
Depth attachment is based on the image same as colour attachment. The difference is that Swap chain will not create depth attachment for us by default, thus we have to create one. We will not need 3 images since only one depth is used per draw call.

This will require 3 well known resources `VkImage`, `VkDeviceMemory` and `VkImageView`. We will create them and store them as class members. Next we will create function that will create those resources.

The creation of depth image should be straight forward. It should be same with and height of the swap chain extent, right tilling and device local memory. The format will be specified by `VK_FORMAT_D???`

We can choose from the following
- `VK_FORMAT_D32_SFLOAT` - 32-bit float depth
- `VK_FORMAT_D32_SFLOAT_S8_UINT` - 32-bit float and 8-bit unsigned integer stencil buffer
- `VK_FORMAT_D24_UNORM_S8_UINT:` -  24-bit float for depth and 8 bit stencil component

We could go with 32-bit float depth but it might not be supported in edge cases devices so we will create a function that will take the depth formats from most desirable to least desirable and use the one that is firstly available.

```c++
inline static VkFormat FinsSupportedFormat(VkPhysicalDevice physicalDevice, VkDevice logicalDevice, std::vector<VkFormat>& candidates, VkImageTiling tiling, VkFormatFeatureFlags) {  
      
}
```

Since the format also depends on the *image tiling* we have included that one as well. We can query supported formats by using 

```c++
VkFormatProperties props;  
vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &props);
```

The `VkFormatProperties` contains 
- `liniearTillingFeatures` formats that support linear tilling
- `optimalTillingFeatures` formats that support optimal tilling
- `buffer features` formats that are supported for buffers
We are going to check either linear tilling or optimal tilling based on the provided `VkImageTilling` in the parameters

```c++
// for linear tiling  
if(tiling == VK_IMAGE_TILING_LINEAR && (props.linearTilingFeatures & features) == features) {  
    return format;  
}  
// for optimal tiling  
else if (tiling == VK_IMAGE_TILING_OPTIMAL && (props.optimalTilingFeatures & features) == features) {  
    return format;  
}
```

We will now create yet another helper function that will set up the parameters and retrieve  the right depth buffer format

```c++
return FinsSupportedFormat(m_physicalDevice, m_device, 
						   {VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT}, 
						   VK_IMAGE_TILING_OPTIMAL, VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT);
```

> NOTE: we must not use `VK_IMAGE_USAGE` instead of the `VK_FORMAT_FEATURE`