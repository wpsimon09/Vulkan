Vulkan does not have default pipeline stages, therefore we have to be explicit about everything and fill in all of the little details, like depth testing, colour blending, anti aliasing and much more. 

## Dynamic state
Since pipeline will be baked into imputable (non-changeable) state everything needs to be predefined. Except for few things such as: *View port size, line width and bland constants*. We will specify that we want dynamic values by populating the `VkPipelineDynamicStateCreateInfo` struct. 

This values **will have to be set up during render time**

```c++
std::vector<VkDynamicState> dynamicStates = {  
    VK_DYNAMIC_STATE_VIEWPORT,  
    VK_DYNAMIC_STATE_SCISSOR  
};  
  
VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo{};  
dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;  
dynamicStateCreateInfo.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());  
dynamicStateCreateInfo.pDynamicStates = dynamicStates.data();
```

## Vertex input 
Specifies exactly what `glVertexAtribbArray` function. That is spacing between various kind of data formats, binding points in vertex shader etc.

Since we hard coded everything in vertex shader we will leave this stage at defaults.

In order to fill in this stage we will utilise the `VkPiplineVertexInputStateCreateInfo` structure.

```c++
VkPipelineVertexInputStateCreateInfo vertexInputInfo{};  
vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;  
vertexInputInfo.vertexBindingDescriptionCount = 0;  
vertexInputInfo.pVertexBindingDescriptions = nullptr;  
vertexInputInfo.vertexAttributeDescriptionCount = 0;  
vertexInputInfo.pVertexAttributeDescriptions = nullptr;
```
 `pVertexBindingDescripitions` and `pVertexAttributeDescription` points to the array of structs that describe the information about the vertex arrays.

