Vulkan does not have default pipeline stages, therefore we have to be explicit about everything and fill in all of the little details, like depth testing, colour blending, anti aliasing and much more. 

## Dynamic state
Since pipeline will be baked into imputable (non-changeable) state everything needs to be predefined. Except for few things such as: *View port size, line width and bland constants*. We will specify that we want dynamic values by populating the `VkPipelineDynamicStateCreateInfo` struct. 

This values **will have to be set up during render time**

```c++
std::vector<VkDynamicState> dynamicStates = {  
    VK_DYNAMIC_STATE_VIEWPORT,  
    VK_DYNAMIC_STATE_SCISSOR  
};  
  
VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo{};  
dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;  
dynamicStateCreateInfo.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());  
dynamicStateCreateInfo.pDynamicStates = dynamicStates.data();
```

## Vertex input 
Specifies exactly what `glVertexAtribbArray` function. That is spacing between various kind of data formats, binding points in vertex shader etc.

Since we hard coded everything in vertex shader we will leave this stage at defaults.

In order to fill in this stage we will utilise the `VkPiplineVertexInputStateCreateInfo` structure.

```c++
VkPipelineVertexInputStateCreateInfo vertexInputInfo{};  
vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;  
vertexInputInfo.vertexBindingDescriptionCount = 0;  
vertexInputInfo.pVertexBindingDescriptions = nullptr;  
vertexInputInfo.vertexAttributeDescriptionCount = 0;  
vertexInputInfo.pVertexAttributeDescriptions = nullptr;
```
 `pVertexBindingDescripitions` and `pVertexAttributeDescription` points to the array of structs that describe the information about the vertex arrays.

## Input assembly
Tells how to put together primitives and which ones from the specified vertices. On top of that we can specify if the triangles should repeat after each other by using `topology` member of the `VkPipelineInputAssemblyStateCreateInfo` structure

It can have the following values
- `VK_PRIMITIVE_TOPOLOGY_POINT_LIST` - make points from vertices
- `VK_PRIMITIVE_TOPOLOGY_LINE_LIST` -  line from every 2 vertices without reusing them
- `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP` - end vertex of each line is set as start vertex for other line 
- `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST` -triangle from every 3 vertices **without** reuse
- `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP` - second and third vertex are used as fist 2 vertices of the next. 

The vertices are indexed in sequential order we can use own indexing using *element buffers* but we would have to use special index of `OxFFFF`.

To use element buffers we would have to set the topology to `xxx_STRIP` and set `primitiesRestartEnable` to `VK_TRUE`

We are going to stick with the `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST` and fill in the struct as follows

```c++
VkPipelineInputAssemblyStateCreateInfo inputAssemblyCreateInfo{};  
inputAssemblyCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;  
inputAssemblyCreateInfo.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;  
inputAssemblyCreateInfo.primitiveRestartEnable = VK_FALSE;
```