Here everything will come together. We are going to create `drawFrame` function that will be called from the main loop of the application

The rendering of the frame looks briefly like this 
- Wait for previous frame to finish rendering 
- Acquire new image to draw into
- Record the command buffer that will draw the scene to the acquired image 
- submit the recorded command buffer 
- present the swap chain image 

In Vulkan multiple operations execute at once and they return something before they are actually done. It is up to use to determine when should next operation begin.

To do that we have set of primitives. Namely:
**Semaphore** and **Fence** they act like switches. Once a operation is finished either one will go the the *active* state signalising that next operation can begin.  

## Semaphore

It is used to add order in operations either withing the queue or between different queues.

We can submit operations to the queue either by using the command buffer or in the function. There are 2 semaphores in Vulkan. **Binary** and **Timeline**. We will not discuss the timeline semaphore here. 

It has 2 states **signal** and **unsignalled**. When Semaphore is created it will always start as **unsignalled**. 

Semaphores are only forcing GPU work to wait not the CPU (host) site to wait.

## Fences

They work exactly like semaphores with an exception that they stall the CPU (host) execution

Fences mainly are there to synchronise CPU work with the GPU work. We don't want to send 1000 commands while GPU did not finish processing the 1st one. 

Therefore we will wait for the GPU to be finished. 

## Where to use them
In our application we have to places to synchronise: *Swap chain* and *waiting for the previous frame* to finish. 

For the swap chain operations such as rendering etc.. we want to use **Semaphore** and for the waiting for the frame to be rendered we will use the **Fence** so that we do not override the image that is being rendered into. Additional reason to use Fence is that we will record command buffer every frame and we don't want to override the current frame. 

## Implementation
We will need:
- Semaphore: to signal that image has been acquired from the swap chain
- Another semaphore: to signal that rendering is finished and presentation can now happen
- Fence: to determine when the next frame should be acquired. 

We will use `VkSemaphore` and `VkFence` objects to store the state of them

```c++
//no other features
VkSemaphoreCreateInfo semaphoreInfo{};  
semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;  

//no other features
VkFenceCreateInfo fenceInfo{};  
fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;  
  
if(vkCreateSemaphore(m_device, &semaphoreInfo, nullptr, &m_imageAvailableSemaphore) != VK_SUCCESS ||  
   vkCreateSemaphore(m_device, &semaphoreInfo, nullptr, &m_renderFinishedSemaphore) != VK_SUCCESS ||  
   vkCreateFence(m_device, &fenceInfo, nullptr, &m_inFlightFence) != VK_SUCCESS  
   ) {  
    throw std::runtime_error("Failed to create synchronization objects");  
}
```

And we should delete it when no synchronisation is needed  

```c++
vkDestroySemaphore(m_device, m_imageAvailableSemaphore, nullptr);  
vkDestroySemaphore(m_device, m_renderFinishedSemaphore, nullptr);  
vkDestroyFence(m_device, m_inFlightFence, nullptr);  
vkDestroyCommandPool(m_device, m_comandPool, nullptr);
```

## Waiting for the next frame 

Now we will focus on the `drawFrame` method. Before we can do anything here we have to wait for the previous frame until it is finished. We do this by waiting for the *fence* until it is in deactivated state. Using the following function `VkWaitForFences`

```c++
vkWaitForFences(m_device, 1, &m_inFlightFence, VK_TRUE, UINT64_MAX);
```
First parameter is the logical device, second is the fence(s) we are waiting for, fourth is marking if the CPU should continue after all of the fences in the provided array are available, and last one is the timeout which we will disable by passing maximum value of `UINT64`

After waiting we also have to manually set the fence to the **unsignaled** state using `vkResetFences`

```c++
vkResetFences(m_device, 1, &m_inFlightFence);
```
Since we are waiting for the frames to be finished the fence we have set up will be blocking CPU infinetly as during the first frame there is no other frame to wait for thus we will never get over the inactive state of the fence during the rendering of the first frame.

To overcome this issue we will set the fence to be active so that it can be signalled in order to continue onto the next frame. 
To do this we will add `VK_FENCE_CREATE_SIGNALED_BIT` to the `flags` field during the fence creation process.

```c++
VkFenceCreateInfo fenceInfo{};  
fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;  
fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;
```

