In Vulkan drawing is not executed via single function calls like `glDrawArrays` every call is recorded to the **command buffer** and is send to the GPU at once. This have advantages like multi-thread rendering, and optimisations.

Before we can issue commands to the command buffer we have to first create a **command pool** they manage memory. Subsequently command buffers are allocated from the command pools 

We will first create an class member to store the command pool as it will be required later on in the process

```c++
VkCommandPool m_comandPool;
```

We can now create command pool. First we will populate struct `VkCommandPoolCreateInfo` with following information:

```c++
QueueFamilyIndices queueFamilyIndices = FindQueueFamilies(m_physicalDevice, m_sruface);  
  
VkCommandPoolCreateInfo poolInfo{};  
poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;  
poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;  
poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();

if(vkCreateCommandPool(m_device, &poolInfo, nullptr, &m_comandPool) != VK_SUCCESS) {  
    throw std::runtime_error("Failed to create command pool !");  
}
```

We have first retrieved the queue family for graphics operations as we are going to execute drawing operations from our command buffer. 

The `flags` field of the struct can have 2 different flags:
- `VK_COMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` to say that we want to reset the command buffers individually if this flag was not there all command buffers would behave the same 
- `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT` this is noting that the command buffer is going to be recorded with new command very often meaning that commands from it will vary (graphics, compute, memory management, etc.) 

Lastly we must not forget to delete the command pool using `vkDestroyCommandPool` function.



