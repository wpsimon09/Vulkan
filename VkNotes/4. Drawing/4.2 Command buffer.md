In Vulkan drawing is not executed via single function calls like `glDrawArrays` every call is recorded to the **command buffer** and is send to the GPU at once. This have advantages like multi-thread rendering, and optimisations.

Before we can issue commands to the command buffer we have to first create a **command pool** they manage the memory. Subsequently command buffers are allocated from the command pools 

We will first create an class member to store the command pool as it will be required later on in the process

```c++
VkCommandPool m_comandPool;
```

We can now create command pool. First we will populate struct `VkCommandPoolCreateInfo` with following information:

```c++
QueueFamilyIndices queueFamilyIndices = FindQueueFamilies(m_physicalDevice, m_sruface);  
  
VkCommandPoolCreateInfo poolInfo{};  
poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;  
poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;  
poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();

if(vkCreateCommandPool(m_device, &poolInfo, nullptr, &m_comandPool) != VK_SUCCESS) {  
    throw std::runtime_error("Failed to create command pool !");  
}
```

We have first retrieved the queue family for graphics operations as we are going to execute drawing operations from our command buffer. 

The `flags` field of the struct can have 2 different flags:
- `VK_COMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` to say that we want to reset the command buffers individually if this flag was not there all command buffers would behave the same 
- `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT` this is noting that the command buffer is going to be recorded with new command very often meaning that commands from it will vary (graphics, compute, memory management, etc.) 

Lastly we must not forget to delete the command pool using `vkDestroyCommandPool` function.

## Command buffer allocation

The command buffer allocation is done based on the command pool. The command buffer is stored within the `VkCommandBuffer` object. We **do not** need to explicitly delete this as it will be deleted by the associated command pool

The creation of the command buffer is as expected.

```c++
VkCommandBufferAllocateInfo allocInfo{};  
allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;  
allocInfo.commandPool = m_comandPool;  
allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;  
allocInfo.commandBufferCount = 1;  
  
if(vkAllocateCommandBuffers(m_device,&allocInfo,&m_commandBuffer) != VK_SUCCESS) {  
    throw std::runtime_error("Failed to allocate command buffer");  
}
```
`commandPool` field is specifying the command pool we have previously created.
`level` field specifies if the command buffer is **primary** or **secondary**. 
- If they are primary they can be submitted directly to the queue to be executed but can not be called from other command buffers
- If they are secondary they **can not** be submitted directly to the queue to be executed but can be called from the primary command buffers 
`commandBufferCount` is one as we only allocate only 1 command buffer

