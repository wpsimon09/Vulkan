As mentioned we have to transition the image to the layout that is suitable for the GPU. We will utilise Command buffer for this, hence we should abstract this functionality its own function. 

We will use code from `copyBffers` function which copied buffer data from one `VkBuffer` to another.

It will create a command buffer and return it so that we can record any command to it regardless of the usage.

```c++
static inline void CopyBuffer(VkDevice logicalDevice,VkQueue transferQueue,VkCommandPool transferCommandPool,VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {  
  
    VkCommandBuffer commandBuffer = BeginSingleTimeCommand(logicalDevice, transferCommandPool);  
  
    VkBufferCopy copyRegion{};  
    copyRegion.srcOffset = 0;  
    copyRegion.dstOffset = 0;  
    copyRegion.size = size;  
    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer,1,&copyRegion);  
  
    EndSingleTimeCommand(logicalDevice, transferCommandPool, commandBuffer, transferQueue);  
}
```

Now we can create function that will transform the layout of the images.
To pass in the dependencies like logical device, command buffer pool and queue handler I have created a struct to pack all of this together 

```c++
struct ImageLayoutDependencyInfo {  
    VkDevice logicalDevice;  
    VkCommandPool commandPool;  
    VkQueue transformQueue;  
};
```

The function that will transform the layout of the images will look like this. To copy the data from one buffer to the image we can just call `vkCmdCopyBufferToImage` this naturally requires the image to be in right format. 

```c++
static inline void TransitionImageLayout(ImageLayoutDependencyInfo dependencyInfo,VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout) {  

    VkCommandBuffer commandBuffer = BeginSingleTimeCommand(dependencyInfo.logicalDevice, dependencyInfo.commandPool);  

EndSingleTimeCommand(dependencyInfo.logicalDevice, dependencyInfo.commandPool, commandBuffer, dependencyInfo.transformQueue);  
}
```

One of the most common ways to preform Image layout transition is to use *memory barrier*. In the pipeline they are used to ensure that for example writing to the buffer is finished before reading from it. Additionally it can be use to transfer owner ship between queue families when `VK_SHARING_MODE_EXCLUSIVE` is used. The equivalent suited for images and buffer transition is therefore called **buffer memory barrier**

We will create image barrier by populating `VkImageMemoryBarier` struct.

```c++
VkImageMemoryBarrier barrier{.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER};  
barrier.oldLayout = oldLayout;  //could be VK_IMAGE_LAYOUT_UNDEFINED if we dont care about previous layout
barrier.newLayout = newLayout;

// if used to transfer owner ship this should be the index of the queue family
barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;  
barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
```

Next we will specify the image and sub resource details

```c++
barrier.image = image;  
barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;  
barrier.subresourceRange.baseMipLevel = 0;  
barrier.subresourceRange.levelCount = 1;  
barrier.subresourceRange.baseArrayLayer = 0;  
barrier.subresourceRange.layerCount = 0;

barrier.srcAccessMask = 0;  
barrier.dstAccessMask = 0;
```

Since barriers are mainly for synchronisation we must specify which operations that evolve the image must be completed barrier and which orations will have to wait for the barrier. For now we will set this to be 0 and return here later once we know what image layout we will use.

Now we can dispatch the command and record it to the command buffer (screen shot for the parameters since it is quite some function)

![[vkCmdPipelineBarier.png]]

```c++
vkCmdPipelineBarrier( 
commandBuffer, // The command buffer in which the barrier is recorded.
srcStageMask, // The pipeline stage(s) before the barrier (e.g., fragment shader). 
dstStageMask, // The pipeline stage(s) after the barrier (e.g., vertex shader). 
dependencyFlags, // Special flags to specify the type of dependency.
memoryBarrierCount, // Number of memory barriers. 
pMemoryBarriers, // Pointer to an array of memory barriers. 
bufferMemoryBarrierCount, // Number of buffer memory barriers. 
pBufferMemoryBarriers, // Pointer to an array of buffer memory barriers. 
imageMemoryBarrierCount,// Number of image memory barriers. 
pImageMemoryBarriers // Pointer to an array of image memory barriers. );
```


The first parameter after the command buffer specifies pipeline stages in which operations occur (layout transition) that should happen before the barrier. The next parameter specifies what operations happen after the barrier and in what pipeline stages.

What pipeline stage you can specify depends on how you use the resource before and after the barrier. 

## Copying buffer to image
Before we can move on we will write one last helper function that will copy the buffer to the image 

We will start by populating the `VkBufferImageCopy` struct

```c++
VkBufferImageCopy region{}; 
//passing 0 to those fields indicates that our data are tighly packed in the buffer and there is no offest
region.bufferOffset = 0;  
region.bufferRowLength = 0;  //padding bites in rows of some images  
region.bufferImageHeight = 0;  

//int owhich reagion of the image we want to copy information
region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; //we can also do depth if we are coping depth information  
region.imageSubresource.mipLevel = 0;  
region.imageSubresource.baseArrayLayer = 0;  
region.imageSubresource.layerCount = 1;   

//dimentions of the image 
region.imageOffset={0,0,0};  
region.imageExtent = {width, height,1};
```

Now we can record the command buffer to copy the data between buffer and image

```c++
vkCmdCopyBufferToImage(commandBuffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);
```

> here we assume that the image was already transition to the format that is most optimal for copying pixels to by specifying the parameter which informs Vulkan about the image layout that the image is currently in which is not case right now but will be


## Preparing the texture image 

We now have all the tools that we need to copy the data to the image.

There are 2 more steps we need to do.
- Transition the image to the `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` using `TransferImageLayout` helper function 
- Copy the buffers using `CopyBufferToImage` helper function

We will go back to the `VulkaApp::CreateTextureImage` function and do this. Since we have created the helper function before head the code does exactly what is described above. It transforms the image so that it is suitable as copy destination and subsequently copy data from buffer to the image. 

```c++
  
ImageLayoutDependencyInfo dependencyInfo{};  
dependencyInfo.commandPool = m_transferCommandPool;  
dependencyInfo.logicalDevice = m_device;  
dependencyInfo.transformQueue = m_transferQueue;  

TransferImageLayout(
dependencyInfo,
m_textureImage, 
imageCreateInfo.format,
VK_IMAGE_LAYOUT_UNDEFINED, //layout can be undefined as we dont care about the data that were previously in the buffer as they will get rewritten
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);  
  
CopyBufferToImage(dependencyInfo,stagingImageBuffer, m_textureImage, static_cast<uint32_t>(texWidth),static_cast<uint32_t>(texHeight));
```

To use the image in the sampler we have to transition it one more time to the format that is suitable for the shader.

```c++
  
TransferImageLayout(dependencyInfo, m_textureImage, imageCreateInfo.format,VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
```