To make the geometry more realistic we will implement textures. This will allow us to also load and display models.

The high level overview of loading textures looks like this.

- Create an image object that is backed by the device memory.
- Fill in the memory with a pixel from the image
- Create an image sampler 
- Add image sampler to the descriptor to send it to the shader where we can sample colours from the image and apply it to the geometry

We have already worked with images, but they were crated by swap chain. This time we will create the images from scratch. The process is quite similar to buffer creation. We will create staging `VkBuffer`, fill it in with pixel data and send it to the `VkImage` that will be used for rendering.

However we have to take care of the image format depending on the operation we are going to preform with the image. We can choose from the following image layouts.

- `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`  - used for presenting the image 
- `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` - used for writing fragment shader results into it
- `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` - used as source for transfer operations like during `vkCmdCopyImageBuffer` 
- `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` - used as a destination for transfer operation
- `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` - used for sampling the image in the fragment shader 

To transition the layout of image we will utilise *pipeline barrier*. This can be used to transfer the owner ship of the queues that are flagged as `VK_SHARING_MODE_EXCLUSIVE`. But **mostly** pipeline barriers are used for synchronisation. That is, for example, making sure that image has been written into before it is read.

For loading images we will use `stb_image.h` .

## Implementation

We will create function that will load the image and upload it to the Vulkan. Since we will use command buffer this method should be created **before** we have created command pool

```c++
int texWidth, texHeight, texChanels;  
stbi_uc* pixels = stbi_load("Textures/texture.jpg", &texWidth, &texHeight, &texChanels, STBI_rgb_alpha);  
  
// times 4 because we have RGBA  
VkDeviceSize imageSize = texWidth * texHeight * 4;  
  
if(!pixels) {  
    throw std::runtime_error("Failed to load textue");  
}
```

Now we can create staging buffer and staging memory in order to temporally load the texture.

```c++
VkBuffer stagingImageBuffer;  
VkDeviceMemory stagingImageMemory;  

BufferCreateInfo bufferInfo;  
bufferInfo.physicalDevice = m_physicalDevice;  
bufferInfo.logicalDevice = m_device;  
bufferInfo.surface = m_sruface;  
bufferInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;  
bufferInfo.properties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;  
bufferInfo.size = imageSize;  
CreateBuffer(bufferInfo, stagingImageBuffer, stagingImageMemory);  

stbi_image_free(pixels);  
```

## Texture image

Although we can use buffer directly in the shader, it is not the best thing to do. We are going to store the pixels (texels) inside the `VkImage` this will allow us to access individual texels with `UV` coordinates. And it is easier and faster to implement.

We are going to need the images through the program so we will store it as class members.

```c++

```