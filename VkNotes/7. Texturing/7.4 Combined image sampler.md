
To access images in shaders we will use the *sampler* created previously. To pass the sampler together with an image we will use descriptors. More closely, we will use **combined image sampler** 

We will start by modifying descriptor layout, descriptor pool and descriptor set to include the combined image sampler. 

## Updating descriptors

We will start by modifying the bindings which are combined together to the **descriptor set layout** and are created in `CreateDescriptorSetLayout` method. 

```c++
VkDescriptorSetLayoutBinding uboLayoutBinding{};  
uboLayoutBinding.binding = 0;  
uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;  
uboLayoutBinding.descriptorCount = 1;  
uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;  
uboLayoutBinding.pImmutableSamplers = nullptr;  
  
VkDescriptorSetLayoutBinding imageSamplerLayoutBinding{};  
imageSamplerLayoutBinding.binding = 1;  
imageSamplerLayoutBinding.descriptorCount = 1;  
imageSamplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;  
imageSamplerLayoutBinding.pImmutableSamplers = nullptr;  
imageSamplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;  
  
std::array<VkDescriptorSetLayoutBinding,2> bindings = {uboLayoutBinding, imageSamplerLayoutBinding};  
  
VkDescriptorSetLayoutCreateInfo layoutInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO};  
layoutInfo.bindingCount = static_cast<uint32_t>(bindings.size());  
layoutInfo.pBindings = &bindings.data();  
layoutInfo.pNext = nullptr;
```

This code is pretty self explanatory, we have created new `VkDescriptorSetLayout` that has special type of `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` and we have noted that this sampler will be accessed in **Fragment shader**

Since we have changed the layout we also must increase the size of the descriptor pool. We will modify its creation by including sampler and image to the `VkDescriptorPoolCreateInfo`

```c++
std::array<VkDescriptorPoolSize,2> poolSizes{};  
// for UBO  
poolSizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;  
poolSizes[0].descriptorCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);  
  
// for Sampler  
poolSizes[1].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;  
poolSizes[1].descriptorCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);  
  
VkDescriptorPoolCreateInfo poolInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO};  
poolInfo.poolSizeCount = static_cast<uint32_t>(poolSizes.size());  
poolInfo.pPoolSizes = poolSizes.data();  
poolInfo.maxSets = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);  
  
if(vkCreateDescriptorPool(m_device, &poolInfo, nullptr, &m_descriptorPool) != VK_SUCCESS) {  
    throw std::runtime_error("Failed to create descriptor pool");  
}
```

Now we can bind the image and sampler to the descriptors in the `CreateDescriptorSet` method.

First we will create `VkDescriptorImageInfo` struct to pass the image sampler and the image view (through which we access the actual image).

```c++
for(size_t i = 0; i<MAX_FRAMES_IN_FLIGHT; i++) {  
    VkDescriptorBufferInfo bufferInfo{};  
    bufferInfo.buffer = m_uniformBuffers[i];  
    bufferInfo.offset = 0;  
    bufferInfo.range = VK_WHOLE_SIZE;  
  
    VkDescriptorImageInfo imageInfo{};  
    imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;  
    imageInfo.imageView = m_textureImageView;  
    imageInfo.sampler = m_textureSampler;
```

Finally we can now update the `VkWrtieDescriptorSet` struct to include the image as well.

```c++

```