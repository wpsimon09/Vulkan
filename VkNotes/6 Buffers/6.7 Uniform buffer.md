Since **model**, **view** and **projection** tend to change almost ever frame it is not wise to put the as a vertex attributes. In Vulkan this is done through the *resource descriptors*. They allow shaders to freely access resources such as buffer and images.

We will create buffer that contains those transformation metrics and we will use the *descriptor* to access them in shader. 

The creation and usage of descriptor looks like this:
- specify the descriptor layout - only **specifies** the **types** of the resources that are going to be used, much like render pass 
- allocate the descriptor set from the descriptor pool - specifies the actual resources (buffers, images)
- bind description set during rendering 

There are many different descriptor sets but we will focus on the *Uniform buffer objects* (UBO).

Lets suppose we have the following C struct 
```c++
struct UniformBufferObject {  
    glm::mat4 model;  
    glm::mat4 view;  
    glm::mat4 projection;  
};
```

we will use this struct to fill in `VkBuffer` and update it each frame in order to implement camera or some other transformations.

First we have to modify the vertex shader like so

```c++
layout (binding = 0) uniform UnifromBufferObject {  
    mat4 model;  
    mat4 view;  
    mat4 proj;  
}ubo;  
      
layout (location = 0) in vec2 inPosition;  
layout (location = 1) in vec3 inColor;  
layout (location = 0) out vec3 color;  
  
void main() {  
    gl_Position = ubo.proj* ubo.view * ubo.model * vec4(inPosition,0.0,1.0);  
    color =  inColor;  
}
```

During descriptor layout creation in graphics pipeline we are going to be referencing the `binding = 0`

Now we have to tell Vulkan the created descriptor and use the struct crated earlier to fill it in. We will have to provide information about every descriptor binding used in the shader same way we did with vertex array attributes. [[6.1 Vertex input description]]

We can now crate `VkDescriptorSetLayoutBinding` struct that will describe the binding used in shader 

```c++
VkDescriptorSetLayoutBinding uboLayoutBinding{};  
uboLayoutBinding.binding = 0;  
uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;  
uboLayoutBinding.descriptorCount = 1;
```

`binding` specifies the binding location in shader, it is possible to for shader variable to hold an array of uniform buffer objects, for instance MVP for each bone in skeletal animation. Which is why we can pass an array to the `descriptorType` .

Next we specify at which shader the UBO is accessed. 

```c++
uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT; //we can use the VK_SHADER_STAGE_ALL to specify all saders

//only for image samplers (we will do this later in texture chapters)
uboLayoutBinding.pImmutableSamplers = nullptr;
```

All of the descriptor bindings are combined together in `VkDescriptorSetLayout`. Which has to be stored for the future reference.

```c++
VkDescriptorSetLayout descriptorSetLayout;
```

To fill it in we have to populate the `VkDescriptorSetLayoutCreateInfo` struct with the array of `VkDescriptorSetLayoutBinding`

```c++
VkDescriptorSetLayoutCreateInfo layoutInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO};  
layoutInfo.bindingCount = 1;  
layoutInfo.pBindings = &uboLayoutBinding;  
layoutInfo.pNext = nullptr;  
  
if(vkCreateDescriptorSetLayout(m_device, &layoutInfo, nullptr, &descriptorSetLayout) != VK_SUCCESS) {  
    throw std::runtime_error("Failed to create descriptor set layout");  
};
```

