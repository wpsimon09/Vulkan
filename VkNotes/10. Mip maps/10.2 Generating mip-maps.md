Our staging buffer while creating image is only used to fill in mip map at level 0. We will generate the data from the base mip level that we have available and use `vkCmdBlitImage` to scale, copy and filter the data. This command will be called multiple times, for every mip level.

Since we are going to use the base image as a both the **source** and **destination** during the `vkCmdBlitImage` (which is considered a transfer operation ) we have to tell it to Vulkan by specifying `VK_IMAGE_USAGE_TRANSFER_SRC_BIT`

```c++
imageCreateInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
```

>NOTE: We are going to be working with 2 mip levels. First one is the previous mip image (src) in the mip chain and second one is the new mip level that we are filling in (dst) 

Similar to other image operations *blitting* image data depends on the image layout. Simple solution is to transfer the image  to the `VK_IMAGE_LAYOUT_GENERAL` but this might be slow. 

For the best performance the mip level that was generated before should have layout of `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` and the one that we are generating should have layout of `VK_IMAGE_LAYOUT_TRNASFER_DST_OPTIMAL`

We will transition each level into the corresponding format between the blits.

We will start of by removing the transition to the `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`. We will transition to this stage for once we have generated mip chain.

```c++
CreateImage(imageCreateInfo, m_material->GetTextures()[texturesToProcess[i]].image, m_material->GetTextures()[texturesToProcess[i]].memory);  
  
TransferImageLayout(dependencyInfo, m_material->GetTextures()[texturesToProcess[i]].image, imageCreateInfo.format, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,m_material->GetTextures()[texturesToProcess[i]].maxMipLevels);  
  
CopyBufferToImage(dependencyInfo,stagingImageBuffer, m_material->GetTextures()[texturesToProcess[i]].image, static_cast<uint32_t>(texWidth),static_cast<uint32_t>(texHeight));  
  
//TransferImageLayout(dependencyInfo, m_material->GetTextures()[texturesToProcess[i]].image, imageCreateInfo.format,VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,m_material->GetTextures()[texturesToProcess[i]].maxMipLevels);  
FlushCommandBuffer(dependencyInfo.commandBuffer);
```

By removing transition to the `VK_IMAGE_LAYOUT_SHADER_READ_OPTIMAL` we leave the image in the `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` 

Now we can write function that will generate mip maps 

```c++
void GenerateMipMaps(ImageLayoutDependencyInfo dependency, VkImage image, uint32_t width, uint32_t height, uint32_t mipLevels) {  
    VkImageMemoryBarrier barrier{.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER};  
    barrier.image = image;  
    //not transitioning owenership  
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;  
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;  
  
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;  
    barrier.subresourceRange.baseArrayLayer = 0;  
    barrier.subresourceRange.layerCount = 1;  
    barrier.subresourceRange.levelCount = 1;
```

This `VkImageMemoryBarrier` will be used for each transition. Fields we have specified will remain the same, but `subresourceRange.mipLevel`, `subresourceRange.newLayout`, `subresourceRange.oldLayout`,  `srcAccessMask` and `dstAccessMask` will be changed after every transition of the layout.

