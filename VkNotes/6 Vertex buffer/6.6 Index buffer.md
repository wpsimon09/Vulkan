It is used to not replicate the redundant vertices. We will use index to specify which vertices to draw where. OpenGL equivalent to this is `ElementBufferObject (EBO)` 

![[Index vs vertex buffer.png]]
We will start of by changing the vertices of the triangle to contain 4 corners 

```c++
const std::vector<Vertex> vertices = {  
    {{-0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}},  
    {{0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}},  
    {{0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}}  
    {{-0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}}  
};
```

Now we can create the index buffer

```c++
const std::vector<uint16_t> indices = {  
    0, 1, 2, 2, 3, 0  
};
```

We can either use `uint16_t` or `uint32_t` depending on the amount of indices we are going to be using. If we were to use more than 6600 we should opt for the `uint32_t`. Same as for the vertex buffer indices will be stored in class member variable in `VkBuffer` type

```c++
VkBuffer m_indexBuffer;  
VkDeviceMemory m_indexBufferMemory;
```

The creation of the index buffer is identical to the creation of the vertex buffer. We will first put data to the staging buffer and copy them to the fastest possible memory type. This memory type is flagged with `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`
The usage of the index buffer should be marked with `VK_BUFFER_USAGE_INDEX_BUFFER_BIT`