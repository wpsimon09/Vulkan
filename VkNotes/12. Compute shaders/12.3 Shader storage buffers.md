We will create a shader storage buffer that will hold array of particles which we can manipulate directly on the GPU. 

We will have to duplicate this so that CPU and GPU stay busy during frame rendering. Since we use frames in flight CPU can pass the altered data to the *vertex shader* while compute shader is manipulating the new batch of particle data.

We will create the `std::vector` of `VkBuffer` and back it up with `VkDeviceMemory`

```c++
std::vector<VkBuffer> m_shaderStorageBuffer;  
std::vector<VkDeviceMemory> m_shaderStorageBufferMemory;
```

Next we can create the particle struct that will hold the information about each particle 

```c++
struct Particle {  
    glm::vec2 position;  
    glm::vec2 velocity;  
    glm::vec4 color;  
};
```

Now in `CreateShaderStorageBuffer` (we have to create it) method we will resize the buffer and storage to match the maximum number of frame in flight 

```c++
void VulkanApp::CreateShaderStorageBuffer() {  
    m_shaderStorageBuffer.resize(MAX_FRAMES_IN_FLIGHT);  
    m_shaderStorageBufferMemory.resize(MAX_FRAMES_IN_FLIGHT);
    
```
