        -:    0:Source:/usr/include/glm/detail/func_exponential.inl
        -:    0:Graph:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/Camera/Camera.cpp.gcno
        -:    0:Data:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/Camera/Camera.cpp.gcda
        -:    0:Runs:1
        -:    1:/// @ref core
        -:    2:/// @file glm/detail/func_exponential.inl
        -:    3:
        -:    4:#include "../vector_relational.hpp"
        -:    5:#include "_vectorize.hpp"
        -:    6:#include <limits>
        -:    7:#include <cmath>
        -:    8:#include <cassert>
        -:    9:
        -:   10:namespace glm{
        -:   11:namespace detail
        -:   12:{
        -:   13:#	if GLM_HAS_CXX11_STL
        -:   14:		using std::log2;
        -:   15:#	else
        -:   16:		template<typename genType>
        -:   17:		genType log2(genType Value)
        -:   18:		{
        -:   19:			return std::log(Value) * static_cast<genType>(1.4426950408889634073599246810019);
        -:   20:		}
        -:   21:#	endif
        -:   22:
        -:   23:	template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
        -:   24:	struct compute_log2
        -:   25:	{
        -:   26:		GLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& v)
        -:   27:		{
        -:   28:			GLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, "'log2' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
        -:   29:
        -:   30:			return detail::functor1<vec, L, T, T, Q>::call(log2, v);
        -:   31:		}
        -:   32:	};
        -:   33:
        -:   34:	template<length_t L, typename T, qualifier Q, bool Aligned>
        -:   35:	struct compute_sqrt
        -:   36:	{
        -:   37:		GLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x)
        -:   38:		{
        -:   39:			return detail::functor1<vec, L, T, T, Q>::call(std::sqrt, x);
        -:   40:		}
        -:   41:	};
        -:   42:
        -:   43:	template<length_t L, typename T, qualifier Q, bool Aligned>
        -:   44:	struct compute_inversesqrt
        -:   45:	{
        -:   46:		GLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x)
        -:   47:		{
        -:   48:			return static_cast<T>(1) / sqrt(x);
        -:   49:		}
        -:   50:	};
        -:   51:
        -:   52:	template<length_t L, bool Aligned>
        -:   53:	struct compute_inversesqrt<L, float, lowp, Aligned>
        -:   54:	{
        -:   55:		GLM_FUNC_QUALIFIER static vec<L, float, lowp> call(vec<L, float, lowp> const& x)
        -:   56:		{
        -:   57:			vec<L, float, lowp> tmp(x);
        -:   58:			vec<L, float, lowp> xhalf(tmp * 0.5f);
        -:   59:			vec<L, uint, lowp>* p = reinterpret_cast<vec<L, uint, lowp>*>(const_cast<vec<L, float, lowp>*>(&x));
        -:   60:			vec<L, uint, lowp> i = vec<L, uint, lowp>(0x5f375a86) - (*p >> vec<L, uint, lowp>(1));
        -:   61:			vec<L, float, lowp>* ptmp = reinterpret_cast<vec<L, float, lowp>*>(&i);
        -:   62:			tmp = *ptmp;
        -:   63:			tmp = tmp * (1.5f - xhalf * tmp * tmp);
        -:   64:			return tmp;
        -:   65:		}
        -:   66:	};
        -:   67:}//namespace detail
        -:   68:
        -:   69:	// pow
        -:   70:	using std::pow;
        -:   71:	template<length_t L, typename T, qualifier Q>
        -:   72:	GLM_FUNC_QUALIFIER vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)
        -:   73:	{
        -:   74:		return detail::functor2<vec, L, T, Q>::call(pow, base, exponent);
        -:   75:	}
        -:   76:
        -:   77:	// exp
        -:   78:	using std::exp;
        -:   79:	template<length_t L, typename T, qualifier Q>
        -:   80:	GLM_FUNC_QUALIFIER vec<L, T, Q> exp(vec<L, T, Q> const& x)
        -:   81:	{
        -:   82:		return detail::functor1<vec, L, T, T, Q>::call(exp, x);
        -:   83:	}
        -:   84:
        -:   85:	// log
        -:   86:	using std::log;
        -:   87:	template<length_t L, typename T, qualifier Q>
        -:   88:	GLM_FUNC_QUALIFIER vec<L, T, Q> log(vec<L, T, Q> const& x)
        -:   89:	{
        -:   90:		return detail::functor1<vec, L, T, T, Q>::call(log, x);
        -:   91:	}
        -:   92:
        -:   93:#   if GLM_HAS_CXX11_STL
        -:   94:    using std::exp2;
        -:   95:#   else
        -:   96:	//exp2, ln2 = 0.69314718055994530941723212145818f
        -:   97:	template<typename genType>
        -:   98:	GLM_FUNC_QUALIFIER genType exp2(genType x)
        -:   99:	{
        -:  100:		GLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, "'exp2' only accept floating-point inputs");
        -:  101:
        -:  102:		return std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);
        -:  103:	}
        -:  104:#   endif
        -:  105:
        -:  106:	template<length_t L, typename T, qualifier Q>
        -:  107:	GLM_FUNC_QUALIFIER vec<L, T, Q> exp2(vec<L, T, Q> const& x)
        -:  108:	{
        -:  109:		return detail::functor1<vec, L, T, T, Q>::call(exp2, x);
        -:  110:	}
        -:  111:
        -:  112:	// log2, ln2 = 0.69314718055994530941723212145818f
        -:  113:	template<typename genType>
        -:  114:	GLM_FUNC_QUALIFIER genType log2(genType x)
        -:  115:	{
        -:  116:		return log2(vec<1, genType>(x)).x;
        -:  117:	}
        -:  118:
        -:  119:	template<length_t L, typename T, qualifier Q>
        -:  120:	GLM_FUNC_QUALIFIER vec<L, T, Q> log2(vec<L, T, Q> const& x)
        -:  121:	{
        -:  122:		return detail::compute_log2<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
        -:  123:	}
        -:  124:
        -:  125:	// sqrt
        -:  126:	using std::sqrt;
        -:  127:	template<length_t L, typename T, qualifier Q>
        -:  128:	GLM_FUNC_QUALIFIER vec<L, T, Q> sqrt(vec<L, T, Q> const& x)
        -:  129:	{
        -:  130:		GLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, "'sqrt' only accept floating-point inputs");
        -:  131:		return detail::compute_sqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
        -:  132:	}
        -:  133:
        -:  134:	// inversesqrt
        -:  135:	template<typename genType>
function _ZN3glm11inversesqrtIfEET_S1_ called 0 returned 0% blocks executed 0%
    #####:  136:	GLM_FUNC_QUALIFIER genType inversesqrt(genType x)
        -:  137:	{
    #####:  138:		return static_cast<genType>(1) / sqrt(x);
    %%%%%:  138-block 2
call    0 never executed
        -:  139:	}
        -:  140:
        -:  141:	template<length_t L, typename T, qualifier Q>
        -:  142:	GLM_FUNC_QUALIFIER vec<L, T, Q> inversesqrt(vec<L, T, Q> const& x)
        -:  143:	{
        -:  144:		GLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, "'inversesqrt' only accept floating-point inputs");
        -:  145:		return detail::compute_inversesqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
        -:  146:	}
        -:  147:}//namespace glm
        -:  148:
        -:  149:#if GLM_CONFIG_SIMD == GLM_ENABLE
        -:  150:#	include "func_exponential_simd.inl"
        -:  151:#endif
        -:  152:
