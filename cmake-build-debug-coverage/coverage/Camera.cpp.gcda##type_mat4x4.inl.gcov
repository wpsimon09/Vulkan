        -:    0:Source:/usr/include/glm/detail/type_mat4x4.inl
        -:    0:Graph:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/Camera/Camera.cpp.gcno
        -:    0:Data:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/Camera/Camera.cpp.gcda
        -:    0:Runs:1
        -:    1:#include "../matrix.hpp"
        -:    2:
        -:    3:namespace glm
        -:    4:{
        -:    5:	// -- Constructors --
        -:    6:
        -:    7:#	if GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE
        -:    8:		template<typename T, qualifier Q>
        -:    9:		GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat()
        -:   10:#			if GLM_CONFIG_CTOR_INIT == GLM_CTOR_INITIALIZER_LIST
        -:   11:				: value{col_type(1, 0, 0, 0), col_type(0, 1, 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
        -:   12:#			endif
        -:   13:		{
        -:   14:#			if GLM_CONFIG_CTOR_INIT == GLM_CTOR_INITIALISATION
        -:   15:				this->value[0] = col_type(1, 0, 0, 0);
        -:   16:				this->value[1] = col_type(0, 1, 0, 0);
        -:   17:				this->value[2] = col_type(0, 0, 1, 0);
        -:   18:				this->value[3] = col_type(0, 0, 0, 1);
        -:   19:#			endif
        -:   20:		}
        -:   21:#	endif
        -:   22:
        -:   23:	template<typename T, qualifier Q>
        -:   24:	template<qualifier P>
        -:   25:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<4, 4, T, P> const& m)
        -:   26:#		if GLM_HAS_INITIALIZER_LISTS
        -:   27:			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
        -:   28:#		endif
        -:   29:	{
        -:   30:#		if !GLM_HAS_INITIALIZER_LISTS
        -:   31:			this->value[0] = m[0];
        -:   32:			this->value[1] = m[1];
        -:   33:			this->value[2] = m[2];
        -:   34:			this->value[3] = m[3];
        -:   35:#		endif
        -:   36:	}
        -:   37:
        -:   38:	template<typename T, qualifier Q>
function _ZN3glm3matILi4ELi4EfLNS_9qualifierE0EEC2ERKf called 0 returned 0% blocks executed 0%
    #####:   39:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(T const& s)
        -:   40:#		if GLM_HAS_INITIALIZER_LISTS
    #####:   41:			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0), col_type(0, 0, 0, s)}
    %%%%%:   41-block 2
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   42:#		endif
        -:   43:	{
        -:   44:#		if !GLM_HAS_INITIALIZER_LISTS
        -:   45:			this->value[0] = col_type(s, 0, 0, 0);
        -:   46:			this->value[1] = col_type(0, s, 0, 0);
        -:   47:			this->value[2] = col_type(0, 0, s, 0);
        -:   48:			this->value[3] = col_type(0, 0, 0, s);
        -:   49:#		endif
    #####:   50:	}
        -:   51:
        -:   52:	template<typename T, qualifier Q>
        -:   53:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat
        -:   54:	(
        -:   55:		T const& x0, T const& y0, T const& z0, T const& w0,
        -:   56:		T const& x1, T const& y1, T const& z1, T const& w1,
        -:   57:		T const& x2, T const& y2, T const& z2, T const& w2,
        -:   58:		T const& x3, T const& y3, T const& z3, T const& w3
        -:   59:	)
        -:   60:#		if GLM_HAS_INITIALIZER_LISTS
        -:   61:			: value{
        -:   62:				col_type(x0, y0, z0, w0),
        -:   63:				col_type(x1, y1, z1, w1),
        -:   64:				col_type(x2, y2, z2, w2),
        -:   65:				col_type(x3, y3, z3, w3)}
        -:   66:#		endif
        -:   67:	{
        -:   68:#		if !GLM_HAS_INITIALIZER_LISTS
        -:   69:			this->value[0] = col_type(x0, y0, z0, w0);
        -:   70:			this->value[1] = col_type(x1, y1, z1, w1);
        -:   71:			this->value[2] = col_type(x2, y2, z2, w2);
        -:   72:			this->value[3] = col_type(x3, y3, z3, w3);
        -:   73:#		endif
        -:   74:	}
        -:   75:
        -:   76:	template<typename T, qualifier Q>
        -:   77:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)
        -:   78:#		if GLM_HAS_INITIALIZER_LISTS
        -:   79:			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
        -:   80:#		endif
        -:   81:	{
        -:   82:#		if !GLM_HAS_INITIALIZER_LISTS
        -:   83:			this->value[0] = v0;
        -:   84:			this->value[1] = v1;
        -:   85:			this->value[2] = v2;
        -:   86:			this->value[3] = v3;
        -:   87:#		endif
        -:   88:	}
        -:   89:
        -:   90:	template<typename T, qualifier Q>
        -:   91:	template<typename U, qualifier P>
        -:   92:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<4, 4, U, P> const& m)
        -:   93:#		if GLM_HAS_INITIALIZER_LISTS
        -:   94:			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
        -:   95:#		endif
        -:   96:	{
        -:   97:#		if !GLM_HAS_INITIALIZER_LISTS
        -:   98:			this->value[0] = col_type(m[0]);
        -:   99:			this->value[1] = col_type(m[1]);
        -:  100:			this->value[2] = col_type(m[2]);
        -:  101:			this->value[3] = col_type(m[3]);
        -:  102:#		endif
        -:  103:	}
        -:  104:
        -:  105:	// -- Conversions --
        -:  106:
        -:  107:	template<typename T, qualifier Q>
        -:  108:	template<
        -:  109:		typename X1, typename Y1, typename Z1, typename W1,
        -:  110:		typename X2, typename Y2, typename Z2, typename W2,
        -:  111:		typename X3, typename Y3, typename Z3, typename W3,
        -:  112:		typename X4, typename Y4, typename Z4, typename W4>
        -:  113:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat
        -:  114:	(
        -:  115:		X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
        -:  116:		X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
        -:  117:		X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
        -:  118:		X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
        -:  119:	)
        -:  120:#		if GLM_HAS_INITIALIZER_LISTS
        -:  121:			: value{col_type(x1, y1, z1, w1), col_type(x2, y2, z2, w2), col_type(x3, y3, z3, w3), col_type(x4, y4, z4, w4)}
        -:  122:#		endif
        -:  123:	{
        -:  124:		GLM_STATIC_ASSERT(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
        -:  125:		GLM_STATIC_ASSERT(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
        -:  126:		GLM_STATIC_ASSERT(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
        -:  127:		GLM_STATIC_ASSERT(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");
        -:  128:
        -:  129:		GLM_STATIC_ASSERT(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
        -:  130:		GLM_STATIC_ASSERT(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
        -:  131:		GLM_STATIC_ASSERT(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
        -:  132:		GLM_STATIC_ASSERT(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");
        -:  133:
        -:  134:		GLM_STATIC_ASSERT(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
        -:  135:		GLM_STATIC_ASSERT(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
        -:  136:		GLM_STATIC_ASSERT(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
        -:  137:		GLM_STATIC_ASSERT(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");
        -:  138:
        -:  139:		GLM_STATIC_ASSERT(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
        -:  140:		GLM_STATIC_ASSERT(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
        -:  141:		GLM_STATIC_ASSERT(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
        -:  142:		GLM_STATIC_ASSERT(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");
        -:  143:
        -:  144:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  145:			this->value[0] = col_type(x1, y1, z1, w1);
        -:  146:			this->value[1] = col_type(x2, y2, z2, w2);
        -:  147:			this->value[2] = col_type(x3, y3, z3, w3);
        -:  148:			this->value[3] = col_type(x4, y4, z4, w4);
        -:  149:#		endif
        -:  150:	}
        -:  151:
        -:  152:	template<typename T, qualifier Q>
        -:  153:	template<typename V1, typename V2, typename V3, typename V4>
        -:  154:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2, vec<4, V3, Q> const& v3, vec<4, V4, Q> const& v4)
        -:  155:#		if GLM_HAS_INITIALIZER_LISTS
        -:  156:			: value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}
        -:  157:#		endif
        -:  158:	{
        -:  159:		GLM_STATIC_ASSERT(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
        -:  160:		GLM_STATIC_ASSERT(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
        -:  161:		GLM_STATIC_ASSERT(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
        -:  162:		GLM_STATIC_ASSERT(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");
        -:  163:
        -:  164:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  165:			this->value[0] = col_type(v1);
        -:  166:			this->value[1] = col_type(v2);
        -:  167:			this->value[2] = col_type(v3);
        -:  168:			this->value[3] = col_type(v4);
        -:  169:#		endif
        -:  170:	}
        -:  171:
        -:  172:	// -- Matrix conversions --
        -:  173:
        -:  174:	template<typename T, qualifier Q>
        -:  175:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)
        -:  176:#		if GLM_HAS_INITIALIZER_LISTS
        -:  177:			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
        -:  178:#		endif
        -:  179:	{
        -:  180:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  181:			this->value[0] = col_type(m[0], 0, 0);
        -:  182:			this->value[1] = col_type(m[1], 0, 0);
        -:  183:			this->value[2] = col_type(0, 0, 1, 0);
        -:  184:			this->value[3] = col_type(0, 0, 0, 1);
        -:  185:#		endif
        -:  186:	}
        -:  187:
        -:  188:	template<typename T, qualifier Q>
        -:  189:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)
        -:  190:#		if GLM_HAS_INITIALIZER_LISTS
        -:  191:			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(0, 0, 0, 1)}
        -:  192:#		endif
        -:  193:	{
        -:  194:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  195:			this->value[0] = col_type(m[0], 0);
        -:  196:			this->value[1] = col_type(m[1], 0);
        -:  197:			this->value[2] = col_type(m[2], 0);
        -:  198:			this->value[3] = col_type(0, 0, 0, 1);
        -:  199:#		endif
        -:  200:	}
        -:  201:
        -:  202:	template<typename T, qualifier Q>
        -:  203:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)
        -:  204:#		if GLM_HAS_INITIALIZER_LISTS
        -:  205:			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
        -:  206:#		endif
        -:  207:	{
        -:  208:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  209:			this->value[0] = col_type(m[0], 0);
        -:  210:			this->value[1] = col_type(m[1], 0);
        -:  211:			this->value[2] = col_type(0, 0, 1, 0);
        -:  212:			this->value[3] = col_type(0, 0, 0, 1);
        -:  213:#		endif
        -:  214:	}
        -:  215:
        -:  216:	template<typename T, qualifier Q>
        -:  217:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)
        -:  218:#		if GLM_HAS_INITIALIZER_LISTS
        -:  219:			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0), col_type(0, 0, 0, 1)}
        -:  220:#		endif
        -:  221:	{
        -:  222:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  223:			this->value[0] = col_type(m[0], 0, 0);
        -:  224:			this->value[1] = col_type(m[1], 0, 0);
        -:  225:			this->value[2] = col_type(m[2], 1, 0);
        -:  226:			this->value[3] = col_type(0, 0, 0, 1);
        -:  227:#		endif
        -:  228:	}
        -:  229:
        -:  230:	template<typename T, qualifier Q>
        -:  231:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)
        -:  232:#		if GLM_HAS_INITIALIZER_LISTS
        -:  233:			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
        -:  234:#		endif
        -:  235:	{
        -:  236:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  237:			this->value[0] = m[0];
        -:  238:			this->value[1] = m[1];
        -:  239:			this->value[2] = col_type(0, 0, 1, 0);
        -:  240:			this->value[3] = col_type(0, 0, 0, 1);
        -:  241:#		endif
        -:  242:	}
        -:  243:
        -:  244:	template<typename T, qualifier Q>
        -:  245:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)
        -:  246:#		if GLM_HAS_INITIALIZER_LISTS
        -:  247:			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
        -:  248:#		endif
        -:  249:	{
        -:  250:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  251:			this->value[0] = col_type(m[0], 0, 0);
        -:  252:			this->value[1] = col_type(m[1], 0, 0);
        -:  253:			this->value[2] = col_type(0, 0, 1, 0);
        -:  254:			this->value[3] = col_type(0, 0, 0, 1);
        -:  255:#		endif
        -:  256:	}
        -:  257:
        -:  258:	template<typename T, qualifier Q>
        -:  259:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)
        -:  260:#		if GLM_HAS_INITIALIZER_LISTS
        -:  261:			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0, 0, 0, 1)}
        -:  262:#		endif
        -:  263:	{
        -:  264:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  265:			this->value[0] = m[0];
        -:  266:			this->value[1] = m[1];
        -:  267:			this->value[2] = m[2];
        -:  268:			this->value[3] = col_type(0, 0, 0, 1);
        -:  269:#		endif
        -:  270:	}
        -:  271:
        -:  272:	template<typename T, qualifier Q>
        -:  273:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat<4, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)
        -:  274:#		if GLM_HAS_INITIALIZER_LISTS
        -:  275:			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(m[3], 1)}
        -:  276:#		endif
        -:  277:	{
        -:  278:#		if !GLM_HAS_INITIALIZER_LISTS
        -:  279:			this->value[0] = col_type(m[0], 0);
        -:  280:			this->value[1] = col_type(m[1], 0);
        -:  281:			this->value[2] = col_type(m[2], 0);
        -:  282:			this->value[3] = col_type(m[3], 1);
        -:  283:#		endif
        -:  284:	}
        -:  285:
        -:  286:	// -- Accesses --
        -:  287:
        -:  288:	template<typename T, qualifier Q>
function _ZN3glm3matILi4ELi4EfLNS_9qualifierE0EEixEi called 0 returned 0% blocks executed 0%
    #####:  289:	GLM_FUNC_QUALIFIER typename mat<4, 4, T, Q>::col_type & mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i)
        -:  290:	{
    #####:  291:		assert(i < this->length());
    %%%%%:  291-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  291-block 4
call    3 never executed
    #####:  292:		return this->value[i];
    %%%%%:  292-block 5
        -:  293:	}
        -:  294:
        -:  295:	template<typename T, qualifier Q>
        -:  296:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR typename mat<4, 4, T, Q>::col_type const& mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) const
        -:  297:	{
        -:  298:		assert(i < this->length());
        -:  299:		return this->value[i];
        -:  300:	}
        -:  301:
        -:  302:	// -- Unary arithmetic operators --
        -:  303:
        -:  304:	template<typename T, qualifier Q>
        -:  305:	template<typename U>
        -:  306:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator=(mat<4, 4, U, Q> const& m)
        -:  307:	{
        -:  308:		//memcpy could be faster
        -:  309:		//memcpy(&this->value, &m.value, 16 * sizeof(valType));
        -:  310:		this->value[0] = m[0];
        -:  311:		this->value[1] = m[1];
        -:  312:		this->value[2] = m[2];
        -:  313:		this->value[3] = m[3];
        -:  314:		return *this;
        -:  315:	}
        -:  316:
        -:  317:	template<typename T, qualifier Q>
        -:  318:	template<typename U>
        -:  319:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(U s)
        -:  320:	{
        -:  321:		this->value[0] += s;
        -:  322:		this->value[1] += s;
        -:  323:		this->value[2] += s;
        -:  324:		this->value[3] += s;
        -:  325:		return *this;
        -:  326:	}
        -:  327:
        -:  328:	template<typename T, qualifier Q>
        -:  329:	template<typename U>
        -:  330:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(mat<4, 4, U, Q> const& m)
        -:  331:	{
        -:  332:		this->value[0] += m[0];
        -:  333:		this->value[1] += m[1];
        -:  334:		this->value[2] += m[2];
        -:  335:		this->value[3] += m[3];
        -:  336:		return *this;
        -:  337:	}
        -:  338:
        -:  339:	template<typename T, qualifier Q>
        -:  340:	template<typename U>
        -:  341:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(U s)
        -:  342:	{
        -:  343:		this->value[0] -= s;
        -:  344:		this->value[1] -= s;
        -:  345:		this->value[2] -= s;
        -:  346:		this->value[3] -= s;
        -:  347:		return *this;
        -:  348:	}
        -:  349:
        -:  350:	template<typename T, qualifier Q>
        -:  351:	template<typename U>
        -:  352:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(mat<4, 4, U, Q> const& m)
        -:  353:	{
        -:  354:		this->value[0] -= m[0];
        -:  355:		this->value[1] -= m[1];
        -:  356:		this->value[2] -= m[2];
        -:  357:		this->value[3] -= m[3];
        -:  358:		return *this;
        -:  359:	}
        -:  360:
        -:  361:	template<typename T, qualifier Q>
        -:  362:	template<typename U>
        -:  363:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(U s)
        -:  364:	{
        -:  365:		this->value[0] *= s;
        -:  366:		this->value[1] *= s;
        -:  367:		this->value[2] *= s;
        -:  368:		this->value[3] *= s;
        -:  369:		return *this;
        -:  370:	}
        -:  371:
        -:  372:	template<typename T, qualifier Q>
        -:  373:	template<typename U>
        -:  374:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(mat<4, 4, U, Q> const& m)
        -:  375:	{
        -:  376:		return (*this = *this * m);
        -:  377:	}
        -:  378:
        -:  379:	template<typename T, qualifier Q>
        -:  380:	template<typename U>
        -:  381:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(U s)
        -:  382:	{
        -:  383:		this->value[0] /= s;
        -:  384:		this->value[1] /= s;
        -:  385:		this->value[2] /= s;
        -:  386:		this->value[3] /= s;
        -:  387:		return *this;
        -:  388:	}
        -:  389:
        -:  390:	template<typename T, qualifier Q>
        -:  391:	template<typename U>
        -:  392:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(mat<4, 4, U, Q> const& m)
        -:  393:	{
        -:  394:		return *this *= inverse(m);
        -:  395:	}
        -:  396:
        -:  397:	// -- Increment and decrement operators --
        -:  398:
        -:  399:	template<typename T, qualifier Q>
        -:  400:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator++()
        -:  401:	{
        -:  402:		++this->value[0];
        -:  403:		++this->value[1];
        -:  404:		++this->value[2];
        -:  405:		++this->value[3];
        -:  406:		return *this;
        -:  407:	}
        -:  408:
        -:  409:	template<typename T, qualifier Q>
        -:  410:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator--()
        -:  411:	{
        -:  412:		--this->value[0];
        -:  413:		--this->value[1];
        -:  414:		--this->value[2];
        -:  415:		--this->value[3];
        -:  416:		return *this;
        -:  417:	}
        -:  418:
        -:  419:	template<typename T, qualifier Q>
        -:  420:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> mat<4, 4, T, Q>::operator++(int)
        -:  421:	{
        -:  422:		mat<4, 4, T, Q> Result(*this);
        -:  423:		++*this;
        -:  424:		return Result;
        -:  425:	}
        -:  426:
        -:  427:	template<typename T, qualifier Q>
        -:  428:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> mat<4, 4, T, Q>::operator--(int)
        -:  429:	{
        -:  430:		mat<4, 4, T, Q> Result(*this);
        -:  431:		--*this;
        -:  432:		return Result;
        -:  433:	}
        -:  434:
        -:  435:	// -- Unary constant operators --
        -:  436:
        -:  437:	template<typename T, qualifier Q>
        -:  438:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m)
        -:  439:	{
        -:  440:		return m;
        -:  441:	}
        -:  442:
        -:  443:	template<typename T, qualifier Q>
        -:  444:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m)
        -:  445:	{
        -:  446:		return mat<4, 4, T, Q>(
        -:  447:			-m[0],
        -:  448:			-m[1],
        -:  449:			-m[2],
        -:  450:			-m[3]);
        -:  451:	}
        -:  452:
        -:  453:	// -- Binary arithmetic operators --
        -:  454:
        -:  455:	template<typename T, qualifier Q>
        -:  456:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T const& s)
        -:  457:	{
        -:  458:		return mat<4, 4, T, Q>(
        -:  459:			m[0] + s,
        -:  460:			m[1] + s,
        -:  461:			m[2] + s,
        -:  462:			m[3] + s);
        -:  463:	}
        -:  464:
        -:  465:	template<typename T, qualifier Q>
        -:  466:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator+(T const& s, mat<4, 4, T, Q> const& m)
        -:  467:	{
        -:  468:		return mat<4, 4, T, Q>(
        -:  469:			m[0] + s,
        -:  470:			m[1] + s,
        -:  471:			m[2] + s,
        -:  472:			m[3] + s);
        -:  473:	}
        -:  474:
        -:  475:	template<typename T, qualifier Q>
        -:  476:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
        -:  477:	{
        -:  478:		return mat<4, 4, T, Q>(
        -:  479:			m1[0] + m2[0],
        -:  480:			m1[1] + m2[1],
        -:  481:			m1[2] + m2[2],
        -:  482:			m1[3] + m2[3]);
        -:  483:	}
        -:  484:
        -:  485:	template<typename T, qualifier Q>
        -:  486:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T const& s)
        -:  487:	{
        -:  488:		return mat<4, 4, T, Q>(
        -:  489:			m[0] - s,
        -:  490:			m[1] - s,
        -:  491:			m[2] - s,
        -:  492:			m[3] - s);
        -:  493:	}
        -:  494:
        -:  495:	template<typename T, qualifier Q>
        -:  496:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator-(T const& s, mat<4, 4, T, Q> const& m)
        -:  497:	{
        -:  498:		return mat<4, 4, T, Q>(
        -:  499:			s - m[0],
        -:  500:			s - m[1],
        -:  501:			s - m[2],
        -:  502:			s - m[3]);
        -:  503:	}
        -:  504:
        -:  505:	template<typename T, qualifier Q>
        -:  506:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
        -:  507:	{
        -:  508:		return mat<4, 4, T, Q>(
        -:  509:			m1[0] - m2[0],
        -:  510:			m1[1] - m2[1],
        -:  511:			m1[2] - m2[2],
        -:  512:			m1[3] - m2[3]);
        -:  513:	}
        -:  514:
        -:  515:	template<typename T, qualifier Q>
        -:  516:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T const  & s)
        -:  517:	{
        -:  518:		return mat<4, 4, T, Q>(
        -:  519:			m[0] * s,
        -:  520:			m[1] * s,
        -:  521:			m[2] * s,
        -:  522:			m[3] * s);
        -:  523:	}
        -:  524:
        -:  525:	template<typename T, qualifier Q>
        -:  526:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator*(T const& s, mat<4, 4, T, Q> const& m)
        -:  527:	{
        -:  528:		return mat<4, 4, T, Q>(
        -:  529:			m[0] * s,
        -:  530:			m[1] * s,
        -:  531:			m[2] * s,
        -:  532:			m[3] * s);
        -:  533:	}
        -:  534:
        -:  535:	template<typename T, qualifier Q>
        -:  536:	GLM_FUNC_QUALIFIER typename mat<4, 4, T, Q>::col_type operator*
        -:  537:	(
        -:  538:		mat<4, 4, T, Q> const& m,
        -:  539:		typename mat<4, 4, T, Q>::row_type const& v
        -:  540:	)
        -:  541:	{
        -:  542:/*
        -:  543:		__m128 v0 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(0, 0, 0, 0));
        -:  544:		__m128 v1 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(1, 1, 1, 1));
        -:  545:		__m128 v2 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(2, 2, 2, 2));
        -:  546:		__m128 v3 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(3, 3, 3, 3));
        -:  547:
        -:  548:		__m128 m0 = _mm_mul_ps(m[0].data, v0);
        -:  549:		__m128 m1 = _mm_mul_ps(m[1].data, v1);
        -:  550:		__m128 a0 = _mm_add_ps(m0, m1);
        -:  551:
        -:  552:		__m128 m2 = _mm_mul_ps(m[2].data, v2);
        -:  553:		__m128 m3 = _mm_mul_ps(m[3].data, v3);
        -:  554:		__m128 a1 = _mm_add_ps(m2, m3);
        -:  555:
        -:  556:		__m128 a2 = _mm_add_ps(a0, a1);
        -:  557:
        -:  558:		return typename mat<4, 4, T, Q>::col_type(a2);
        -:  559:*/
        -:  560:
        -:  561:		typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);
        -:  562:		typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);
        -:  563:		typename mat<4, 4, T, Q>::col_type const Mul0 = m[0] * Mov0;
        -:  564:		typename mat<4, 4, T, Q>::col_type const Mul1 = m[1] * Mov1;
        -:  565:		typename mat<4, 4, T, Q>::col_type const Add0 = Mul0 + Mul1;
        -:  566:		typename mat<4, 4, T, Q>::col_type const Mov2(v[2]);
        -:  567:		typename mat<4, 4, T, Q>::col_type const Mov3(v[3]);
        -:  568:		typename mat<4, 4, T, Q>::col_type const Mul2 = m[2] * Mov2;
        -:  569:		typename mat<4, 4, T, Q>::col_type const Mul3 = m[3] * Mov3;
        -:  570:		typename mat<4, 4, T, Q>::col_type const Add1 = Mul2 + Mul3;
        -:  571:		typename mat<4, 4, T, Q>::col_type const Add2 = Add0 + Add1;
        -:  572:		return Add2;
        -:  573:
        -:  574:/*
        -:  575:		return typename mat<4, 4, T, Q>::col_type(
        -:  576:			m[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3],
        -:  577:			m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3],
        -:  578:			m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3],
        -:  579:			m[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3] * v[3]);
        -:  580:*/
        -:  581:	}
        -:  582:
        -:  583:	template<typename T, qualifier Q>
        -:  584:	GLM_FUNC_QUALIFIER typename mat<4, 4, T, Q>::row_type operator*
        -:  585:	(
        -:  586:		typename mat<4, 4, T, Q>::col_type const& v,
        -:  587:		mat<4, 4, T, Q> const& m
        -:  588:	)
        -:  589:	{
        -:  590:		return typename mat<4, 4, T, Q>::row_type(
        -:  591:			m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
        -:  592:			m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
        -:  593:			m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
        -:  594:			m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
        -:  595:	}
        -:  596:
        -:  597:	template<typename T, qualifier Q>
        -:  598:	GLM_FUNC_QUALIFIER mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
        -:  599:	{
        -:  600:		return mat<2, 4, T, Q>(
        -:  601:			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
        -:  602:			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
        -:  603:			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
        -:  604:			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
        -:  605:			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
        -:  606:			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
        -:  607:			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
        -:  608:			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
        -:  609:	}
        -:  610:
        -:  611:	template<typename T, qualifier Q>
        -:  612:	GLM_FUNC_QUALIFIER mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
        -:  613:	{
        -:  614:		return mat<3, 4, T, Q>(
        -:  615:			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
        -:  616:			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
        -:  617:			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
        -:  618:			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
        -:  619:			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
        -:  620:			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
        -:  621:			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
        -:  622:			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
        -:  623:			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
        -:  624:			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
        -:  625:			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
        -:  626:			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
        -:  627:	}
        -:  628:
        -:  629:	template<typename T, qualifier Q>
        -:  630:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
        -:  631:	{
        -:  632:		typename mat<4, 4, T, Q>::col_type const SrcA0 = m1[0];
        -:  633:		typename mat<4, 4, T, Q>::col_type const SrcA1 = m1[1];
        -:  634:		typename mat<4, 4, T, Q>::col_type const SrcA2 = m1[2];
        -:  635:		typename mat<4, 4, T, Q>::col_type const SrcA3 = m1[3];
        -:  636:
        -:  637:		typename mat<4, 4, T, Q>::col_type const SrcB0 = m2[0];
        -:  638:		typename mat<4, 4, T, Q>::col_type const SrcB1 = m2[1];
        -:  639:		typename mat<4, 4, T, Q>::col_type const SrcB2 = m2[2];
        -:  640:		typename mat<4, 4, T, Q>::col_type const SrcB3 = m2[3];
        -:  641:
        -:  642:		mat<4, 4, T, Q> Result;
        -:  643:		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
        -:  644:		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
        -:  645:		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
        -:  646:		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
        -:  647:		return Result;
        -:  648:	}
        -:  649:
        -:  650:	template<typename T, qualifier Q>
        -:  651:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T const& s)
        -:  652:	{
        -:  653:		return mat<4, 4, T, Q>(
        -:  654:			m[0] / s,
        -:  655:			m[1] / s,
        -:  656:			m[2] / s,
        -:  657:			m[3] / s);
        -:  658:	}
        -:  659:
        -:  660:	template<typename T, qualifier Q>
        -:  661:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator/(T const& s,	mat<4, 4, T, Q> const& m)
        -:  662:	{
        -:  663:		return mat<4, 4, T, Q>(
        -:  664:			s / m[0],
        -:  665:			s / m[1],
        -:  666:			s / m[2],
        -:  667:			s / m[3]);
        -:  668:	}
        -:  669:
        -:  670:	template<typename T, qualifier Q>
        -:  671:	GLM_FUNC_QUALIFIER typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v)
        -:  672:	{
        -:  673:		return inverse(m) * v;
        -:  674:	}
        -:  675:
        -:  676:	template<typename T, qualifier Q>
        -:  677:	GLM_FUNC_QUALIFIER typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m)
        -:  678:	{
        -:  679:		return v * inverse(m);
        -:  680:	}
        -:  681:
        -:  682:	template<typename T, qualifier Q>
        -:  683:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
        -:  684:	{
        -:  685:		mat<4, 4, T, Q> m1_copy(m1);
        -:  686:		return m1_copy /= m2;
        -:  687:	}
        -:  688:
        -:  689:	// -- Boolean operators --
        -:  690:
        -:  691:	template<typename T, qualifier Q>
        -:  692:	GLM_FUNC_QUALIFIER bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
        -:  693:	{
        -:  694:		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
        -:  695:	}
        -:  696:
        -:  697:	template<typename T, qualifier Q>
        -:  698:	GLM_FUNC_QUALIFIER bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
        -:  699:	{
        -:  700:		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
        -:  701:	}
        -:  702:}//namespace glm
        -:  703:
        -:  704:#if GLM_CONFIG_SIMD == GLM_ENABLE
        -:  705:#	include "type_mat4x4_simd.inl"
        -:  706:#endif
