        -:    0:Source:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/Includes/Utils.hpp
        -:    0:Graph:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/VulkanApp.cpp.gcno
        -:    0:Data:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/VulkanApp.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by wpsimon09 on 26/07/24.
        -:    3://
        -:    4:
        -:    5:#ifndef UTILS_HPP
        -:    6:#define UTILS_HPP
        -:    7:#include <optional>
        -:    8:#include <set>
        -:    9:#include <vulkan/vulkan.hpp>
        -:   10:#include <limits>
        -:   11:#include <algorithm>
        -:   12:#include <fstream>
        -:   13:#include <vector>
        -:   14:#include <glm/glm.hpp>
        -:   15:
        -:   16:#include "Structs.hpp"
        -:   17:
        -:   18:
        -:   19:const std::vector<const char *> deviceExtentions = {
        -:   20:    VK_KHR_SWAPCHAIN_EXTENSION_NAME
        -:   21:};
        -:   22:
        -:   23:
function _Z28CreateDebugUtilsMessengerEXTP12VkInstance_TPK34VkDebugUtilsMessengerCreateInfoEXTPK21VkAllocationCallbacksPP26VkDebugUtilsMessengerEXT_T called 1 returned 100% blocks executed 83%
        1:   24:inline VkResult CreateDebugUtilsMessengerEXT(VkInstance instance,
        -:   25:                                             const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfor,
        -:   26:                                             const VkAllocationCallbacks *pAllocator,
        -:   27:                                             VkDebugUtilsMessengerEXT *pDebugMessenger) {
        1:   28:    auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
        1:   28-block 2
call    0 returned 1
        1:   29:    if (func != nullptr)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   30:        return func(instance, pCreateInfor, pAllocator, pDebugMessenger);
        1:   30-block 4
call    0 returned 1
        -:   31:    else
    #####:   32:        return VK_ERROR_EXTENSION_NOT_PRESENT;
    %%%%%:   32-block 6
        -:   33:}
        -:   34:
function _Z29DestroyDebugUtilsMessengerEXTP12VkInstance_TP26VkDebugUtilsMessengerEXT_TPK21VkAllocationCallbacks called 1 returned 100% blocks executed 100%
        1:   35:inline void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger,
        -:   36:                                          const VkAllocationCallbacks *pAllocator) {
        -:   37:    auto func = (PFN_vkDestroyDebugUtilsMessengerEXT)
        1:   38:            vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
        1:   38-block 2
call    0 returned 1
        -:   39:
        1:   40:    if (func != nullptr) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   41:        func(instance, debugMessenger, pAllocator);
        1:   41-block 4
call    0 returned 1
        -:   42:    }
        1:   43:}
        -:   44:
        -:   45:
function _Z17FindQueueFamiliesP18VkPhysicalDevice_TP14VkSurfaceKHR_T called 17 returned 100% blocks executed 77%
       17:   46:inline QueueFamilyIndices FindQueueFamilies(VkPhysicalDevice device, VkSurfaceKHR surface) {
       17:   47:    QueueFamilyIndices indices;
       17:   48:    uint32_t queueFamilyCount = 0;
       17:   49:    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);
       17:   49-block 2
call    0 returned 17
branch  1 taken 17 (fallthrough)
branch  2 taken 0 (throw)
       17:   50:    std::vector<VkQueueFamilyProperties> queueFamilyProperties(queueFamilyCount);
       17:   50-block 5
call    0 returned 17
branch  1 taken 17 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:   50-block 31
       17:   51:    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilyProperties.data());
call    0 returned 17
call    1 returned 17
branch  2 taken 17 (fallthrough)
branch  3 taken 0 (throw)
        -:   52:
       17:   53:    int i = 0;
      17*:   54:    for (auto &queueFamily: queueFamilyProperties) {
       17:   54-block 9
call    0 returned 17
call    1 returned 17
       17:   54-block 11
call    2 returned 17
       17:   54-block 23
call    3 returned 17
branch  4 taken 17
branch  5 taken 0 (fallthrough)
       17:   55:        if (queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
branch  0 taken 17 (fallthrough)
branch  1 taken 0
       17:   56:            indices.graphicsFamily = i;
       17:   56-block 13
call    0 returned 17
        -:   57:        }
       17:   58:        if (queueFamily.queueFlags & VK_QUEUE_TRANSFER_BIT) {
       17:   58-block 14
branch  0 taken 17 (fallthrough)
branch  1 taken 0
       17:   59:            indices.transferFamily = i;
       17:   59-block 15
call    0 returned 17
        -:   60:        }
       17:   61:        VkBool32 presentSupport = false;
       17:   62:        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport);
       17:   62-block 16
call    0 returned 17
branch  1 taken 17 (fallthrough)
branch  2 taken 0 (throw)
       17:   63:        if (presentSupport) {
       17:   63-block 17
branch  0 taken 17 (fallthrough)
branch  1 taken 0
       17:   64:            indices.presentFamily = i;
       17:   64-block 18
call    0 returned 17
        -:   65:        }
       17:   66:        if (indices.isComplete()) break;
       17:   66-block 19
call    0 returned 17
branch  1 taken 17 (fallthrough)
branch  2 taken 0
       17:   66-block 21
        -:   67:
    #####:   68:        i++;
    %%%%%:   68-block 22
call    0 never executed
        -:   69:    }
        -:   70:
       34:   71:    return indices;
       17:   71-block 25
       17:   71-block 28
       17:   72:}
       17:   72-block 26
call    0 returned 17
    $$$$$:   72-block 34
call    1 never executed
        -:   73:
function _Z27CheckDeviceExtentionSupportP18VkPhysicalDevice_T called 2 returned 100% blocks executed 67%
        2:   74:inline bool CheckDeviceExtentionSupport(VkPhysicalDevice device) {
        -:   75:    uint32_t extensionCount;
        2:   76:    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);
        2:   76-block 2
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:   77:    std::vector<VkExtensionProperties> availablExtensions(extensionCount);
        2:   77-block 5
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:   77-block 31
        2:   78:    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availablExtensions.data());
call    0 returned 2
call    1 returned 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0 (throw)
        -:   79:
        2:   80:    std::set<std::string> requiredExtensions(deviceExtentions.begin(), deviceExtentions.end());
        2:   80-block 9
call    0 returned 2
call    1 returned 2
call    2 returned 2
branch  3 taken 2 (fallthrough)
branch  4 taken 0 (throw)
        -:   81:
      338:   82:    for (auto &availabl_extension: availablExtensions) {
        2:   82-block 12
call    0 returned 2
call    1 returned 2
      336:   82-block 14
call    2 returned 336
      338:   82-block 22
call    3 returned 338
branch  4 taken 336
branch  5 taken 2 (fallthrough)
      672:   83:        requiredExtensions.erase(availabl_extension.extensionName);
      336:   83-block 17
call    0 returned 336
branch  1 taken 336 (fallthrough)
branch  2 taken 0 (throw)
      336:   83-block 18
call    3 returned 336
branch  4 taken 336 (fallthrough)
branch  5 taken 0 (throw)
      336:   83-block 19
call    6 returned 336
call    7 returned 336
    $$$$$:   83-block 32
call    8 never executed
    $$$$$:   83-block 36
    $$$$$:   83-block 37
        -:   84:    }
        -:   85:
        4:   86:    return requiredExtensions.empty();
        2:   86-block 24
call    0 returned 2
        2:   86-block 28
        2:   87:}
call    0 returned 2
call    1 returned 2
    $$$$$:   87-block 39
call    2 never executed
    $$$$$:   87-block 41
call    3 never executed
        -:   88:
        -:   89:
function _Z21querySwapChainSupportP18VkPhysicalDevice_TP14VkSurfaceKHR_T called 3 returned 100% blocks executed 88%
        3:   90:inline SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface) {
        3:   91:    SwapChainSupportDetails details;
        3:   91-block 2
call    0 returned 3
        -:   92:
        3:   93:    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &details.capabilities);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:   94:
        -:   95:    uint32_t formatCount;
        3:   96:    vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &formatCount, nullptr);
        3:   96-block 4
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   97:    if (formatCount != 0) {
        3:   97-block 5
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:   98:        details.formats.resize(formatCount);
        3:   98-block 6
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   99:        vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &formatCount, details.formats.data());
        3:   99-block 7
call    0 returned 3
call    1 returned 3
branch  2 taken 3 (fallthrough)
branch  3 taken 0 (throw)
        -:  100:    }
        -:  101:
        -:  102:    uint32_t presentModeCount;
        3:  103:    vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, &presentModeCount, nullptr);
        3:  103-block 9
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  104:    if (presentModeCount != 0) {
        3:  104-block 10
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  105:        details.presentModes.resize(presentModeCount);
        3:  105-block 11
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  106:        vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, &presentModeCount,
        3:  106-block 12
call    0 returned 3
call    1 returned 3
branch  2 taken 3 (fallthrough)
branch  3 taken 0 (throw)
        -:  107:                                                  details.presentModes.data());
        -:  108:    }
        -:  109:
        3:  110:    return details;
        3:  110-block 14
        3:  110-block 15
    =====:  111:}
    $$$$$:  111-block 16
call    0 never executed
        -:  112:
function _Z16isDeviceSuitableP18VkPhysicalDevice_TP14VkSurfaceKHR_T called 2 returned 100% blocks executed 93%
        2:  113:inline bool isDeviceSuitable(VkPhysicalDevice device, VkSurfaceKHR surface) {
        -:  114:    VkPhysicalDeviceProperties deviceProperties;
        -:  115:    VkPhysicalDeviceFeatures deviceFeatures;
        2:  116:    vkGetPhysicalDeviceProperties(device, &deviceProperties);
        2:  116-block 2
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  117:    vkGetPhysicalDeviceFeatures(device, &deviceFeatures);
        2:  117-block 3
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  118:    std::cout << '\t' << deviceProperties.deviceName << std::endl;
        2:  118-block 4
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  118-block 5
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
        2:  118-block 6
call    6 returned 2
branch  7 taken 2 (fallthrough)
branch  8 taken 0 (throw)
        -:  119:
        2:  120:    QueueFamilyIndices indices = FindQueueFamilies(device, surface);
        2:  120-block 7
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  121:
        2:  122:    bool extensionsSupported = CheckDeviceExtentionSupport(device);
        2:  122-block 8
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  123:
        2:  124:    bool swapChainAdequtate = false;
        2:  125:    if (extensionsSupported) {
        2:  125-block 9
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  126:        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device, surface);
        2:  126-block 10
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  127:
       2*:  128:        swapChainAdequtate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty();
        2:  128-block 11
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2:  128-block 13
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        2:  128-block 15
    %%%%%:  128-block 16
        2:  129:    }
        2:  129-block 17
call    0 returned 2
        -:  130:
        -:  131:    VkPhysicalDeviceFeatures supportedFeatures;
        2:  132:    vkGetPhysicalDeviceFeatures(device, &supportedFeatures);
        2:  132-block 19
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  133:
        1:  134:    return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU && indices.isComplete() &&
        1:  134-block 21
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1:  134-block 23
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        5:  135:           swapChainAdequtate && supportedFeatures.samplerAnisotropy;
        2:  135-block 20
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  135-block 24
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  135-block 25
        1:  135-block 26
        2:  135-block 27
        2:  135-block 29
        -:  136:}
        -:  137:
function _Z23chooseSwapSurfaceFormatRKSt6vectorI18VkSurfaceFormatKHRSaIS0_EE called 1 returned 100% blocks executed 83%
        1:  138:inline VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR> &availableFormats) {
        2:  139:    for (const auto &availableFormat: availableFormats) {
        1:  139-block 2
call    0 returned 1
call    1 returned 1
        2:  139-block 4
call    2 returned 2
        1:  139-block 8
call    3 returned 1
        2:  139-block 9
call    4 returned 2
branch  5 taken 2
branch  6 taken 0 (fallthrough)
        2:  140:        if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB && availableFormat.colorSpace ==
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  140-block 6
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -:  141:            VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
        1:  142:            return availableFormat;
        1:  142-block 7
        -:  143:        }
        -:  144:    }
    #####:  145:    return availableFormats[0];
    %%%%%:  145-block 11
call    0 never executed
        -:  146:}
        -:  147:
function _Z21chooseSwapPresentModeRKSt6vectorI16VkPresentModeKHRSaIS0_EE called 1 returned 100% blocks executed 90%
        1:  148:inline VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> &availablePresentModes) {
        3:  149:    for (const auto &availblePresentMode: availablePresentModes) {
        1:  149-block 2
call    0 returned 1
call    1 returned 1
        2:  149-block 4
call    2 returned 2
        2:  149-block 7
call    3 returned 2
        3:  149-block 8
call    4 returned 3
branch  5 taken 2
branch  6 taken 1 (fallthrough)
        2:  150:        if (availblePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  151:            return availblePresentMode;
    %%%%%:  151-block 6
        -:  152:        }
        -:  153:    }
        1:  154:    return VK_PRESENT_MODE_FIFO_KHR;
        1:  154-block 10
        -:  155:}
        -:  156:
function _Z16chooseSwapExtentRK24VkSurfaceCapabilitiesKHRP10GLFWwindow called 1 returned 100% blocks executed 60%
        1:  157:inline VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR &capabilities, GLFWwindow *window) {
        1:  158:    if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
        1:  158-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        -:  159:        //we are going with the window size to be set as current extend
        1:  160:        return capabilities.currentExtent;
        1:  160-block 4
        -:  161:    }
        -:  162:    //teh current extend is max of uint32_t and we adjust max width and height for the swap chain images instead
        -:  163:    int width, height;
    #####:  164:    glfwGetFramebufferSize(window, &width, &height);
    %%%%%:  164-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  165:
        -:  166:    VkExtent2D acctualExtend = {
    #####:  167:        static_cast<uint32_t>(width),
    #####:  168:        static_cast<uint32_t>(height)
    #####:  169:    };
        -:  170:
    #####:  171:    acctualExtend.width = std::clamp(acctualExtend.width, capabilities.minImageExtent.width,
    #####:  172:                                     capabilities.maxImageExtent.width);
    %%%%%:  172-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  173:    acctualExtend.height = std::clamp(acctualExtend.height, capabilities.minImageExtent.height,
    #####:  174:                                      capabilities.maxImageExtent.height);
    %%%%%:  174-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  175:
    #####:  176:    return acctualExtend;
    %%%%%:  176-block 8
        -:  177:}
        -:  178:
function _ZL8readFileRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 2 returned 100% blocks executed 51%
        2:  179:static inline std::vector<char> readFile(const std::string &fileName) {
        2:  180:    std::ifstream file(fileName, std::ios::ate | std::ios::binary);
        2:  180-block 2
call    0 returned 2
call    1 returned 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0 (throw)
        -:  181:
        2:  182:    if (!file.is_open()) {
        2:  182-block 4
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  183:        const auto err = "Failed to open file at path: " + fileName;
    %%%%%:  183-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  184:        throw std::runtime_error(err);
    %%%%%:  184-block 7
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  184-block 9
call    4 never executed
    $$$$$:  184-block 24
call    5 never executed
    =====:  185:    }
    $$$$$:  185-block 26
call    0 never executed
        -:  186:
        -:  187:    //create buffer to hold the binary
        2:  188:    size_t fileSize = (size_t) file.tellg();
        2:  188-block 10
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  188-block 11
call    3 returned 2
    $$$$$:  188-block 29
        2:  189:    std::vector<char> buffer(fileSize);
        2:  189-block 14
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:  189-block 32
        -:  190:
        -:  191:    //go back to the begining and read the file again to get the content
        2:  192:    file.seekg(0);
call    0 returned 2
call    1 returned 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:  192-block 33
        2:  193:    file.read(buffer.data(), fileSize);
        2:  193-block 18
call    0 returned 2
call    1 returned 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0 (throw)
        -:  194:
        2:  195:    file.close();
        2:  195-block 20
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  196:
        2:  197:    return buffer;
        2:  197-block 23
        2:  198:}
        2:  198-block 21
call    0 returned 2
    $$$$$:  198-block 34
call    1 never executed
    $$$$$:  198-block 36
call    2 never executed
        -:  199:
        -:  200:
function _ZL18createShaderModuelP10VkDevice_TRSt6vectorIcSaIcEE called 2 returned 100% blocks executed 62%
        2:  201:static inline VkShaderModule createShaderModuel(VkDevice device, std::vector<char> &shaderSPIRV) {
        -:  202:    VkShaderModuleCreateInfo createInfo;
        2:  203:    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
        2:  204:    createInfo.codeSize = shaderSPIRV.size();
        2:  204-block 2
call    0 returned 2
        2:  205:    createInfo.pNext = nullptr;
        -:  206:    //cast from char to uint32_t
        2:  207:    createInfo.pCode = reinterpret_cast<const uint32_t *>(shaderSPIRV.data());
call    0 returned 2
        -:  208:
        -:  209:    VkShaderModule shaderModule;
        2:  210:    if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  210-block 5
branch  3 taken 0 (fallthrough)
branch  4 taken 2
    #####:  211:        throw std::runtime_error("Could not create shader module");
    %%%%%:  211-block 6
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  211-block 8
call    4 never executed
    $$$$$:  211-block 12
call    5 never executed
        -:  212:    }
        -:  213:
        2:  214:    shaderSPIRV.clear();
        2:  214-block 9
call    0 returned 2
        -:  215:
        2:  216:    return shaderModule;
        2:  216-block 11
        -:  217:}
        -:  218:
function _ZL14FindMemoryTypejjP18VkPhysicalDevice_T called 12 returned 100% blocks executed 64%
       12:  219:static inline uint32_t FindMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties, VkPhysicalDevice physicalDevice) {
        -:  220:    //get the available types of memories on the GPU
        -:  221:    VkPhysicalDeviceMemoryProperties memProperties;
       12:  222:    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);
       12:  222-block 2
call    0 returned 12
branch  1 taken 12 (fallthrough)
branch  2 taken 0 (throw)
        -:  223:
      103:  224:    for(uint32_t i = 0; i<memProperties.memoryTypeCount; i++) {
       12:  224-block 3
       91:  224-block 7
      103:  224-block 8
branch  0 taken 103
branch  1 taken 0 (fallthrough)
      103:  225:        if(typeFilter & (1 << i) &&
      103:  225-block 4
branch  0 taken 31 (fallthrough)
branch  1 taken 72
       31:  226:            (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
       31:  226-block 5
branch  0 taken 12 (fallthrough)
branch  1 taken 19
       12:  227:            return i;
       12:  227-block 6
       12:  227-block 12
        -:  228:        }
        -:  229:    }
        -:  230:
    #####:  231:    throw std::runtime_error("Fialed to find suitable memmory type");
    %%%%%:  231-block 9
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  231-block 11
call    4 never executed
    $$$$$:  231-block 13
call    5 never executed
        -:  232:}
        -:  233:
function _ZL12CreateBufferRK16BufferCreateInfoRP10VkBuffer_TRP16VkDeviceMemory_T called 9 returned 100% blocks executed 54%
        9:  234:static inline void CreateBuffer(const BufferCreateInfo &bufferCreateInfo, VkBuffer& buffer, VkDeviceMemory &bufferMemory ){
        9:  235:    QueueFamilyIndices indices = FindQueueFamilies(bufferCreateInfo.physicalDevice, bufferCreateInfo.surface);
        9:  235-block 2
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        9:  236:    VkBufferCreateInfo bufferInfo{};
        9:  237:    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        9:  238:    bufferInfo.size = bufferCreateInfo.size;
        -:  239:    // might be more using | operator
        9:  240:    bufferInfo.usage = bufferCreateInfo.usage;
        -:  241:    // specifies if it can be shared between queue families
        -:  242:    // we will use it only for the graphics family
       18:  243:    std::vector<uint32_t> sharedQueueFamilies = {indices.graphicsFamily.value(), indices.transferFamily.value()};
        9:  243-block 3
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        9:  243-block 4
call    3 returned 9
branch  4 taken 9 (fallthrough)
branch  5 taken 0 (throw)
        9:  243-block 5
        9:  243-block 7
call    6 returned 9
branch  7 taken 9 (fallthrough)
branch  8 taken 0 (throw)
    $$$$$:  243-block 28
    $$$$$:  243-block 29
        -:  244:
        9:  245:    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        9:  246:    bufferInfo.queueFamilyIndexCount = static_cast<uint32_t>(sharedQueueFamilies.size());
call    0 returned 9
        9:  247:    bufferInfo.pQueueFamilyIndices = sharedQueueFamilies.data();
call    0 returned 9
        -:  248:
        -:  249:    //sparse buffer memmory
        9:  250:    bufferInfo.flags = 0;
        -:  251:
        9:  252:    if(vkCreateBuffer(bufferCreateInfo.logicalDevice, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        9:  252-block 12
branch  3 taken 0 (fallthrough)
branch  4 taken 9
    #####:  253:        throw std::runtime_error("Failed to create Vertex Buffer");
    %%%%%:  253-block 13
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  253-block 15
call    4 never executed
    $$$$$:  253-block 30
call    5 never executed
        -:  254:    }
        -:  255:
        -:  256:    VkMemoryRequirements memRequirements;
        9:  257:    vkGetBufferMemoryRequirements(bufferCreateInfo.logicalDevice, buffer, &memRequirements);
        9:  257-block 16
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        -:  258:
        9:  259:    VkMemoryAllocateInfo allocInfo{};
        9:  260:    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        9:  261:    allocInfo.allocationSize = memRequirements.size;
        9:  262:    allocInfo.memoryTypeIndex = FindMemoryType(memRequirements.memoryTypeBits, bufferCreateInfo.properties, bufferCreateInfo.physicalDevice);
        9:  262-block 17
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        -:  263:
        9:  264:    if(vkAllocateMemory(bufferCreateInfo.logicalDevice, &allocInfo, nullptr, &bufferMemory) != VK_SUCCESS) {
        9:  264-block 18
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        9:  264-block 19
branch  3 taken 0 (fallthrough)
branch  4 taken 9
    #####:  265:        throw std::runtime_error("Failed to allocate memory");
    %%%%%:  265-block 20
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  265-block 22
call    4 never executed
    $$$$$:  265-block 32
call    5 never executed
        -:  266:    }
        -:  267:
        9:  268:    vkBindBufferMemory(bufferCreateInfo.logicalDevice, buffer,bufferMemory, 0);
        9:  268-block 23
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        9:  269:}
        9:  269-block 24
call    0 returned 9
    $$$$$:  269-block 34
call    1 never executed
        -:  270:
function _ZL11CreateImageRK15ImageCreateInfoRP9VkImage_TRP16VkDeviceMemory_T called 3 returned 100% blocks executed 54%
        3:  271:static inline void CreateImage(const ImageCreateInfo &createImageInfo, VkImage &image, VkDeviceMemory &textureMemory) {
        -:  272:
        3:  273:    QueueFamilyIndices indices = FindQueueFamilies(createImageInfo.physicalDevice, createImageInfo.surface);
        3:  273-block 2
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  274:    VkImageCreateInfo imageInfo{.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO};
        -:  275:
        -:  276:    //what coordinate systems will be used for the image access
        3:  277:    imageInfo.imageType = VK_IMAGE_TYPE_2D;
        3:  278:    imageInfo.extent.width = createImageInfo.width;
        3:  279:    imageInfo.extent.height = createImageInfo.height;
        -:  280:    // 1 textel on Z axis not 0 texels
        3:  281:    imageInfo.extent.depth = 1;
        3:  282:    imageInfo.mipLevels = 1;
        3:  283:    imageInfo.arrayLayers = 1;
        -:  284:    //use the same format as pixels that were loaded
        -:  285:    //using different format might result in crash during copying
        3:  286:    imageInfo.format = createImageInfo.format;
        3:  287:    imageInfo.tiling = createImageInfo.imageTiling;
        3:  288:    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        3:  289:    imageInfo.usage = createImageInfo.usage;
        3:  290:    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        -:  291:
        6:  292:    std::vector<uint32_t> sharedQueueFamilies = {indices.graphicsFamily.value(), indices.transferFamily.value()};
        3:  292-block 3
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  292-block 4
call    3 returned 3
branch  4 taken 3 (fallthrough)
branch  5 taken 0 (throw)
        3:  292-block 5
        3:  292-block 7
call    6 returned 3
branch  7 taken 3 (fallthrough)
branch  8 taken 0 (throw)
    $$$$$:  292-block 28
    $$$$$:  292-block 29
        3:  293:    imageInfo.queueFamilyIndexCount = static_cast<uint32_t>(sharedQueueFamilies.size());
call    0 returned 3
        3:  294:    imageInfo.pQueueFamilyIndices = sharedQueueFamilies.data();
call    0 returned 3
        -:  295:
        3:  296:    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
        3:  297:    imageInfo.flags = 0;
        -:  298:
        3:  299:    if(vkCreateImage(createImageInfo.logicalDevice, &imageInfo, nullptr, &image) != VK_SUCCESS) {
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  299-block 12
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    #####:  300:        throw std::runtime_error("Failed to create vulkan image ");
    %%%%%:  300-block 13
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  300-block 15
call    4 never executed
    $$$$$:  300-block 30
call    5 never executed
        -:  301:    }
        -:  302:
        -:  303:    VkMemoryRequirements memReqirements;
        3:  304:    vkGetImageMemoryRequirements(createImageInfo.logicalDevice, image, &memReqirements);
        3:  304-block 16
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:  305:
        3:  306:    VkMemoryAllocateInfo allocInfo{.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO};
        3:  307:    allocInfo.allocationSize = memReqirements.size;
        3:  308:    allocInfo.memoryTypeIndex = FindMemoryType(memReqirements.memoryTypeBits, createImageInfo.memoryProperteis,createImageInfo.physicalDevice);
        3:  308-block 17
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:  309:
        3:  310:    if(vkAllocateMemory(createImageInfo.logicalDevice, &allocInfo, nullptr, &textureMemory) != VK_SUCCESS) {
        3:  310-block 18
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  310-block 19
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    #####:  311:        throw std::runtime_error("Failed to allocate image memory");
    %%%%%:  311-block 20
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  311-block 22
call    4 never executed
    $$$$$:  311-block 32
call    5 never executed
        -:  312:    }
        3:  313:    vkBindImageMemory(createImageInfo.logicalDevice, image, textureMemory, 0);
        3:  313-block 23
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  314:}
        3:  314-block 24
call    0 returned 3
    $$$$$:  314-block 34
call    1 never executed
        -:  315:
function _ZL22BeginSingleTimeCommandP10VkDevice_TP15VkCommandPool_T called 2 returned 100% blocks executed 100%
        2:  316:inline static VkCommandBuffer BeginSingleTimeCommand(VkDevice logicalDevice, VkCommandPool commandPool) {
        2:  317:    VkCommandBufferAllocateInfo allocInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};
        2:  318:    allocInfo.commandPool = commandPool;
        2:  319:    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        2:  320:    allocInfo.commandBufferCount = 1;
        -:  321:
        -:  322:    VkCommandBuffer commandBuffer;
        2:  323:    vkAllocateCommandBuffers(logicalDevice, &allocInfo, &commandBuffer);
        2:  323-block 2
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  324:
        2:  325:    VkCommandBufferBeginInfo beginInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
        2:  326:    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        -:  327:
        2:  328:    vkBeginCommandBuffer(commandBuffer, &beginInfo);
        2:  328-block 3
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  329:
        2:  330:    return commandBuffer;
        2:  330-block 4
        2:  330-block 5
        -:  331:}
        -:  332:
function _ZL20EndSingleTimeCommandP10VkDevice_TP15VkCommandPool_TP17VkCommandBuffer_TP9VkQueue_T called 2 returned 100% blocks executed 100%
        2:  333:inline static void EndSingleTimeCommand(VkDevice logicalDevice,VkCommandPool commandPool,VkCommandBuffer commandBuffer, VkQueue queue) {
        2:  334:    vkEndCommandBuffer(commandBuffer);
        2:  334-block 2
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  335:
        2:  336:    VkSubmitInfo submitInfo{.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO};
        2:  337:    submitInfo.commandBufferCount = 1;
        2:  338:    submitInfo.pCommandBuffers = &commandBuffer;
        -:  339:
        2:  340:    vkQueueSubmit(queue, 1, &submitInfo, VK_NULL_HANDLE);
        2:  340-block 3
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  341:    vkQueueWaitIdle(queue);
        2:  341-block 4
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  342:    vkFreeCommandBuffers(logicalDevice, commandPool, 1, &commandBuffer);
        2:  342-block 5
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  343:}
        2:  343-block 6
        -:  344:
function _ZL10CopyBufferP10VkDevice_TP9VkQueue_TP15VkCommandPool_TP10VkBuffer_TS6_m called 2 returned 100% blocks executed 100%
        2:  345:static inline void CopyBuffer(VkDevice logicalDevice,VkQueue transferQueue,VkCommandPool transferCommandPool,VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
        -:  346:
        2:  347:    VkCommandBuffer commandBuffer = BeginSingleTimeCommand(logicalDevice, transferCommandPool);
        2:  347-block 2
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  348:
        2:  349:    VkBufferCopy copyRegion{};
        2:  350:    copyRegion.srcOffset = 0;
        2:  351:    copyRegion.dstOffset = 0;
        2:  352:    copyRegion.size = size;
        2:  353:    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer,1,&copyRegion);
        2:  353-block 3
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  354:
        2:  355:    EndSingleTimeCommand(logicalDevice, transferCommandPool, commandBuffer, transferQueue);
        2:  355-block 4
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  356:}
        2:  356-block 5
        -:  357:
        -:  358:static inline void CopyBuffer(VkDevice logicalDevice,VkCommandBuffer commandBuffer,VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
        -:  359:
        -:  360:    //VkCommandBuffer commandBuffer = BeginSingleTimeCommand(logicalDevice, transferCommandPool);
        -:  361:
        -:  362:    VkBufferCopy copyRegion{};
        -:  363:    copyRegion.srcOffset = 0;
        -:  364:    copyRegion.dstOffset = 0;
        -:  365:    copyRegion.size = size;
        -:  366:    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer,1,&copyRegion);
        -:  367:
        -:  368:    //EndSingleTimeCommand(logicalDevice, transferCommandPool, commandBuffer, transferQueue);
        -:  369:}
        -:  370:
function _ZL17CopyBufferToImage25ImageLayoutDependencyInfoP10VkBuffer_TP9VkImage_Tjj called 3 returned 100% blocks executed 100%
        3:  371:static inline void CopyBufferToImage(ImageLayoutDependencyInfo dependencyInfo, VkBuffer buffer, VkImage image, uint32_t width, uint32_t height) {
        -:  372:    //VkCommandBuffer commandBuffer = BeginSingleTimeCommand(dependencyInfo.logicalDevice, dependencyInfo.commandPool);
        -:  373:
        3:  374:    VkBufferImageCopy region{};
        3:  375:    region.bufferOffset = 0;
        3:  376:    region.bufferRowLength = 0;
        3:  377:    region.bufferImageHeight = 0;
        -:  378:
        3:  379:    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        3:  380:    region.imageSubresource.mipLevel = 0;
        3:  381:    region.imageSubresource.baseArrayLayer = 0;
        3:  382:    region.imageSubresource.layerCount = 1;
        -:  383:
        3:  384:    region.imageOffset={0,0,0};
        3:  385:    region.imageExtent = {width, height,1};
        -:  386:
        3:  387:    vkCmdCopyBufferToImage(dependencyInfo.commandBuffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);
        3:  387-block 2
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:  388:
        -:  389:    //EndSingleTimeCommand(dependencyInfo.logicalDevice, dependencyInfo.commandPool, commandBuffer, dependencyInfo.transformQueue);
        3:  390:}
        3:  390-block 3
        -:  391:
function _ZL19TransferImageLayout25ImageLayoutDependencyInfoP9VkImage_T8VkFormat13VkImageLayoutS3_ called 6 returned 100% blocks executed 64%
        6:  392:static inline void TransferImageLayout(ImageLayoutDependencyInfo dependencyInfo,VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout) {
        -:  393:
        6:  394:    VkImageMemoryBarrier barrier{.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER};
        6:  395:    barrier.oldLayout = oldLayout;
        6:  396:    barrier.newLayout = newLayout;
        6:  397:    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        6:  398:    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        -:  399:
        6:  400:    barrier.image = image;
        6:  401:    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        6:  402:    barrier.subresourceRange.baseMipLevel = 0;
        6:  403:    barrier.subresourceRange.levelCount = 1;
        6:  404:    barrier.subresourceRange.baseArrayLayer = 0;
        6:  405:    barrier.subresourceRange.layerCount = 1;
        -:  406:
        6:  407:    barrier.srcAccessMask = 0;
        6:  408:    barrier.dstAccessMask = 0;
        -:  409:
        -:  410:    VkPipelineStageFlags sourceStage;
        -:  411:    VkPipelineStageFlags destinationStage;
        -:  412:
        6:  413:    if(oldLayout == VK_IMAGE_LAYOUT_UNDEFINED && newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
        6:  413-block 2
branch  0 taken 3 (fallthrough)
branch  1 taken 3
        3:  413-block 3
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:  414:        barrier.srcAccessMask = 0;
        3:  415:        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        -:  416:
        3:  417:        sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
        3:  418:        destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        3:  418-block 4
        3:  419:    }else if( oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
        3:  419-block 5
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  419-block 6
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:  420:        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        3:  421:        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        -:  422:
        3:  423:        sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        3:  424:        destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
        3:  424-block 7
        -:  425:    }else {
    #####:  426:        throw std::invalid_argument("Unsupported layout transtiion");
    %%%%%:  426-block 8
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  426-block 10
call    4 never executed
    $$$$$:  426-block 13
call    5 never executed
        -:  427:    }
        -:  428:
        6:  429:    vkCmdPipelineBarrier(
        6:  429-block 11
call    0 returned 6
branch  1 taken 6 (fallthrough)
branch  2 taken 0 (throw)
        -:  430:        dependencyInfo.commandBuffer,
        -:  431:        sourceStage, destinationStage,
        -:  432:        0,
        -:  433:        0, nullptr,
        -:  434:        0, nullptr,
        -:  435:        1, &barrier
        -:  436:    );
        6:  437:}
        6:  437-block 12
        -:  438:
        -:  439:
        -:  440:
function _ZL17GenerateImageViewP10VkDevice_TP9VkImage_T8VkFormat called 6 returned 100% blocks executed 50%
        6:  441:static inline VkImageView GenerateImageView(VkDevice logicalDevice,VkImage image, VkFormat format = VK_FORMAT_R8G8B8A8_SRGB) {
        6:  442:    VkImageViewCreateInfo viewInfo{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};
        6:  443:    viewInfo.image = image;
        6:  444:    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
        6:  445:    viewInfo.format = format;
        6:  446:    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        6:  447:    viewInfo.subresourceRange.baseMipLevel = 0;
        6:  448:    viewInfo.subresourceRange.levelCount = 1;
        6:  449:    viewInfo.subresourceRange.baseArrayLayer = 0;
        6:  450:    viewInfo.subresourceRange.layerCount = 1;
        -:  451:
        -:  452:    VkImageView imgView;
        6:  453:    if(vkCreateImageView(logicalDevice, &viewInfo, nullptr, &imgView) != VK_SUCCESS) {
        6:  453-block 2
call    0 returned 6
branch  1 taken 6 (fallthrough)
branch  2 taken 0 (throw)
        6:  453-block 3
branch  3 taken 0 (fallthrough)
branch  4 taken 6
    #####:  454:        throw std::runtime_error("Filed to create image views ");
    %%%%%:  454-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  454-block 6
call    4 never executed
    $$$$$:  454-block 9
call    5 never executed
        -:  455:    }
        -:  456:
        6:  457:    return imgView;
        6:  457-block 7
        6:  457-block 8
        -:  458:}
        -:  459:
        -:  460:
function _ZL14GenerateSphereRSt6vectorI6VertexSaIS0_EERS_IjSaIjEE called 0 returned 0% blocks executed 0%
    #####:  461:static inline void GenerateSphere(std::vector<Vertex> &vertices, std::vector<uint32_t> &indices) {
    #####:  462:    const unsigned int X_SEGMENTS = 64;
    #####:  463:    const unsigned int Y_SEGMENTS = 64;
    #####:  464:    const float PI = 3.14159265359f;
    #####:  465:    for (unsigned int x = 0; x <= X_SEGMENTS; ++x)
    %%%%%:  465-block 2
    %%%%%:  465-block 15
    %%%%%:  465-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  466:    {
    #####:  467:        for (unsigned int y = 0; y <= Y_SEGMENTS; ++y)
    %%%%%:  467-block 3
    %%%%%:  467-block 13
    %%%%%:  467-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  468:        {
    #####:  469:            float xSegment = (float)x / (float)X_SEGMENTS;
    #####:  470:            float ySegment = (float)y / (float)Y_SEGMENTS;
    #####:  471:            float xPos = std::cos(xSegment * 2.0f * PI) * std::sin(ySegment * PI);
    %%%%%:  471-block 4
call    0 never executed
call    1 never executed
    #####:  472:            float yPos = std::cos(ySegment * PI);
call    0 never executed
    #####:  473:            float zPos = std::sin(xSegment * 2.0f * PI) * std::sin(ySegment * PI);
call    0 never executed
call    1 never executed
        -:  474:
    #####:  475:            Vertex tempVertex {};
    #####:  476:            tempVertex.pos = glm::vec3(xPos, yPos, zPos);
call    0 never executed
    #####:  477:            tempVertex.normal = glm::vec3(xPos, yPos, zPos);
call    0 never executed
    #####:  478:            tempVertex.uv = glm::vec2(xSegment, ySegment);
call    0 never executed
        -:  479:
    #####:  480:            vertices.push_back(tempVertex);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  481:        }
        -:  482:    }
        -:  483:
    #####:  484:    bool oddRow = false;
    #####:  485:    for (unsigned int y = 0; y < Y_SEGMENTS; ++y)
    %%%%%:  485-block 17
    %%%%%:  485-block 30
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  486:    {
    #####:  487:        if (!oddRow)
    %%%%%:  487-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  488:        {
    #####:  489:            for (unsigned int x = 0; x <= X_SEGMENTS; ++x)
    %%%%%:  489-block 19
    %%%%%:  489-block 23
branch  0 never executed
branch  1 never executed
        -:  490:            {
    #####:  491:                indices.push_back(y * (X_SEGMENTS + 1) + x);
    %%%%%:  491-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    $$$$$:  491-block 33
call    3 never executed
    #####:  492:                indices.push_back((y + 1) * (X_SEGMENTS + 1) + x);
    %%%%%:  492-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  492-block 22
    $$$$$:  492-block 34
call    3 never executed
        -:  493:            }
        -:  494:        }
        -:  495:        else
        -:  496:        {
    #####:  497:            for (int x = X_SEGMENTS; x >= 0; --x)
    %%%%%:  497-block 24
    %%%%%:  497-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  498:            {
    #####:  499:                indices.push_back((y + 1) * (X_SEGMENTS + 1) + x);
    %%%%%:  499-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    $$$$$:  499-block 35
call    3 never executed
    #####:  500:                indices.push_back(y * (X_SEGMENTS + 1) + x);
    %%%%%:  500-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  500-block 27
        -:  501:            }
        -:  502:        }
    #####:  503:        oddRow = !oddRow;
    %%%%%:  503-block 29
        -:  504:    }
        -:  505:
    #####:  506:}
    %%%%%:  506-block 31
        -:  507:
        -:  508:
        -:  509:#endif //UTILS_HPP
