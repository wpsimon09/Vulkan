        -:    0:Source:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/Includes/stb/stb_image.h
        -:    0:Graph:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/stb/stb_image.cpp.gcno
        -:    0:Data:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/stb/stb_image.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by wpsimon09 on 21/08/24.
        -:    3://
        -:    4:
        -:    5:#ifndef STB_IMAGE_H
        -:    6:#define STB_IMAGE_H
        -:    7:/* stb_image - v2.30 - public domain image loader - http://nothings.org/stb
        -:    8:                                  no warranty implied; use at your own risk
        -:    9:
        -:   10:   Do this:
        -:   11:      #define STB_IMAGE_IMPLEMENTATION
        -:   12:   before you include this file in *one* C or C++ file to create the implementation.
        -:   13:
        -:   14:   // i.e. it should look like this:
        -:   15:   #include ...
        -:   16:   #include ...
        -:   17:   #include ...
        -:   18:   #define STB_IMAGE_IMPLEMENTATION
        -:   19:   #include "stb_image.h"
        -:   20:
        -:   21:   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
        -:   22:   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free
        -:   23:
        -:   24:
        -:   25:   QUICK NOTES:
        -:   26:      Primarily of interest to game developers and other people who can
        -:   27:          avoid problematic images and only need the trivial interface
        -:   28:
        -:   29:      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
        -:   30:      PNG 1/2/4/8/16-bit-per-channel
        -:   31:
        -:   32:      TGA (not sure what subset, if a subset)
        -:   33:      BMP non-1bpp, non-RLE
        -:   34:      PSD (composited view only, no extra channels, 8/16 bit-per-channel)
        -:   35:
        -:   36:      GIF (*comp always reports as 4-channel)
        -:   37:      HDR (radiance rgbE format)
        -:   38:      PIC (Softimage PIC)
        -:   39:      PNM (PPM and PGM binary only)
        -:   40:
        -:   41:      Animated GIF still needs a proper API, but here's one way to do it:
        -:   42:          http://gist.github.com/urraka/685d9a6340b26b830d49
        -:   43:
        -:   44:      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
        -:   45:      - decode from arbitrary I/O callbacks
        -:   46:      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)
        -:   47:
        -:   48:   Full documentation under "DOCUMENTATION" below.
        -:   49:
        -:   50:
        -:   51:LICENSE
        -:   52:
        -:   53:  See end of file for license information.
        -:   54:
        -:   55:RECENT REVISION HISTORY:
        -:   56:
        -:   57:      2.30  (2024-05-31) avoid erroneous gcc warning
        -:   58:      2.29  (2023-05-xx) optimizations
        -:   59:      2.28  (2023-01-29) many error fixes, security errors, just tons of stuff
        -:   60:      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
        -:   61:      2.26  (2020-07-13) many minor fixes
        -:   62:      2.25  (2020-02-02) fix warnings
        -:   63:      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
        -:   64:      2.23  (2019-08-11) fix clang static analysis warning
        -:   65:      2.22  (2019-03-04) gif fixes, fix warnings
        -:   66:      2.21  (2019-02-25) fix typo in comment
        -:   67:      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
        -:   68:      2.19  (2018-02-11) fix warning
        -:   69:      2.18  (2018-01-30) fix warnings
        -:   70:      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
        -:   71:      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
        -:   72:      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
        -:   73:      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
        -:   74:      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
        -:   75:      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
        -:   76:      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
        -:   77:                         RGB-format JPEG; remove white matting in PSD;
        -:   78:                         allocate large structures on the stack;
        -:   79:                         correct channel count for PNG & BMP
        -:   80:      2.10  (2016-01-22) avoid warning introduced in 2.09
        -:   81:      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED
        -:   82:
        -:   83:   See end of file for full revision history.
        -:   84:
        -:   85:
        -:   86: ============================    Contributors    =========================
        -:   87:
        -:   88: Image formats                          Extensions, features
        -:   89:    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
        -:   90:    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
        -:   91:    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
        -:   92:    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
        -:   93:    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
        -:   94:    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
        -:   95:    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
        -:   96:    github:urraka (animated gif)           Junggon Kim (PNM comments)
        -:   97:    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
        -:   98:                                           socks-the-fox (16-bit PNG)
        -:   99:                                           Jeremy Sawicki (handle all ImageNet JPGs)
        -:  100: Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
        -:  101:    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
        -:  102:    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
        -:  103:    John-Mark Allen
        -:  104:    Carmelo J Fdez-Aguera
        -:  105:
        -:  106: Bug & warning fixes
        -:  107:    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko
        -:  108:    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski
        -:  109:    Phil Jordan                                Dave Moore           Roy Eltham
        -:  110:    Hayaki Saito            Nathan Reed        Won Chun
        -:  111:    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community
        -:  112:    Thomas Ruf              Ronny Chevalier                         github:rlyeh
        -:  113:    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou
        -:  114:    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk
        -:  115:    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar
        -:  116:    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex
        -:  117:    Cass Everitt            Ryamond Barbiero                        github:grim210
        -:  118:    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw
        -:  119:    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus
        -:  120:    Josh Tobin              Neil Bickford      Matthew Gregan       github:poppolopoppo
        -:  121:    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji
        -:  122:    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007
        -:  123:                            Brad Weinberger    Matvey Cherevko      github:mosra
        -:  124:    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]
        -:  125:    Ryan C. Gordon          [reserved]                              [reserved]
        -:  126:                     DO NOT ADD YOUR NAME HERE
        -:  127:
        -:  128:                     Jacko Dirks
        -:  129:
        -:  130:  To add your name to the credits, pick a random blank space in the middle and fill it.
        -:  131:  80% of merge conflicts on stb PRs are due to people adding their name at the end
        -:  132:  of the credits.
        -:  133:*/
        -:  134:
        -:  135:#ifndef STBI_INCLUDE_STB_IMAGE_H
        -:  136:#define STBI_INCLUDE_STB_IMAGE_H
        -:  137:
        -:  138:// DOCUMENTATION
        -:  139://
        -:  140:// Limitations:
        -:  141://    - no 12-bit-per-channel JPEG
        -:  142://    - no JPEGs with arithmetic coding
        -:  143://    - GIF always returns *comp=4
        -:  144://
        -:  145:// Basic usage (see HDR discussion below for HDR usage):
        -:  146://    int x,y,n;
        -:  147://    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
        -:  148://    // ... process data if not NULL ...
        -:  149://    // ... x = width, y = height, n = # 8-bit components per pixel ...
        -:  150://    // ... replace '0' with '1'..'4' to force that many components per pixel
        -:  151://    // ... but 'n' will always be the number that it would have been if you said 0
        -:  152://    stbi_image_free(data);
        -:  153://
        -:  154:// Standard parameters:
        -:  155://    int *x                 -- outputs image width in pixels
        -:  156://    int *y                 -- outputs image height in pixels
        -:  157://    int *channels_in_file  -- outputs # of image components in image file
        -:  158://    int desired_channels   -- if non-zero, # of image components requested in result
        -:  159://
        -:  160:// The return value from an image loader is an 'unsigned char *' which points
        -:  161:// to the pixel data, or NULL on an allocation failure or if the image is
        -:  162:// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
        -:  163:// with each pixel consisting of N interleaved 8-bit components; the first
        -:  164:// pixel pointed to is top-left-most in the image. There is no padding between
        -:  165:// image scanlines or between pixels, regardless of format. The number of
        -:  166:// components N is 'desired_channels' if desired_channels is non-zero, or
        -:  167:// *channels_in_file otherwise. If desired_channels is non-zero,
        -:  168:// *channels_in_file has the number of components that _would_ have been
        -:  169:// output otherwise. E.g. if you set desired_channels to 4, you will always
        -:  170:// get RGBA output, but you can check *channels_in_file to see if it's trivially
        -:  171:// opaque because e.g. there were only 3 channels in the source image.
        -:  172://
        -:  173:// An output image with N components has the following components interleaved
        -:  174:// in this order in each pixel:
        -:  175://
        -:  176://     N=#comp     components
        -:  177://       1           grey
        -:  178://       2           grey, alpha
        -:  179://       3           red, green, blue
        -:  180://       4           red, green, blue, alpha
        -:  181://
        -:  182:// If image loading fails for any reason, the return value will be NULL,
        -:  183:// and *x, *y, *channels_in_file will be unchanged. The function
        -:  184:// stbi_failure_reason() can be queried for an extremely brief, end-user
        -:  185:// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
        -:  186:// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
        -:  187:// more user-friendly ones.
        -:  188://
        -:  189:// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
        -:  190://
        -:  191:// To query the width, height and component count of an image without having to
        -:  192:// decode the full file, you can use the stbi_info family of functions:
        -:  193://
        -:  194://   int x,y,n,ok;
        -:  195://   ok = stbi_info(filename, &x, &y, &n);
        -:  196://   // returns ok=1 and sets x, y, n if image is a supported format,
        -:  197://   // 0 otherwise.
        -:  198://
        -:  199:// Note that stb_image pervasively uses ints in its public API for sizes,
        -:  200:// including sizes of memory buffers. This is now part of the API and thus
        -:  201:// hard to change without causing breakage. As a result, the various image
        -:  202:// loaders all have certain limits on image size; these differ somewhat
        -:  203:// by format but generally boil down to either just under 2GB or just under
        -:  204:// 1GB. When the decoded image would be larger than this, stb_image decoding
        -:  205:// will fail.
        -:  206://
        -:  207:// Additionally, stb_image will reject image files that have any of their
        -:  208:// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,
        -:  209:// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,
        -:  210:// the only way to have an image with such dimensions load correctly
        -:  211:// is for it to have a rather extreme aspect ratio. Either way, the
        -:  212:// assumption here is that such larger images are likely to be malformed
        -:  213:// or malicious. If you do need to load an image with individual dimensions
        -:  214:// larger than that, and it still fits in the overall size limit, you can
        -:  215:// #define STBI_MAX_DIMENSIONS on your own to be something larger.
        -:  216://
        -:  217:// ===========================================================================
        -:  218://
        -:  219:// UNICODE:
        -:  220://
        -:  221://   If compiling for Windows and you wish to use Unicode filenames, compile
        -:  222://   with
        -:  223://       #define STBI_WINDOWS_UTF8
        -:  224://   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
        -:  225://   Windows wchar_t filenames to utf8.
        -:  226://
        -:  227:// ===========================================================================
        -:  228://
        -:  229:// Philosophy
        -:  230://
        -:  231:// stb libraries are designed with the following priorities:
        -:  232://
        -:  233://    1. easy to use
        -:  234://    2. easy to maintain
        -:  235://    3. good performance
        -:  236://
        -:  237:// Sometimes I let "good performance" creep up in priority over "easy to maintain",
        -:  238:// and for best performance I may provide less-easy-to-use APIs that give higher
        -:  239:// performance, in addition to the easy-to-use ones. Nevertheless, it's important
        -:  240:// to keep in mind that from the standpoint of you, a client of this library,
        -:  241:// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
        -:  242://
        -:  243:// Some secondary priorities arise directly from the first two, some of which
        -:  244:// provide more explicit reasons why performance can't be emphasized.
        -:  245://
        -:  246://    - Portable ("ease of use")
        -:  247://    - Small source code footprint ("easy to maintain")
        -:  248://    - No dependencies ("ease of use")
        -:  249://
        -:  250:// ===========================================================================
        -:  251://
        -:  252:// I/O callbacks
        -:  253://
        -:  254:// I/O callbacks allow you to read from arbitrary sources, like packaged
        -:  255:// files or some other source. Data read from callbacks are processed
        -:  256:// through a small internal buffer (currently 128 bytes) to try to reduce
        -:  257:// overhead.
        -:  258://
        -:  259:// The three functions you must define are "read" (reads some bytes of data),
        -:  260:// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
        -:  261://
        -:  262:// ===========================================================================
        -:  263://
        -:  264:// SIMD support
        -:  265://
        -:  266:// The JPEG decoder will try to automatically use SIMD kernels on x86 when
        -:  267:// supported by the compiler. For ARM Neon support, you must explicitly
        -:  268:// request it.
        -:  269://
        -:  270:// (The old do-it-yourself SIMD API is no longer supported in the current
        -:  271:// code.)
        -:  272://
        -:  273:// On x86, SSE2 will automatically be used when available based on a run-time
        -:  274:// test; if not, the generic C versions are used as a fall-back. On ARM targets,
        -:  275:// the typical path is to have separate builds for NEON and non-NEON devices
        -:  276:// (at least this is true for iOS and Android). Therefore, the NEON support is
        -:  277:// toggled by a build flag: define STBI_NEON to get NEON loops.
        -:  278://
        -:  279:// If for some reason you do not want to use any of SIMD code, or if
        -:  280:// you have issues compiling it, you can disable it entirely by
        -:  281:// defining STBI_NO_SIMD.
        -:  282://
        -:  283:// ===========================================================================
        -:  284://
        -:  285:// HDR image support   (disable by defining STBI_NO_HDR)
        -:  286://
        -:  287:// stb_image supports loading HDR images in general, and currently the Radiance
        -:  288:// .HDR file format specifically. You can still load any file through the existing
        -:  289:// interface; if you attempt to load an HDR file, it will be automatically remapped
        -:  290:// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
        -:  291:// both of these constants can be reconfigured through this interface:
        -:  292://
        -:  293://     stbi_hdr_to_ldr_gamma(2.2f);
        -:  294://     stbi_hdr_to_ldr_scale(1.0f);
        -:  295://
        -:  296:// (note, do not use _inverse_ constants; stbi_image will invert them
        -:  297:// appropriately).
        -:  298://
        -:  299:// Additionally, there is a new, parallel interface for loading files as
        -:  300:// (linear) floats to preserve the full dynamic range:
        -:  301://
        -:  302://    float *data = stbi_loadf(filename, &x, &y, &n, 0);
        -:  303://
        -:  304:// If you load LDR images through this interface, those images will
        -:  305:// be promoted to floating point values, run through the inverse of
        -:  306:// constants corresponding to the above:
        -:  307://
        -:  308://     stbi_ldr_to_hdr_scale(1.0f);
        -:  309://     stbi_ldr_to_hdr_gamma(2.2f);
        -:  310://
        -:  311:// Finally, given a filename (or an open file or memory block--see header
        -:  312:// file for details) containing image data, you can query for the "most
        -:  313:// appropriate" interface to use (that is, whether the image is HDR or
        -:  314:// not), using:
        -:  315://
        -:  316://     stbi_is_hdr(char *filename);
        -:  317://
        -:  318:// ===========================================================================
        -:  319://
        -:  320:// iPhone PNG support:
        -:  321://
        -:  322:// We optionally support converting iPhone-formatted PNGs (which store
        -:  323:// premultiplied BGRA) back to RGB, even though they're internally encoded
        -:  324:// differently. To enable this conversion, call
        -:  325:// stbi_convert_iphone_png_to_rgb(1).
        -:  326://
        -:  327:// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
        -:  328:// pixel to remove any premultiplied alpha *only* if the image file explicitly
        -:  329:// says there's premultiplied data (currently only happens in iPhone images,
        -:  330:// and only if iPhone convert-to-rgb processing is on).
        -:  331://
        -:  332:// ===========================================================================
        -:  333://
        -:  334:// ADDITIONAL CONFIGURATION
        -:  335://
        -:  336://  - You can suppress implementation of any of the decoders to reduce
        -:  337://    your code footprint by #defining one or more of the following
        -:  338://    symbols before creating the implementation.
        -:  339://
        -:  340://        STBI_NO_JPEG
        -:  341://        STBI_NO_PNG
        -:  342://        STBI_NO_BMP
        -:  343://        STBI_NO_PSD
        -:  344://        STBI_NO_TGA
        -:  345://        STBI_NO_GIF
        -:  346://        STBI_NO_HDR
        -:  347://        STBI_NO_PIC
        -:  348://        STBI_NO_PNM   (.ppm and .pgm)
        -:  349://
        -:  350://  - You can request *only* certain decoders and suppress all other ones
        -:  351://    (this will be more forward-compatible, as addition of new decoders
        -:  352://    doesn't require you to disable them explicitly):
        -:  353://
        -:  354://        STBI_ONLY_JPEG
        -:  355://        STBI_ONLY_PNG
        -:  356://        STBI_ONLY_BMP
        -:  357://        STBI_ONLY_PSD
        -:  358://        STBI_ONLY_TGA
        -:  359://        STBI_ONLY_GIF
        -:  360://        STBI_ONLY_HDR
        -:  361://        STBI_ONLY_PIC
        -:  362://        STBI_ONLY_PNM   (.ppm and .pgm)
        -:  363://
        -:  364://   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
        -:  365://     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
        -:  366://
        -:  367://  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
        -:  368://    than that size (in either width or height) without further processing.
        -:  369://    This is to let programs in the wild set an upper bound to prevent
        -:  370://    denial-of-service attacks on untrusted data, as one could generate a
        -:  371://    valid image of gigantic dimensions and force stb_image to allocate a
        -:  372://    huge block of memory and spend disproportionate time decoding it. By
        -:  373://    default this is set to (1 << 24), which is 16777216, but that's still
        -:  374://    very big.
        -:  375:
        -:  376:#ifndef STBI_NO_STDIO
        -:  377:#include <stdio.h>
        -:  378:#endif // STBI_NO_STDIO
        -:  379:
        -:  380:#define STBI_VERSION 1
        -:  381:
        -:  382:enum
        -:  383:{
        -:  384:   STBI_default = 0, // only used for desired_channels
        -:  385:
        -:  386:   STBI_grey       = 1,
        -:  387:   STBI_grey_alpha = 2,
        -:  388:   STBI_rgb        = 3,
        -:  389:   STBI_rgb_alpha  = 4
        -:  390:};
        -:  391:
        -:  392:#include <stdlib.h>
        -:  393:typedef unsigned char stbi_uc;
        -:  394:typedef unsigned short stbi_us;
        -:  395:
        -:  396:#ifdef __cplusplus
        -:  397:extern "C" {
        -:  398:#endif
        -:  399:
        -:  400:#ifndef STBIDEF
        -:  401:#ifdef STB_IMAGE_STATIC
        -:  402:#define STBIDEF static
        -:  403:#else
        -:  404:#define STBIDEF extern
        -:  405:#endif
        -:  406:#endif
        -:  407:
        -:  408://////////////////////////////////////////////////////////////////////////////
        -:  409://
        -:  410:// PRIMARY API - works on images of any type
        -:  411://
        -:  412:
        -:  413://
        -:  414:// load image by filename, open file, or memory buffer
        -:  415://
        -:  416:
        -:  417:typedef struct
        -:  418:{
        -:  419:   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
        -:  420:   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
        -:  421:   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
        -:  422:} stbi_io_callbacks;
        -:  423:
        -:  424:////////////////////////////////////
        -:  425://
        -:  426:// 8-bits-per-channel interface
        -:  427://
        -:  428:
        -:  429:STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
        -:  430:STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  431:
        -:  432:#ifndef STBI_NO_STDIO
        -:  433:STBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  434:STBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  435:// for stbi_load_from_file, file pointer is left pointing immediately after image
        -:  436:#endif
        -:  437:
        -:  438:#ifndef STBI_NO_GIF
        -:  439:STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
        -:  440:#endif
        -:  441:
        -:  442:#ifdef STBI_WINDOWS_UTF8
        -:  443:STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
        -:  444:#endif
        -:  445:
        -:  446:////////////////////////////////////
        -:  447://
        -:  448:// 16-bits-per-channel interface
        -:  449://
        -:  450:
        -:  451:STBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  452:STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  453:
        -:  454:#ifndef STBI_NO_STDIO
        -:  455:STBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  456:STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  457:#endif
        -:  458:
        -:  459:////////////////////////////////////
        -:  460://
        -:  461:// float-per-channel interface
        -:  462://
        -:  463:#ifndef STBI_NO_LINEAR
        -:  464:   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  465:   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);
        -:  466:
        -:  467:   #ifndef STBI_NO_STDIO
        -:  468:   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  469:   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  470:   #endif
        -:  471:#endif
        -:  472:
        -:  473:#ifndef STBI_NO_HDR
        -:  474:   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
        -:  475:   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
        -:  476:#endif // STBI_NO_HDR
        -:  477:
        -:  478:#ifndef STBI_NO_LINEAR
        -:  479:   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
        -:  480:   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
        -:  481:#endif // STBI_NO_LINEAR
        -:  482:
        -:  483:// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
        -:  484:STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
        -:  485:STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
        -:  486:#ifndef STBI_NO_STDIO
        -:  487:STBIDEF int      stbi_is_hdr          (char const *filename);
        -:  488:STBIDEF int      stbi_is_hdr_from_file(FILE *f);
        -:  489:#endif // STBI_NO_STDIO
        -:  490:
        -:  491:
        -:  492:// get a VERY brief reason for failure
        -:  493:// on most compilers (and ALL modern mainstream compilers) this is threadsafe
        -:  494:STBIDEF const char *stbi_failure_reason  (void);
        -:  495:
        -:  496:// free the loaded image -- this is just free()
        -:  497:STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);
        -:  498:
        -:  499:// get image dimensions & components without fully decoding
        -:  500:STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
        -:  501:STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
        -:  502:STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
        -:  503:STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);
        -:  504:
        -:  505:#ifndef STBI_NO_STDIO
        -:  506:STBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);
        -:  507:STBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);
        -:  508:STBIDEF int      stbi_is_16_bit          (char const *filename);
        -:  509:STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
        -:  510:#endif
        -:  511:
        -:  512:
        -:  513:
        -:  514:// for image formats that explicitly notate that they have premultiplied alpha,
        -:  515:// we just return the colors as stored in the file. set this flag to force
        -:  516:// unpremultiplication. results are undefined if the unpremultiply overflow.
        -:  517:STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);
        -:  518:
        -:  519:// indicate whether we should process iphone images back to canonical format,
        -:  520:// or just pass them through "as-is"
        -:  521:STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);
        -:  522:
        -:  523:// flip the image vertically, so the first pixel in the output array is the bottom left
        -:  524:STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);
        -:  525:
        -:  526:// as above, but only applies to images loaded on the thread that calls the function
        -:  527:// this function is only available if your compiler supports thread-local variables;
        -:  528:// calling it will fail to link if your compiler doesn't
        -:  529:STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
        -:  530:STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
        -:  531:STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);
        -:  532:
        -:  533:// ZLIB client - used by PNG, available for other purposes
        -:  534:
        -:  535:STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
        -:  536:STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
        -:  537:STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
        -:  538:STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
        -:  539:
        -:  540:STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
        -:  541:STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
        -:  542:
        -:  543:
        -:  544:#ifdef __cplusplus
        -:  545:}
        -:  546:#endif
        -:  547:
        -:  548://
        -:  549://
        -:  550:////   end header file   /////////////////////////////////////////////////////
        -:  551:#endif // STBI_INCLUDE_STB_IMAGE_H
        -:  552:
        -:  553:#ifdef STB_IMAGE_IMPLEMENTATION
        -:  554:
        -:  555:#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
        -:  556:  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
        -:  557:  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
        -:  558:  || defined(STBI_ONLY_ZLIB)
        -:  559:   #ifndef STBI_ONLY_JPEG
        -:  560:   #define STBI_NO_JPEG
        -:  561:   #endif
        -:  562:   #ifndef STBI_ONLY_PNG
        -:  563:   #define STBI_NO_PNG
        -:  564:   #endif
        -:  565:   #ifndef STBI_ONLY_BMP
        -:  566:   #define STBI_NO_BMP
        -:  567:   #endif
        -:  568:   #ifndef STBI_ONLY_PSD
        -:  569:   #define STBI_NO_PSD
        -:  570:   #endif
        -:  571:   #ifndef STBI_ONLY_TGA
        -:  572:   #define STBI_NO_TGA
        -:  573:   #endif
        -:  574:   #ifndef STBI_ONLY_GIF
        -:  575:   #define STBI_NO_GIF
        -:  576:   #endif
        -:  577:   #ifndef STBI_ONLY_HDR
        -:  578:   #define STBI_NO_HDR
        -:  579:   #endif
        -:  580:   #ifndef STBI_ONLY_PIC
        -:  581:   #define STBI_NO_PIC
        -:  582:   #endif
        -:  583:   #ifndef STBI_ONLY_PNM
        -:  584:   #define STBI_NO_PNM
        -:  585:   #endif
        -:  586:#endif
        -:  587:
        -:  588:#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
        -:  589:#define STBI_NO_ZLIB
        -:  590:#endif
        -:  591:
        -:  592:
        -:  593:#include <stdarg.h>
        -:  594:#include <stddef.h> // ptrdiff_t on osx
        -:  595:#include <stdlib.h>
        -:  596:#include <string.h>
        -:  597:#include <limits.h>
        -:  598:
        -:  599:#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
        -:  600:#include <math.h>  // ldexp, pow
        -:  601:#endif
        -:  602:
        -:  603:#ifndef STBI_NO_STDIO
        -:  604:#include <stdio.h>
        -:  605:#endif
        -:  606:
        -:  607:#ifndef STBI_ASSERT
        -:  608:#include <assert.h>
        -:  609:#define STBI_ASSERT(x) assert(x)
        -:  610:#endif
        -:  611:
        -:  612:#ifdef __cplusplus
        -:  613:#define STBI_EXTERN extern "C"
        -:  614:#else
        -:  615:#define STBI_EXTERN extern
        -:  616:#endif
        -:  617:
        -:  618:
        -:  619:#ifndef _MSC_VER
        -:  620:   #ifdef __cplusplus
        -:  621:   #define stbi_inline inline
        -:  622:   #else
        -:  623:   #define stbi_inline
        -:  624:   #endif
        -:  625:#else
        -:  626:   #define stbi_inline __forceinline
        -:  627:#endif
        -:  628:
        -:  629:#ifndef STBI_NO_THREAD_LOCALS
        -:  630:   #if defined(__cplusplus) &&  __cplusplus >= 201103L
        -:  631:      #define STBI_THREAD_LOCAL       thread_local
        -:  632:   #elif defined(__GNUC__) && __GNUC__ < 5
        -:  633:      #define STBI_THREAD_LOCAL       __thread
        -:  634:   #elif defined(_MSC_VER)
        -:  635:      #define STBI_THREAD_LOCAL       __declspec(thread)
        -:  636:   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
        -:  637:      #define STBI_THREAD_LOCAL       _Thread_local
        -:  638:   #endif
        -:  639:
        -:  640:   #ifndef STBI_THREAD_LOCAL
        -:  641:      #if defined(__GNUC__)
        -:  642:        #define STBI_THREAD_LOCAL       __thread
        -:  643:      #endif
        -:  644:   #endif
        -:  645:#endif
        -:  646:
        -:  647:#if defined(_MSC_VER) || defined(__SYMBIAN32__)
        -:  648:typedef unsigned short stbi__uint16;
        -:  649:typedef   signed short stbi__int16;
        -:  650:typedef unsigned int   stbi__uint32;
        -:  651:typedef   signed int   stbi__int32;
        -:  652:#else
        -:  653:#include <stdint.h>
        -:  654:typedef uint16_t stbi__uint16;
        -:  655:typedef int16_t  stbi__int16;
        -:  656:typedef uint32_t stbi__uint32;
        -:  657:typedef int32_t  stbi__int32;
        -:  658:#endif
        -:  659:
        -:  660:// should produce compiler error if size is wrong
        -:  661:typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];
        -:  662:
        -:  663:#ifdef _MSC_VER
        -:  664:#define STBI_NOTUSED(v)  (void)(v)
        -:  665:#else
        -:  666:#define STBI_NOTUSED(v)  (void)sizeof(v)
        -:  667:#endif
        -:  668:
        -:  669:#ifdef _MSC_VER
        -:  670:#define STBI_HAS_LROTL
        -:  671:#endif
        -:  672:
        -:  673:#ifdef STBI_HAS_LROTL
        -:  674:   #define stbi_lrot(x,y)  _lrotl(x,y)
        -:  675:#else
        -:  676:   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
        -:  677:#endif
        -:  678:
        -:  679:#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
        -:  680:// ok
        -:  681:#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
        -:  682:// ok
        -:  683:#else
        -:  684:#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
        -:  685:#endif
        -:  686:
        -:  687:#ifndef STBI_MALLOC
        -:  688:#define STBI_MALLOC(sz)           malloc(sz)
        -:  689:#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
        -:  690:#define STBI_FREE(p)              free(p)
        -:  691:#endif
        -:  692:
        -:  693:#ifndef STBI_REALLOC_SIZED
        -:  694:#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
        -:  695:#endif
        -:  696:
        -:  697:// x86/x64 detection
        -:  698:#if defined(__x86_64__) || defined(_M_X64)
        -:  699:#define STBI__X64_TARGET
        -:  700:#elif defined(__i386) || defined(_M_IX86)
        -:  701:#define STBI__X86_TARGET
        -:  702:#endif
        -:  703:
        -:  704:#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
        -:  705:// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
        -:  706:// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
        -:  707:// but previous attempts to provide the SSE2 functions with runtime
        -:  708:// detection caused numerous issues. The way architecture extensions are
        -:  709:// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
        -:  710:// New behavior: if compiled with -msse2, we use SSE2 without any
        -:  711:// detection; if not, we don't use it at all.
        -:  712:#define STBI_NO_SIMD
        -:  713:#endif
        -:  714:
        -:  715:#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
        -:  716:// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
        -:  717://
        -:  718:// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
        -:  719:// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
        -:  720:// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
        -:  721:// simultaneously enabling "-mstackrealign".
        -:  722://
        -:  723:// See https://github.com/nothings/stb/issues/81 for more information.
        -:  724://
        -:  725:// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
        -:  726:// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
        -:  727:#define STBI_NO_SIMD
        -:  728:#endif
        -:  729:
        -:  730:#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
        -:  731:#define STBI_SSE2
        -:  732:#include <emmintrin.h>
        -:  733:
        -:  734:#ifdef _MSC_VER
        -:  735:
        -:  736:#if _MSC_VER >= 1400  // not VC6
        -:  737:#include <intrin.h> // __cpuid
        -:  738:static int stbi__cpuid3(void)
        -:  739:{
        -:  740:   int info[4];
        -:  741:   __cpuid(info,1);
        -:  742:   return info[3];
        -:  743:}
        -:  744:#else
        -:  745:static int stbi__cpuid3(void)
        -:  746:{
        -:  747:   int res;
        -:  748:   __asm {
        -:  749:      mov  eax,1
        -:  750:      cpuid
        -:  751:      mov  res,edx
        -:  752:   }
        -:  753:   return res;
        -:  754:}
        -:  755:#endif
        -:  756:
        -:  757:#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
        -:  758:
        -:  759:#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
        -:  760:static int stbi__sse2_available(void)
        -:  761:{
        -:  762:   int info3 = stbi__cpuid3();
        -:  763:   return ((info3 >> 26) & 1) != 0;
        -:  764:}
        -:  765:#endif
        -:  766:
        -:  767:#else // assume GCC-style if not VC++
        -:  768:#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
        -:  769:
        -:  770:#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
function _ZL20stbi__sse2_availablev called 0 returned 0% blocks executed 0%
    #####:  771:static int stbi__sse2_available(void)
        -:  772:{
        -:  773:   // If we're even attempting to compile this on GCC/Clang, that means
        -:  774:   // -msse2 is on, which means the compiler is allowed to use SSE2
        -:  775:   // instructions at will, and so are we.
    #####:  776:   return 1;
    %%%%%:  776-block 2
        -:  777:}
        -:  778:#endif
        -:  779:
        -:  780:#endif
        -:  781:#endif
        -:  782:
        -:  783:// ARM NEON
        -:  784:#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
        -:  785:#undef STBI_NEON
        -:  786:#endif
        -:  787:
        -:  788:#ifdef STBI_NEON
        -:  789:#include <arm_neon.h>
        -:  790:#ifdef _MSC_VER
        -:  791:#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
        -:  792:#else
        -:  793:#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
        -:  794:#endif
        -:  795:#endif
        -:  796:
        -:  797:#ifndef STBI_SIMD_ALIGN
        -:  798:#define STBI_SIMD_ALIGN(type, name) type name
        -:  799:#endif
        -:  800:
        -:  801:#ifndef STBI_MAX_DIMENSIONS
        -:  802:#define STBI_MAX_DIMENSIONS (1 << 24)
        -:  803:#endif
        -:  804:
        -:  805:///////////////////////////////////////////////
        -:  806://
        -:  807://  stbi__context struct and start_xxx functions
        -:  808:
        -:  809:// stbi__context structure is our basic context used by all images, so it
        -:  810:// contains all the IO context, plus some basic image information
        -:  811:typedef struct
        -:  812:{
        -:  813:   stbi__uint32 img_x, img_y;
        -:  814:   int img_n, img_out_n;
        -:  815:
        -:  816:   stbi_io_callbacks io;
        -:  817:   void *io_user_data;
        -:  818:
        -:  819:   int read_from_callbacks;
        -:  820:   int buflen;
        -:  821:   stbi_uc buffer_start[128];
        -:  822:   int callback_already_read;
        -:  823:
        -:  824:   stbi_uc *img_buffer, *img_buffer_end;
        -:  825:   stbi_uc *img_buffer_original, *img_buffer_original_end;
        -:  826:} stbi__context;
        -:  827:
        -:  828:
        -:  829:static void stbi__refill_buffer(stbi__context *s);
        -:  830:
        -:  831:// initialize a memory-decode context
function _ZL15stbi__start_memP13stbi__contextPKhi called 0 returned 0% blocks executed 0%
    #####:  832:static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
        -:  833:{
    #####:  834:   s->io.read = NULL;
    #####:  835:   s->read_from_callbacks = 0;
    #####:  836:   s->callback_already_read = 0;
    #####:  837:   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
    #####:  838:   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
    #####:  839:}
        -:  840:
        -:  841:// initialize a callback-based context
function _ZL21stbi__start_callbacksP13stbi__contextP17stbi_io_callbacksPv called 3 returned 100% blocks executed 100%
        3:  842:static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
        -:  843:{
        3:  844:   s->io = *c;
        3:  845:   s->io_user_data = user;
        3:  846:   s->buflen = sizeof(s->buffer_start);
        3:  847:   s->read_from_callbacks = 1;
        3:  848:   s->callback_already_read = 0;
        3:  849:   s->img_buffer = s->img_buffer_original = s->buffer_start;
        3:  850:   stbi__refill_buffer(s);
        3:  850-block 2
call    0 returned 3
        3:  851:   s->img_buffer_original_end = s->img_buffer_end;
        3:  852:}
        -:  853:
        -:  854:#ifndef STBI_NO_STDIO
        -:  855:
function _ZL16stbi__stdio_readPvPci called 3574 returned 100% blocks executed 100%
     3574:  856:static int stbi__stdio_read(void *user, char *data, int size)
        -:  857:{
     3574:  858:   return (int) fread(data,1,size,(FILE*) user);
     3574:  858-block 2
call    0 returned 3574
        -:  859:}
        -:  860:
function _ZL16stbi__stdio_skipPvi called 7 returned 100% blocks executed 100%
        7:  861:static void stbi__stdio_skip(void *user, int n)
        -:  862:{
        -:  863:   int ch;
        7:  864:   fseek((FILE*) user, n, SEEK_CUR);
        7:  864-block 2
call    0 returned 7
        7:  865:   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
call    0 returned 7
        7:  866:   if (ch != EOF) {
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7:  867:      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
        7:  867-block 5
call    0 returned 7
        -:  868:   }
        7:  869:}
        -:  870:
function _ZL15stbi__stdio_eofPv called 0 returned 0% blocks executed 0%
    #####:  871:static int stbi__stdio_eof(void *user)
        -:  872:{
    #####:  873:   return feof((FILE*) user) || ferror((FILE *) user);
    %%%%%:  873-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  873-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  873-block 6
    %%%%%:  873-block 7
    %%%%%:  873-block 8
        -:  874:}
        -:  875:
        -:  876:static stbi_io_callbacks stbi__stdio_callbacks =
        -:  877:{
        -:  878:   stbi__stdio_read,
        -:  879:   stbi__stdio_skip,
        -:  880:   stbi__stdio_eof,
        -:  881:};
        -:  882:
function _ZL16stbi__start_fileP13stbi__contextP8_IO_FILE called 3 returned 100% blocks executed 100%
        3:  883:static void stbi__start_file(stbi__context *s, FILE *f)
        -:  884:{
        3:  885:   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
        3:  885-block 2
call    0 returned 3
        3:  886:}
        -:  887:
        -:  888://static void stop_file(stbi__context *s) { }
        -:  889:
        -:  890:#endif // !STBI_NO_STDIO
        -:  891:
function _ZL12stbi__rewindP13stbi__context called 3 returned 100% blocks executed 100%
        3:  892:static void stbi__rewind(stbi__context *s)
        -:  893:{
        -:  894:   // conceptually rewind SHOULD rewind to the beginning of the stream,
        -:  895:   // but we just rewind to the beginning of the initial buffer, because
        -:  896:   // we only use it after doing 'test', which only ever looks at at most 92 bytes
        3:  897:   s->img_buffer = s->img_buffer_original;
        3:  898:   s->img_buffer_end = s->img_buffer_original_end;
        3:  899:}
        -:  900:
        -:  901:enum
        -:  902:{
        -:  903:   STBI_ORDER_RGB,
        -:  904:   STBI_ORDER_BGR
        -:  905:};
        -:  906:
        -:  907:typedef struct
        -:  908:{
        -:  909:   int bits_per_channel;
        -:  910:   int num_channels;
        -:  911:   int channel_order;
        -:  912:} stbi__result_info;
        -:  913:
        -:  914:#ifndef STBI_NO_JPEG
        -:  915:static int      stbi__jpeg_test(stbi__context *s);
        -:  916:static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  917:static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
        -:  918:#endif
        -:  919:
        -:  920:#ifndef STBI_NO_PNG
        -:  921:static int      stbi__png_test(stbi__context *s);
        -:  922:static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  923:static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
        -:  924:static int      stbi__png_is16(stbi__context *s);
        -:  925:#endif
        -:  926:
        -:  927:#ifndef STBI_NO_BMP
        -:  928:static int      stbi__bmp_test(stbi__context *s);
        -:  929:static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  930:static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
        -:  931:#endif
        -:  932:
        -:  933:#ifndef STBI_NO_TGA
        -:  934:static int      stbi__tga_test(stbi__context *s);
        -:  935:static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  936:static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
        -:  937:#endif
        -:  938:
        -:  939:#ifndef STBI_NO_PSD
        -:  940:static int      stbi__psd_test(stbi__context *s);
        -:  941:static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
        -:  942:static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
        -:  943:static int      stbi__psd_is16(stbi__context *s);
        -:  944:#endif
        -:  945:
        -:  946:#ifndef STBI_NO_HDR
        -:  947:static int      stbi__hdr_test(stbi__context *s);
        -:  948:static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  949:static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
        -:  950:#endif
        -:  951:
        -:  952:#ifndef STBI_NO_PIC
        -:  953:static int      stbi__pic_test(stbi__context *s);
        -:  954:static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  955:static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
        -:  956:#endif
        -:  957:
        -:  958:#ifndef STBI_NO_GIF
        -:  959:static int      stbi__gif_test(stbi__context *s);
        -:  960:static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  961:static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
        -:  962:static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
        -:  963:#endif
        -:  964:
        -:  965:#ifndef STBI_NO_PNM
        -:  966:static int      stbi__pnm_test(stbi__context *s);
        -:  967:static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  968:static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
        -:  969:static int      stbi__pnm_is16(stbi__context *s);
        -:  970:#endif
        -:  971:
        -:  972:static
        -:  973:#ifdef STBI_THREAD_LOCAL
        -:  974:STBI_THREAD_LOCAL
        -:  975:#endif
        -:  976:const char *stbi__g_failure_reason;
        -:  977:
function stbi_failure_reason called 0 returned 0% blocks executed 0%
    #####:  978:STBIDEF const char *stbi_failure_reason(void)
        -:  979:{
    #####:  980:   return stbi__g_failure_reason;
    %%%%%:  980-block 2
        -:  981:}
        -:  982:
        -:  983:#ifndef STBI_NO_FAILURE_STRINGS
function _ZL9stbi__errPKc called 0 returned 0% blocks executed 0%
    #####:  984:static int stbi__err(const char *str)
        -:  985:{
    #####:  986:   stbi__g_failure_reason = str;
    #####:  987:   return 0;
    %%%%%:  987-block 2
        -:  988:}
        -:  989:#endif
        -:  990:
function _ZL12stbi__mallocm called 12 returned 100% blocks executed 100%
       12:  991:static void *stbi__malloc(size_t size)
        -:  992:{
       12:  993:    return STBI_MALLOC(size);
       12:  993-block 2
        -:  994:}
        -:  995:
        -:  996:// stb_image uses ints pervasively, including for offset calculations.
        -:  997:// therefore the largest decoded image size we can support with the
        -:  998:// current code, even on 64-bit targets, is INT_MAX. this is not a
        -:  999:// significant limitation for the intended use case.
        -: 1000://
        -: 1001:// we do, however, need to make sure our size calculations don't
        -: 1002:// overflow. hence a few helper functions for size calculations that
        -: 1003:// multiply integers together, making sure that they're non-negative
        -: 1004:// and no overflow occurs.
        -: 1005:
        -: 1006:// return 1 if the sum is valid, 0 on overflow.
        -: 1007:// negative terms are considered invalid.
function _ZL20stbi__addsizes_validii called 12 returned 100% blocks executed 75%
       12: 1008:static int stbi__addsizes_valid(int a, int b)
        -: 1009:{
      12*: 1010:   if (b < 0) return 0;
       12: 1010-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    %%%%%: 1010-block 3
        -: 1011:   // now 0 <= b <= INT_MAX, hence also
        -: 1012:   // 0 <= INT_MAX - b <= INTMAX.
        -: 1013:   // And "a + b <= INT_MAX" (which might overflow) is the
        -: 1014:   // same as a <= INT_MAX - b (no overflow)
       12: 1015:   return a <= INT_MAX - b;
       12: 1015-block 4
        -: 1016:}
        -: 1017:
        -: 1018:// returns 1 if the product is valid, 0 on overflow.
        -: 1019:// negative factors are considered invalid.
function _ZL21stbi__mul2sizes_validii called 18 returned 100% blocks executed 71%
       18: 1020:static int stbi__mul2sizes_valid(int a, int b)
        -: 1021:{
      18*: 1022:   if (a < 0 || b < 0) return 0;
       18: 1022-block 2
branch  0 taken 18 (fallthrough)
branch  1 taken 0
       18: 1022-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 18
    %%%%%: 1022-block 4
      18*: 1023:   if (b == 0) return 1; // mul-by-0 is always safe
       18: 1023-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    %%%%%: 1023-block 6
        -: 1024:   // portable way to check for no overflows in a*b
       18: 1025:   return a <= INT_MAX/b;
       18: 1025-block 7
        -: 1026:}
        -: 1027:
        -: 1028:#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
        -: 1029:// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
function _ZL21stbi__mad2sizes_validiii called 6 returned 100% blocks executed 88%
        6: 1030:static int stbi__mad2sizes_valid(int a, int b, int add)
        -: 1031:{
       6*: 1032:   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
        6: 1032-block 2
call    0 returned 6
branch  1 taken 6 (fallthrough)
branch  2 taken 0
        6: 1032-block 4
call    3 returned 6
branch  4 taken 6 (fallthrough)
branch  5 taken 0
        6: 1032-block 6
    %%%%%: 1032-block 7
        6: 1032-block 8
        -: 1033:}
        -: 1034:#endif
        -: 1035:
        -: 1036:// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
function _ZL21stbi__mad3sizes_validiiii called 6 returned 100% blocks executed 90%
        6: 1037:static int stbi__mad3sizes_valid(int a, int b, int c, int add)
        -: 1038:{
      12*: 1039:   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
        6: 1039-block 2
call    0 returned 6
branch  1 taken 6 (fallthrough)
branch  2 taken 0
        6: 1039-block 4
call    3 returned 6
branch  4 taken 6 (fallthrough)
branch  5 taken 0
branch  6 taken 6 (fallthrough)
branch  7 taken 0
        6: 1039-block 8
    %%%%%: 1039-block 9
       12: 1040:      stbi__addsizes_valid(a*b*c, add);
        6: 1040-block 6
call    0 returned 6
        6: 1040-block 10
        -: 1041:}
        -: 1042:
        -: 1043:// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
        -: 1044:#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
function _ZL21stbi__mad4sizes_validiiiii called 0 returned 0% blocks executed 0%
    #####: 1045:static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
        -: 1046:{
    #####: 1047:   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
    %%%%%: 1047-block 2
call    0 never executed
    %%%%%: 1047-block 4
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1048:      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1048-block 6
call    2 never executed
    %%%%%: 1048-block 8
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1048-block 10
    %%%%%: 1048-block 11
    %%%%%: 1048-block 12
        -: 1049:}
        -: 1050:#endif
        -: 1051:
        -: 1052:#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
        -: 1053:// mallocs with size overflow checking
function _ZL17stbi__malloc_mad2iii called 3 returned 100% blocks executed 80%
        3: 1054:static void *stbi__malloc_mad2(int a, int b, int add)
        -: 1055:{
       3*: 1056:   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
        3: 1056-block 2
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    %%%%%: 1056-block 4
        3: 1057:   return stbi__malloc(a*b + add);
        3: 1057-block 5
call    0 returned 3
        -: 1058:}
        -: 1059:#endif
        -: 1060:
function _ZL17stbi__malloc_mad3iiii called 3 returned 100% blocks executed 80%
        3: 1061:static void *stbi__malloc_mad3(int a, int b, int c, int add)
        -: 1062:{
       3*: 1063:   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
        3: 1063-block 2
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    %%%%%: 1063-block 4
        3: 1064:   return stbi__malloc(a*b*c + add);
        3: 1064-block 5
call    0 returned 3
        -: 1065:}
        -: 1066:
        -: 1067:#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
function _ZL17stbi__malloc_mad4iiiii called 0 returned 0% blocks executed 0%
    #####: 1068:static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
        -: 1069:{
    #####: 1070:   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
    %%%%%: 1070-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1070-block 4
    #####: 1071:   return stbi__malloc(a*b*c*d + add);
    %%%%%: 1071-block 5
call    0 never executed
        -: 1072:}
        -: 1073:#endif
        -: 1074:
        -: 1075:// returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.
function _ZL19stbi__addints_validii called 0 returned 0% blocks executed 0%
    #####: 1076:static int stbi__addints_valid(int a, int b)
        -: 1077:{
    #####: 1078:   if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
    %%%%%: 1078-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1078-block 3
    #####: 1079:   if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
    %%%%%: 1079-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1079-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1079-block 6
    #####: 1080:   return a <= INT_MAX - b;
    %%%%%: 1080-block 7
        -: 1081:}
        -: 1082:
        -: 1083:// returns 1 if the product of two ints fits in a signed short, 0 on overflow.
function _ZL22stbi__mul2shorts_validii called 0 returned 0% blocks executed 0%
    #####: 1084:static int stbi__mul2shorts_valid(int a, int b)
        -: 1085:{
    #####: 1086:   if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
    %%%%%: 1086-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1086-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1086-block 4
    #####: 1087:   if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
    %%%%%: 1087-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1087-block 6
    #####: 1088:   if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
    %%%%%: 1088-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1088-block 8
    #####: 1089:   return a >= SHRT_MIN / b;
    %%%%%: 1089-block 9
        -: 1090:}
        -: 1091:
        -: 1092:// stbi__err - error
        -: 1093:// stbi__errpf - error returning pointer to float
        -: 1094:// stbi__errpuc - error returning pointer to unsigned char
        -: 1095:
        -: 1096:#ifdef STBI_NO_FAILURE_STRINGS
        -: 1097:   #define stbi__err(x,y)  0
        -: 1098:#elif defined(STBI_FAILURE_USERMSG)
        -: 1099:   #define stbi__err(x,y)  stbi__err(y)
        -: 1100:#else
        -: 1101:   #define stbi__err(x,y)  stbi__err(x)
        -: 1102:#endif
        -: 1103:
        -: 1104:#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
        -: 1105:#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))
        -: 1106:
function stbi_image_free called 3 returned 100% blocks executed 100%
        3: 1107:STBIDEF void stbi_image_free(void *retval_from_stbi_load)
        -: 1108:{
        3: 1109:   STBI_FREE(retval_from_stbi_load);
        3: 1110:}
        -: 1111:
        -: 1112:#ifndef STBI_NO_LINEAR
        -: 1113:static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
        -: 1114:#endif
        -: 1115:
        -: 1116:#ifndef STBI_NO_HDR
        -: 1117:static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
        -: 1118:#endif
        -: 1119:
        -: 1120:static int stbi__vertically_flip_on_load_global = 0;
        -: 1121:
function stbi_set_flip_vertically_on_load called 0 returned 0% blocks executed 0%
    #####: 1122:STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
        -: 1123:{
    #####: 1124:   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
    #####: 1125:}
        -: 1126:
        -: 1127:#ifndef STBI_THREAD_LOCAL
        -: 1128:#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
        -: 1129:#else
        -: 1130:static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;
        -: 1131:
function stbi_set_flip_vertically_on_load_thread called 0 returned 0% blocks executed 0%
    #####: 1132:STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
        -: 1133:{
    #####: 1134:   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
    #####: 1135:   stbi__vertically_flip_on_load_set = 1;
    #####: 1136:}
        -: 1137:
        -: 1138:#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
        -: 1139:                                         ? stbi__vertically_flip_on_load_local  \
        -: 1140:                                         : stbi__vertically_flip_on_load_global)
        -: 1141:#endif // STBI_THREAD_LOCAL
        -: 1142:
function _ZL15stbi__load_mainP13stbi__contextPiS1_S1_iP17stbi__result_infoi called 3 returned 100% blocks executed 12%
        3: 1143:static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
        -: 1144:{
        3: 1145:   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
        3: 1146:   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
        3: 1147:   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
        3: 1148:   ri->num_channels = 0;
        -: 1149:
        -: 1150:   // test the formats with a very explicit header first (at least a FOURCC
        -: 1151:   // or distinctive magic number first)
        -: 1152:   #ifndef STBI_NO_PNG
        3: 1153:   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
        3: 1153-block 2
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0
        3: 1153-block 4
call    3 returned 3
        -: 1154:   #endif
        -: 1155:   #ifndef STBI_NO_BMP
    #####: 1156:   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1156-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1156-block 8
call    3 never executed
        -: 1157:   #endif
        -: 1158:   #ifndef STBI_NO_GIF
    #####: 1159:   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1159-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1159-block 12
call    3 never executed
        -: 1160:   #endif
        -: 1161:   #ifndef STBI_NO_PSD
    #####: 1162:   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
    %%%%%: 1162-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1162-block 16
call    3 never executed
        -: 1163:   #else
        -: 1164:   STBI_NOTUSED(bpc);
        -: 1165:   #endif
        -: 1166:   #ifndef STBI_NO_PIC
    #####: 1167:   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1167-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1167-block 20
call    3 never executed
        -: 1168:   #endif
        -: 1169:
        -: 1170:   // then the formats that can end up attempting to load with just 1 or 2
        -: 1171:   // bytes matching expectations; these are prone to false positives, so
        -: 1172:   // try them later
        -: 1173:   #ifndef STBI_NO_JPEG
    #####: 1174:   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1174-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1174-block 24
call    3 never executed
        -: 1175:   #endif
        -: 1176:   #ifndef STBI_NO_PNM
    #####: 1177:   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1177-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1177-block 28
call    3 never executed
        -: 1178:   #endif
        -: 1179:
        -: 1180:   #ifndef STBI_NO_HDR
    #####: 1181:   if (stbi__hdr_test(s)) {
    %%%%%: 1181-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1182:      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
    %%%%%: 1182-block 32
call    0 never executed
    #####: 1183:      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1183-block 34
    %%%%%: 1183-block 35
    %%%%%: 1183-block 36
call    2 never executed
        -: 1184:   }
        -: 1185:   #endif
        -: 1186:
        -: 1187:   #ifndef STBI_NO_TGA
        -: 1188:   // test tga last because it's a crappy test!
    #####: 1189:   if (stbi__tga_test(s))
    %%%%%: 1189-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1190:      return stbi__tga_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1190-block 39
call    0 never executed
        -: 1191:   #endif
        -: 1192:
    #####: 1193:   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
    %%%%%: 1193-block 41
call    0 never executed
        -: 1194:}
        -: 1195:
function _ZL21stbi__convert_16_to_8Ptiii called 3 returned 100% blocks executed 78%
        3: 1196:static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
        -: 1197:{
        -: 1198:   int i;
        3: 1199:   int img_len = w * h * channels;
        -: 1200:   stbi_uc *reduced;
        -: 1201:
        3: 1202:   reduced = (stbi_uc *) stbi__malloc(img_len);
        3: 1202-block 2
call    0 returned 3
       3*: 1203:   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 1203-block 4
call    2 never executed
        -: 1204:
 12582915: 1205:   for (i = 0; i < img_len; ++i)
        3: 1205-block 6
 12582915: 1205-block 8
branch  0 taken 12582912
branch  1 taken 3 (fallthrough)
 12582912: 1206:      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
 12582912: 1206-block 7
        -: 1207:
        3: 1208:   STBI_FREE(orig);
        3: 1209:   return reduced;
        3: 1209-block 9
        -: 1210:}
        -: 1211:
function _ZL21stbi__convert_8_to_16Phiii called 0 returned 0% blocks executed 0%
    #####: 1212:static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
        -: 1213:{
        -: 1214:   int i;
    #####: 1215:   int img_len = w * h * channels;
        -: 1216:   stbi__uint16 *enlarged;
        -: 1217:
    #####: 1218:   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
    %%%%%: 1218-block 2
call    0 never executed
    #####: 1219:   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1219-block 4
call    2 never executed
        -: 1220:
    #####: 1221:   for (i = 0; i < img_len; ++i)
    %%%%%: 1221-block 6
    %%%%%: 1221-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1222:      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
    %%%%%: 1222-block 7
        -: 1223:
    #####: 1224:   STBI_FREE(orig);
    #####: 1225:   return enlarged;
    %%%%%: 1225-block 9
        -: 1226:}
        -: 1227:
function _ZL19stbi__vertical_flipPviii called 0 returned 0% blocks executed 0%
    #####: 1228:static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
        -: 1229:{
        -: 1230:   int row;
    #####: 1231:   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
        -: 1232:   stbi_uc temp[2048];
    #####: 1233:   stbi_uc *bytes = (stbi_uc *)image;
        -: 1234:
    #####: 1235:   for (row = 0; row < (h>>1); row++) {
    %%%%%: 1235-block 2
    %%%%%: 1235-block 6
    %%%%%: 1235-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1236:      stbi_uc *row0 = bytes + row*bytes_per_row;
    #####: 1237:      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
        -: 1238:      // swap row0 with row1
    #####: 1239:      size_t bytes_left = bytes_per_row;
    #####: 1240:      while (bytes_left) {
    %%%%%: 1240-block 3
    %%%%%: 1240-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1241:         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
    #####: 1242:         memcpy(temp, row0, bytes_copy);
    #####: 1243:         memcpy(row0, row1, bytes_copy);
    #####: 1244:         memcpy(row1, temp, bytes_copy);
    #####: 1245:         row0 += bytes_copy;
    #####: 1246:         row1 += bytes_copy;
    #####: 1247:         bytes_left -= bytes_copy;
    %%%%%: 1247-block 4
        -: 1248:      }
        -: 1249:   }
    #####: 1250:}
        -: 1251:
        -: 1252:#ifndef STBI_NO_GIF
function _ZL26stbi__vertical_flip_slicesPviiii called 0 returned 0% blocks executed 0%
    #####: 1253:static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
        -: 1254:{
        -: 1255:   int slice;
    #####: 1256:   int slice_size = w * h * bytes_per_pixel;
        -: 1257:
    #####: 1258:   stbi_uc *bytes = (stbi_uc *)image;
    #####: 1259:   for (slice = 0; slice < z; ++slice) {
    %%%%%: 1259-block 2
    %%%%%: 1259-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1260:      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
    %%%%%: 1260-block 3
call    0 never executed
    #####: 1261:      bytes += slice_size;
        -: 1262:   }
    #####: 1263:}
        -: 1264:#endif
        -: 1265:
function _ZL31stbi__load_and_postprocess_8bitP13stbi__contextPiS1_S1_i called 3 returned 100% blocks executed 67%
        3: 1266:static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
        -: 1267:{
        -: 1268:   stbi__result_info ri;
        3: 1269:   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
        3: 1269-block 2
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -: 1270:
        3: 1271:   if (result == NULL)
        3: 1271-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 1272:      return NULL;
    %%%%%: 1272-block 4
        -: 1273:
        -: 1274:   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
       3*: 1275:   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
        3: 1275-block 5
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 1275-block 6
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    %%%%%: 1275-block 7
call    4 never executed
        -: 1276:
        3: 1277:   if (ri.bits_per_channel != 8) {
        3: 1277-block 8
branch  0 taken 3 (fallthrough)
branch  1 taken 0
       3*: 1278:      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
        3: 1278-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 1278-block 10
        3: 1278-block 11
        3: 1278-block 12
call    2 returned 3
        3: 1279:      ri.bits_per_channel = 8;
        -: 1280:   }
        -: 1281:
        -: 1282:   // @TODO: move stbi__convert_format to here
        -: 1283:
       3*: 1284:   if (stbi__vertically_flip_on_load) {
        3: 1284-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 1284-block 15
        3: 1284-block 16
        3: 1284-block 17
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    #####: 1285:      int channels = req_comp ? req_comp : *comp;
    %%%%%: 1285-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1285-block 19
    %%%%%: 1285-block 20
    #####: 1286:      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
    %%%%%: 1286-block 21
call    0 never executed
        -: 1287:   }
        -: 1288:
        3: 1289:   return (unsigned char *) result;
        3: 1289-block 22
        -: 1290:}
        -: 1291:
function _ZL32stbi__load_and_postprocess_16bitP13stbi__contextPiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 1292:static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
        -: 1293:{
        -: 1294:   stbi__result_info ri;
    #####: 1295:   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
    %%%%%: 1295-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1296:
    #####: 1297:   if (result == NULL)
    %%%%%: 1297-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1298:      return NULL;
    %%%%%: 1298-block 4
        -: 1299:
        -: 1300:   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
    #####: 1301:   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
    %%%%%: 1301-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1301-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1301-block 7
call    4 never executed
        -: 1302:
    #####: 1303:   if (ri.bits_per_channel != 16) {
    %%%%%: 1303-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1304:      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
    %%%%%: 1304-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1304-block 10
    %%%%%: 1304-block 11
    %%%%%: 1304-block 12
call    2 never executed
    #####: 1305:      ri.bits_per_channel = 16;
        -: 1306:   }
        -: 1307:
        -: 1308:   // @TODO: move stbi__convert_format16 to here
        -: 1309:   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
        -: 1310:
    #####: 1311:   if (stbi__vertically_flip_on_load) {
    %%%%%: 1311-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1311-block 15
    %%%%%: 1311-block 16
    %%%%%: 1311-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1312:      int channels = req_comp ? req_comp : *comp;
    %%%%%: 1312-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1312-block 19
    %%%%%: 1312-block 20
    #####: 1313:      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
    %%%%%: 1313-block 21
call    0 never executed
        -: 1314:   }
        -: 1315:
    #####: 1316:   return (stbi__uint16 *) result;
    %%%%%: 1316-block 22
        -: 1317:}
        -: 1318:
        -: 1319:#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
function _ZL23stbi__float_postprocessPfPiS0_S0_i called 0 returned 0% blocks executed 0%
    #####: 1320:static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
        -: 1321:{
    #####: 1322:   if (stbi__vertically_flip_on_load && result != NULL) {
    %%%%%: 1322-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1322-block 3
    %%%%%: 1322-block 4
    %%%%%: 1322-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1322-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1323:      int channels = req_comp ? req_comp : *comp;
    %%%%%: 1323-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1323-block 8
    %%%%%: 1323-block 9
    #####: 1324:      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
    %%%%%: 1324-block 10
call    0 never executed
        -: 1325:   }
    #####: 1326:}
        -: 1327:#endif
        -: 1328:
        -: 1329:#ifndef STBI_NO_STDIO
        -: 1330:
        -: 1331:#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
        -: 1332:STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
        -: 1333:STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
        -: 1334:#endif
        -: 1335:
        -: 1336:#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
        -: 1337:STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
        -: 1338:{
        -: 1339:	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
        -: 1340:}
        -: 1341:#endif
        -: 1342:
function _ZL11stbi__fopenPKcS0_ called 3 returned 100% blocks executed 100%
        3: 1343:static FILE *stbi__fopen(char const *filename, char const *mode)
        -: 1344:{
        -: 1345:   FILE *f;
        -: 1346:#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
        -: 1347:   wchar_t wMode[64];
        -: 1348:   wchar_t wFilename[1024];
        -: 1349:	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
        -: 1350:      return 0;
        -: 1351:
        -: 1352:	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
        -: 1353:      return 0;
        -: 1354:
        -: 1355:#if defined(_MSC_VER) && _MSC_VER >= 1400
        -: 1356:	if (0 != _wfopen_s(&f, wFilename, wMode))
        -: 1357:		f = 0;
        -: 1358:#else
        -: 1359:   f = _wfopen(wFilename, wMode);
        -: 1360:#endif
        -: 1361:
        -: 1362:#elif defined(_MSC_VER) && _MSC_VER >= 1400
        -: 1363:   if (0 != fopen_s(&f, filename, mode))
        -: 1364:      f=0;
        -: 1365:#else
        3: 1366:   f = fopen(filename, mode);
        3: 1366-block 2
call    0 returned 3
        -: 1367:#endif
        3: 1368:   return f;
        -: 1369:}
        -: 1370:
        -: 1371:
function stbi_load called 3 returned 100% blocks executed 75%
        3: 1372:STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
        -: 1373:{
        3: 1374:   FILE *f = stbi__fopen(filename, "rb");
        3: 1374-block 2
call    0 returned 3
        -: 1375:   unsigned char *result;
       3*: 1376:   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 1376-block 4
call    2 never executed
        3: 1377:   result = stbi_load_from_file(f,x,y,comp,req_comp);
        3: 1377-block 6
call    0 returned 3
        3: 1378:   fclose(f);
call    0 returned 3
        3: 1379:   return result;
        -: 1380:}
        -: 1381:
function stbi_load_from_file called 3 returned 100% blocks executed 100%
        3: 1382:STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
        -: 1383:{
        -: 1384:   unsigned char *result;
        -: 1385:   stbi__context s;
        3: 1386:   stbi__start_file(&s,f);
        3: 1386-block 2
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 1387:   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
        3: 1387-block 3
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 1388:   if (result) {
        3: 1388-block 4
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 1389:      // need to 'unget' all the characters in the IO buffer
        3: 1390:      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
        3: 1390-block 5
call    0 returned 3
        -: 1391:   }
        3: 1392:   return result;
        3: 1392-block 6
        3: 1392-block 7
        -: 1393:}
        -: 1394:
function stbi_load_from_file_16 called 0 returned 0% blocks executed 0%
    #####: 1395:STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
        -: 1396:{
        -: 1397:   stbi__uint16 *result;
        -: 1398:   stbi__context s;
    #####: 1399:   stbi__start_file(&s,f);
    %%%%%: 1399-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1400:   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
    %%%%%: 1400-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1401:   if (result) {
    %%%%%: 1401-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1402:      // need to 'unget' all the characters in the IO buffer
    #####: 1403:      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
    %%%%%: 1403-block 5
call    0 never executed
        -: 1404:   }
    #####: 1405:   return result;
    %%%%%: 1405-block 6
    %%%%%: 1405-block 7
        -: 1406:}
        -: 1407:
function stbi_load_16 called 0 returned 0% blocks executed 0%
    #####: 1408:STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
        -: 1409:{
    #####: 1410:   FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 1410-block 2
call    0 never executed
        -: 1411:   stbi__uint16 *result;
    #####: 1412:   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1412-block 4
call    2 never executed
    #####: 1413:   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
    %%%%%: 1413-block 6
call    0 never executed
    #####: 1414:   fclose(f);
call    0 never executed
    #####: 1415:   return result;
        -: 1416:}
        -: 1417:
        -: 1418:
        -: 1419:#endif //!STBI_NO_STDIO
        -: 1420:
function stbi_load_16_from_memory called 0 returned 0% blocks executed 0%
    #####: 1421:STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
        -: 1422:{
        -: 1423:   stbi__context s;
    #####: 1424:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1424-block 2
call    0 never executed
    #####: 1425:   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1425-block 4
    %%%%%: 1425-block 6
        -: 1426:}
        -: 1427:
function stbi_load_16_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1428:STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
        -: 1429:{
        -: 1430:   stbi__context s;
    #####: 1431:   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
    %%%%%: 1431-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1432:   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
    %%%%%: 1432-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1432-block 4
    %%%%%: 1432-block 6
        -: 1433:}
        -: 1434:
function stbi_load_from_memory called 0 returned 0% blocks executed 0%
    #####: 1435:STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
        -: 1436:{
        -: 1437:   stbi__context s;
    #####: 1438:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1438-block 2
call    0 never executed
    #####: 1439:   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1439-block 4
    %%%%%: 1439-block 6
        -: 1440:}
        -: 1441:
function stbi_load_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1442:STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
        -: 1443:{
        -: 1444:   stbi__context s;
    #####: 1445:   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
    %%%%%: 1445-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1446:   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
    %%%%%: 1446-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1446-block 4
    %%%%%: 1446-block 6
        -: 1447:}
        -: 1448:
        -: 1449:#ifndef STBI_NO_GIF
function stbi_load_gif_from_memory called 0 returned 0% blocks executed 0%
    #####: 1450:STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
        -: 1451:{
        -: 1452:   unsigned char *result;
        -: 1453:   stbi__context s;
    #####: 1454:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1454-block 2
call    0 never executed
        -: 1455:
    #####: 1456:   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1457:   if (stbi__vertically_flip_on_load) {
    %%%%%: 1457-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1457-block 5
    %%%%%: 1457-block 6
    %%%%%: 1457-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1458:      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
    %%%%%: 1458-block 8
call    0 never executed
        -: 1459:   }
        -: 1460:
    #####: 1461:   return result;
    %%%%%: 1461-block 9
    %%%%%: 1461-block 10
        -: 1462:}
        -: 1463:#endif
        -: 1464:
        -: 1465:#ifndef STBI_NO_LINEAR
function _ZL16stbi__loadf_mainP13stbi__contextPiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 1466:static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
        -: 1467:{
        -: 1468:   unsigned char *data;
        -: 1469:   #ifndef STBI_NO_HDR
    #####: 1470:   if (stbi__hdr_test(s)) {
    %%%%%: 1470-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 1471:      stbi__result_info ri;
    #####: 1472:      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
    %%%%%: 1472-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1473:      if (hdr_data)
    %%%%%: 1473-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1474:         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
    %%%%%: 1474-block 6
call    0 never executed
    #####: 1475:      return hdr_data;
    %%%%%: 1475-block 7
        -: 1476:   }
        -: 1477:   #endif
    #####: 1478:   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
    %%%%%: 1478-block 8
call    0 never executed
    #####: 1479:   if (data)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1480:      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
    %%%%%: 1480-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1480-block 11
    %%%%%: 1480-block 12
    %%%%%: 1480-block 13
call    2 never executed
    #####: 1481:   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
    %%%%%: 1481-block 14
call    0 never executed
        -: 1482:}
        -: 1483:
function stbi_loadf_from_memory called 0 returned 0% blocks executed 0%
    #####: 1484:STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
        -: 1485:{
        -: 1486:   stbi__context s;
    #####: 1487:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1487-block 2
call    0 never executed
    #####: 1488:   return stbi__loadf_main(&s,x,y,comp,req_comp);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1488-block 4
    %%%%%: 1488-block 6
        -: 1489:}
        -: 1490:
function stbi_loadf_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1491:STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
        -: 1492:{
        -: 1493:   stbi__context s;
    #####: 1494:   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
    %%%%%: 1494-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1495:   return stbi__loadf_main(&s,x,y,comp,req_comp);
    %%%%%: 1495-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1495-block 4
    %%%%%: 1495-block 6
        -: 1496:}
        -: 1497:
        -: 1498:#ifndef STBI_NO_STDIO
function stbi_loadf called 0 returned 0% blocks executed 0%
    #####: 1499:STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
        -: 1500:{
        -: 1501:   float *result;
    #####: 1502:   FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 1502-block 2
call    0 never executed
    #####: 1503:   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1503-block 4
call    2 never executed
    #####: 1504:   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
    %%%%%: 1504-block 6
call    0 never executed
    #####: 1505:   fclose(f);
call    0 never executed
    #####: 1506:   return result;
        -: 1507:}
        -: 1508:
function stbi_loadf_from_file called 0 returned 0% blocks executed 0%
    #####: 1509:STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
        -: 1510:{
        -: 1511:   stbi__context s;
    #####: 1512:   stbi__start_file(&s,f);
    %%%%%: 1512-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1513:   return stbi__loadf_main(&s,x,y,comp,req_comp);
    %%%%%: 1513-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1513-block 4
    %%%%%: 1513-block 6
        -: 1514:}
        -: 1515:#endif // !STBI_NO_STDIO
        -: 1516:
        -: 1517:#endif // !STBI_NO_LINEAR
        -: 1518:
        -: 1519:// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
        -: 1520:// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
        -: 1521:// reports false!
        -: 1522:
function stbi_is_hdr_from_memory called 0 returned 0% blocks executed 0%
    #####: 1523:STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
        -: 1524:{
        -: 1525:   #ifndef STBI_NO_HDR
        -: 1526:   stbi__context s;
    #####: 1527:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1527-block 2
call    0 never executed
    #####: 1528:   return stbi__hdr_test(&s);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1528-block 4
    %%%%%: 1528-block 6
        -: 1529:   #else
        -: 1530:   STBI_NOTUSED(buffer);
        -: 1531:   STBI_NOTUSED(len);
        -: 1532:   return 0;
        -: 1533:   #endif
        -: 1534:}
        -: 1535:
        -: 1536:#ifndef STBI_NO_STDIO
function stbi_is_hdr called 0 returned 0% blocks executed 0%
    #####: 1537:STBIDEF int      stbi_is_hdr          (char const *filename)
        -: 1538:{
    #####: 1539:   FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 1539-block 2
call    0 never executed
    #####: 1540:   int result=0;
    #####: 1541:   if (f) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1542:      result = stbi_is_hdr_from_file(f);
    %%%%%: 1542-block 4
call    0 never executed
    #####: 1543:      fclose(f);
call    0 never executed
        -: 1544:   }
    #####: 1545:   return result;
    %%%%%: 1545-block 6
        -: 1546:}
        -: 1547:
function stbi_is_hdr_from_file called 0 returned 0% blocks executed 0%
    #####: 1548:STBIDEF int stbi_is_hdr_from_file(FILE *f)
        -: 1549:{
        -: 1550:   #ifndef STBI_NO_HDR
    #####: 1551:   long pos = ftell(f);
    %%%%%: 1551-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1552:   int res;
        -: 1553:   stbi__context s;
    #####: 1554:   stbi__start_file(&s,f);
    %%%%%: 1554-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1555:   res = stbi__hdr_test(&s);
    %%%%%: 1555-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1556:   fseek(f, pos, SEEK_SET);
    %%%%%: 1556-block 5
call    0 never executed
    #####: 1557:   return res;
    %%%%%: 1557-block 7
        -: 1558:   #else
        -: 1559:   STBI_NOTUSED(f);
        -: 1560:   return 0;
        -: 1561:   #endif
        -: 1562:}
        -: 1563:#endif // !STBI_NO_STDIO
        -: 1564:
function stbi_is_hdr_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1565:STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
        -: 1566:{
        -: 1567:   #ifndef STBI_NO_HDR
        -: 1568:   stbi__context s;
    #####: 1569:   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
    %%%%%: 1569-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1570:   return stbi__hdr_test(&s);
    %%%%%: 1570-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1570-block 4
    %%%%%: 1570-block 6
        -: 1571:   #else
        -: 1572:   STBI_NOTUSED(clbk);
        -: 1573:   STBI_NOTUSED(user);
        -: 1574:   return 0;
        -: 1575:   #endif
        -: 1576:}
        -: 1577:
        -: 1578:#ifndef STBI_NO_LINEAR
        -: 1579:static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;
        -: 1580:
function stbi_ldr_to_hdr_gamma called 0 returned 0% blocks executed 0%
    #####: 1581:STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
function stbi_ldr_to_hdr_scale called 0 returned 0% blocks executed 0%
    #####: 1582:STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
        -: 1583:#endif
        -: 1584:
        -: 1585:static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
        -: 1586:
function stbi_hdr_to_ldr_gamma called 0 returned 0% blocks executed 0%
    #####: 1587:STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
function stbi_hdr_to_ldr_scale called 0 returned 0% blocks executed 0%
    #####: 1588:STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
        -: 1589:
        -: 1590:
        -: 1591://////////////////////////////////////////////////////////////////////////////
        -: 1592://
        -: 1593:// Common code used by all image loaders
        -: 1594://
        -: 1595:
        -: 1596:enum
        -: 1597:{
        -: 1598:   STBI__SCAN_load=0,
        -: 1599:   STBI__SCAN_type,
        -: 1600:   STBI__SCAN_header
        -: 1601:};
        -: 1602:
function _ZL19stbi__refill_bufferP13stbi__context called 1794 returned 100% blocks executed 80%
     1794: 1603:static void stbi__refill_buffer(stbi__context *s)
        -: 1604:{
     1794: 1605:   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
     1794: 1605-block 2
call    0 returned 1794
     1794: 1606:   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
     1794: 1607:   if (n == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1794
        -: 1608:      // at end of file, treat same as if from memory, but need to handle case
        -: 1609:      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
    #####: 1610:      s->read_from_callbacks = 0;
    #####: 1611:      s->img_buffer = s->buffer_start;
    #####: 1612:      s->img_buffer_end = s->buffer_start+1;
    #####: 1613:      *s->img_buffer = 0;
    %%%%%: 1613-block 4
        -: 1614:   } else {
     1794: 1615:      s->img_buffer = s->buffer_start;
     1794: 1616:      s->img_buffer_end = s->buffer_start + n;
     1794: 1616-block 5
        -: 1617:   }
     1794: 1618:}
        -: 1619:
function _ZL10stbi__get8P13stbi__context called 21975 returned 100% blocks executed 86%
    21975: 1620:stbi_inline static stbi_uc stbi__get8(stbi__context *s)
        -: 1621:{
    21975: 1622:   if (s->img_buffer < s->img_buffer_end)
    21975: 1622-block 2
branch  0 taken 20184 (fallthrough)
branch  1 taken 1791
    20184: 1623:      return *s->img_buffer++;
    20184: 1623-block 3
     1791: 1624:   if (s->read_from_callbacks) {
     1791: 1624-block 4
branch  0 taken 1791 (fallthrough)
branch  1 taken 0
     1791: 1625:      stbi__refill_buffer(s);
     1791: 1625-block 5
call    0 returned 1791
     1791: 1626:      return *s->img_buffer++;
        -: 1627:   }
    #####: 1628:   return 0;
    %%%%%: 1628-block 7
        -: 1629:}
        -: 1630:
        -: 1631:#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
        -: 1632:// nothing
        -: 1633:#else
function _ZL12stbi__at_eofP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 1634:stbi_inline static int stbi__at_eof(stbi__context *s)
        -: 1635:{
    #####: 1636:   if (s->io.read) {
    %%%%%: 1636-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1637:      if (!(s->io.eof)(s->io_user_data)) return 0;
    %%%%%: 1637-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1637-block 5
        -: 1638:      // if feof() is true, check if buffer = end
        -: 1639:      // special case: we've only got the special 0 character at the end
    #####: 1640:      if (s->read_from_callbacks == 0) return 1;
    %%%%%: 1640-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1640-block 7
        -: 1641:   }
        -: 1642:
    #####: 1643:   return s->img_buffer >= s->img_buffer_end;
    %%%%%: 1643-block 8
        -: 1644:}
        -: 1645:#endif
        -: 1646:
        -: 1647:#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
        -: 1648:// nothing
        -: 1649:#else
function _ZL10stbi__skipP13stbi__contexti called 38 returned 100% blocks executed 80%
       38: 1650:static void stbi__skip(stbi__context *s, int n)
        -: 1651:{
      38*: 1652:   if (n == 0) return;  // already there!
       38: 1652-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 38
    %%%%%: 1652-block 3
       38: 1653:   if (n < 0) {
       38: 1653-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 38
    #####: 1654:      s->img_buffer = s->img_buffer_end;
    #####: 1655:      return;
    %%%%%: 1655-block 5
        -: 1656:   }
       38: 1657:   if (s->io.read) {
       38: 1657-block 6
branch  0 taken 38 (fallthrough)
branch  1 taken 0
       38: 1658:      int blen = (int) (s->img_buffer_end - s->img_buffer);
       38: 1659:      if (blen < n) {
       38: 1659-block 7
branch  0 taken 7 (fallthrough)
branch  1 taken 31
        7: 1660:         s->img_buffer = s->img_buffer_end;
        7: 1661:         (s->io.skip)(s->io_user_data, n - blen);
        7: 1661-block 8
call    0 returned 7
        7: 1662:         return;
        -: 1663:      }
        -: 1664:   }
       31: 1665:   s->img_buffer += n;
       31: 1665-block 10
        -: 1666:}
        -: 1667:#endif
        -: 1668:
        -: 1669:#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
        -: 1670:// nothing
        -: 1671:#else
function _ZL10stbi__getnP13stbi__contextPhi called 1780 returned 100% blocks executed 62%
     1780: 1672:static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
        -: 1673:{
     1780: 1674:   if (s->io.read) {
     1780: 1674-block 2
branch  0 taken 1780 (fallthrough)
branch  1 taken 0
     1780: 1675:      int blen = (int) (s->img_buffer_end - s->img_buffer);
     1780: 1676:      if (blen < n) {
     1780: 1676-block 3
branch  0 taken 1780 (fallthrough)
branch  1 taken 0
        -: 1677:         int res, count;
        -: 1678:
     1780: 1679:         memcpy(buffer, s->img_buffer, blen);
        -: 1680:
     1780: 1681:         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
     1780: 1681-block 4
call    0 returned 1780
     1780: 1682:         res = (count == (n-blen));
     1780: 1683:         s->img_buffer = s->img_buffer_end;
     1780: 1684:         return res;
        -: 1685:      }
        -: 1686:   }
        -: 1687:
    #####: 1688:   if (s->img_buffer+n <= s->img_buffer_end) {
    %%%%%: 1688-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1689:      memcpy(buffer, s->img_buffer, n);
    #####: 1690:      s->img_buffer += n;
    #####: 1691:      return 1;
    %%%%%: 1691-block 7
        -: 1692:   } else
    #####: 1693:      return 0;
    %%%%%: 1693-block 8
        -: 1694:}
        -: 1695:#endif
        -: 1696:
        -: 1697:#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
        -: 1698:// nothing
        -: 1699:#else
function _ZL13stbi__get16beP13stbi__context called 10956 returned 100% blocks executed 100%
    10956: 1700:static int stbi__get16be(stbi__context *s)
        -: 1701:{
    10956: 1702:   int z = stbi__get8(s);
    10956: 1702-block 2
call    0 returned 10956
    10956: 1703:   return (z << 8) + stbi__get8(s);
call    0 returned 10956
        -: 1704:}
        -: 1705:#endif
        -: 1706:
        -: 1707:#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
        -: 1708:// nothing
        -: 1709:#else
function _ZL13stbi__get32beP13stbi__context called 5478 returned 100% blocks executed 100%
     5478: 1710:static stbi__uint32 stbi__get32be(stbi__context *s)
        -: 1711:{
     5478: 1712:   stbi__uint32 z = stbi__get16be(s);
     5478: 1712-block 2
call    0 returned 5478
     5478: 1713:   return (z << 16) + stbi__get16be(s);
call    0 returned 5478
        -: 1714:}
        -: 1715:#endif
        -: 1716:
        -: 1717:#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
        -: 1718:// nothing
        -: 1719:#else
function _ZL13stbi__get16leP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 1720:static int stbi__get16le(stbi__context *s)
        -: 1721:{
    #####: 1722:   int z = stbi__get8(s);
    %%%%%: 1722-block 2
call    0 never executed
    #####: 1723:   return z + (stbi__get8(s) << 8);
call    0 never executed
        -: 1724:}
        -: 1725:#endif
        -: 1726:
        -: 1727:#ifndef STBI_NO_BMP
function _ZL13stbi__get32leP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 1728:static stbi__uint32 stbi__get32le(stbi__context *s)
        -: 1729:{
    #####: 1730:   stbi__uint32 z = stbi__get16le(s);
    %%%%%: 1730-block 2
call    0 never executed
    #####: 1731:   z += (stbi__uint32)stbi__get16le(s) << 16;
call    0 never executed
    #####: 1732:   return z;
        -: 1733:}
        -: 1734:#endif
        -: 1735:
        -: 1736:#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
        -: 1737:
        -: 1738:#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
        -: 1739:// nothing
        -: 1740:#else
        -: 1741://////////////////////////////////////////////////////////////////////////////
        -: 1742://
        -: 1743://  generic converter from built-in img_n to req_comp
        -: 1744://    individual types do this automatically as much as possible (e.g. jpeg
        -: 1745://    does all cases internally since it needs to colorspace convert anyway,
        -: 1746://    and it never has alpha, so very few cases ). png can automatically
        -: 1747://    interleave an alpha=255 channel, but falls back to this for other cases
        -: 1748://
        -: 1749://  assume data buffer is malloced, so malloc a new one and free that one
        -: 1750://  only failure mode is malloc failing
        -: 1751:
function _ZL15stbi__compute_yiii called 0 returned 0% blocks executed 0%
    #####: 1752:static stbi_uc stbi__compute_y(int r, int g, int b)
        -: 1753:{
    #####: 1754:   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
    %%%%%: 1754-block 2
        -: 1755:}
        -: 1756:#endif
        -: 1757:
        -: 1758:#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
        -: 1759:// nothing
        -: 1760:#else
function _ZL20stbi__convert_formatPhiijj called 0 returned 0% blocks executed 0%
    #####: 1761:static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
        -: 1762:{
        -: 1763:   int i,j;
        -: 1764:   unsigned char *good;
        -: 1765:
    #####: 1766:   if (req_comp == img_n) return data;
    %%%%%: 1766-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1766-block 3
    #####: 1767:   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
    %%%%%: 1767-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1767-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1767-block 6
    %%%%%: 1767-block 7
call    4 never executed
        -: 1768:
    #####: 1769:   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
    %%%%%: 1769-block 8
call    0 never executed
    #####: 1770:   if (good == NULL) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1771:      STBI_FREE(data);
    #####: 1772:      return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 1772-block 10
call    0 never executed
        -: 1773:   }
        -: 1774:
    #####: 1775:   for (j=0; j < (int) y; ++j) {
    %%%%%: 1775-block 12
    %%%%%: 1775-block 67
    %%%%%: 1775-block 68
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1776:      unsigned char *src  = data + j * x * img_n   ;
    #####: 1777:      unsigned char *dest = good + j * x * req_comp;
        -: 1778:
        -: 1779:      #define STBI__COMBO(a,b)  ((a)*8+(b))
        -: 1780:      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
        -: 1781:      // convert source image with img_n components to one with req_comp components;
        -: 1782:      // avoid switch per pixel, so use switch per scanline and massive macros
    #####: 1783:      switch (STBI__COMBO(img_n, req_comp)) {
    %%%%%: 1783-block 13
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 1784:         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
    %%%%%: 1784-block 14
    %%%%%: 1784-block 15
    %%%%%: 1784-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1784-block 17
    #####: 1785:         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
    %%%%%: 1785-block 18
    %%%%%: 1785-block 19
    %%%%%: 1785-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1785-block 21
    #####: 1786:         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
    %%%%%: 1786-block 22
    %%%%%: 1786-block 23
    %%%%%: 1786-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1786-block 25
    #####: 1787:         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
    %%%%%: 1787-block 26
    %%%%%: 1787-block 27
    %%%%%: 1787-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1787-block 29
    #####: 1788:         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
    %%%%%: 1788-block 30
    %%%%%: 1788-block 31
    %%%%%: 1788-block 32
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1788-block 33
    #####: 1789:         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
    %%%%%: 1789-block 34
    %%%%%: 1789-block 35
    %%%%%: 1789-block 36
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1789-block 37
    #####: 1790:         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
    %%%%%: 1790-block 38
    %%%%%: 1790-block 39
    %%%%%: 1790-block 40
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1790-block 41
    #####: 1791:         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
    %%%%%: 1791-block 42
    %%%%%: 1791-block 43
call    0 never executed
    %%%%%: 1791-block 45
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1791-block 46
    #####: 1792:         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
    %%%%%: 1792-block 47
    %%%%%: 1792-block 48
call    0 never executed
    %%%%%: 1792-block 50
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1792-block 51
    #####: 1793:         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
    %%%%%: 1793-block 52
    %%%%%: 1793-block 53
call    0 never executed
    %%%%%: 1793-block 55
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1793-block 56
    #####: 1794:         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
    %%%%%: 1794-block 57
    %%%%%: 1794-block 58
call    0 never executed
    %%%%%: 1794-block 60
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1794-block 61
    #####: 1795:         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
    %%%%%: 1795-block 62
    %%%%%: 1795-block 63
    %%%%%: 1795-block 64
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1795-block 65
    #####: 1796:         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
    %%%%%: 1796-block 66
call    0 never executed
        -: 1797:      }
        -: 1798:      #undef STBI__CASE
        -: 1799:   }
        -: 1800:
    #####: 1801:   STBI_FREE(data);
    #####: 1802:   return good;
    %%%%%: 1802-block 69
        -: 1803:}
        -: 1804:#endif
        -: 1805:
        -: 1806:#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
        -: 1807:// nothing
        -: 1808:#else
function _ZL18stbi__compute_y_16iii called 0 returned 0% blocks executed 0%
    #####: 1809:static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
        -: 1810:{
    #####: 1811:   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
    %%%%%: 1811-block 2
        -: 1812:}
        -: 1813:#endif
        -: 1814:
        -: 1815:#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
        -: 1816:// nothing
        -: 1817:#else
function _ZL22stbi__convert_format16Ptiijj called 0 returned 0% blocks executed 0%
    #####: 1818:static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
        -: 1819:{
        -: 1820:   int i,j;
        -: 1821:   stbi__uint16 *good;
        -: 1822:
    #####: 1823:   if (req_comp == img_n) return data;
    %%%%%: 1823-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1823-block 3
    #####: 1824:   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
    %%%%%: 1824-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1824-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1824-block 6
    %%%%%: 1824-block 7
call    4 never executed
        -: 1825:
    #####: 1826:   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
    %%%%%: 1826-block 8
call    0 never executed
    #####: 1827:   if (good == NULL) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1828:      STBI_FREE(data);
    #####: 1829:      return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 1829-block 10
call    0 never executed
        -: 1830:   }
        -: 1831:
    #####: 1832:   for (j=0; j < (int) y; ++j) {
    %%%%%: 1832-block 12
    %%%%%: 1832-block 67
    %%%%%: 1832-block 68
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1833:      stbi__uint16 *src  = data + j * x * img_n   ;
    #####: 1834:      stbi__uint16 *dest = good + j * x * req_comp;
        -: 1835:
        -: 1836:      #define STBI__COMBO(a,b)  ((a)*8+(b))
        -: 1837:      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
        -: 1838:      // convert source image with img_n components to one with req_comp components;
        -: 1839:      // avoid switch per pixel, so use switch per scanline and massive macros
    #####: 1840:      switch (STBI__COMBO(img_n, req_comp)) {
    %%%%%: 1840-block 13
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 1841:         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
    %%%%%: 1841-block 14
    %%%%%: 1841-block 15
    %%%%%: 1841-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1841-block 17
    #####: 1842:         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
    %%%%%: 1842-block 18
    %%%%%: 1842-block 19
    %%%%%: 1842-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1842-block 21
    #####: 1843:         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
    %%%%%: 1843-block 22
    %%%%%: 1843-block 23
    %%%%%: 1843-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1843-block 25
    #####: 1844:         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
    %%%%%: 1844-block 26
    %%%%%: 1844-block 27
    %%%%%: 1844-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1844-block 29
    #####: 1845:         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
    %%%%%: 1845-block 30
    %%%%%: 1845-block 31
    %%%%%: 1845-block 32
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1845-block 33
    #####: 1846:         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
    %%%%%: 1846-block 34
    %%%%%: 1846-block 35
    %%%%%: 1846-block 36
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1846-block 37
    #####: 1847:         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
    %%%%%: 1847-block 38
    %%%%%: 1847-block 39
    %%%%%: 1847-block 40
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1847-block 41
    #####: 1848:         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
    %%%%%: 1848-block 42
    %%%%%: 1848-block 43
call    0 never executed
    %%%%%: 1848-block 45
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1848-block 46
    #####: 1849:         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
    %%%%%: 1849-block 47
    %%%%%: 1849-block 48
call    0 never executed
    %%%%%: 1849-block 50
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1849-block 51
    #####: 1850:         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
    %%%%%: 1850-block 52
    %%%%%: 1850-block 53
call    0 never executed
    %%%%%: 1850-block 55
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1850-block 56
    #####: 1851:         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
    %%%%%: 1851-block 57
    %%%%%: 1851-block 58
call    0 never executed
    %%%%%: 1851-block 60
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1851-block 61
    #####: 1852:         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
    %%%%%: 1852-block 62
    %%%%%: 1852-block 63
    %%%%%: 1852-block 64
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1852-block 65
    #####: 1853:         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
    %%%%%: 1853-block 66
call    0 never executed
        -: 1854:      }
        -: 1855:      #undef STBI__CASE
        -: 1856:   }
        -: 1857:
    #####: 1858:   STBI_FREE(data);
    #####: 1859:   return good;
    %%%%%: 1859-block 69
        -: 1860:}
        -: 1861:#endif
        -: 1862:
        -: 1863:#ifndef STBI_NO_LINEAR
function _ZL16stbi__ldr_to_hdrPhiii called 0 returned 0% blocks executed 0%
    #####: 1864:static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
        -: 1865:{
        -: 1866:   int i,k,n;
        -: 1867:   float *output;
    #####: 1868:   if (!data) return NULL;
    %%%%%: 1868-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1868-block 3
    #####: 1869:   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
    %%%%%: 1869-block 4
call    0 never executed
    #####: 1870:   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1870-block 6
call    2 never executed
        -: 1871:   // compute number of non-alpha components
    #####: 1872:   if (comp & 1) n = comp; else n = comp-1;
    %%%%%: 1872-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1872-block 9
    %%%%%: 1872-block 10
    #####: 1873:   for (i=0; i < x*y; ++i) {
    %%%%%: 1873-block 11
    %%%%%: 1873-block 16
    %%%%%: 1873-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1874:      for (k=0; k < n; ++k) {
    %%%%%: 1874-block 12
    %%%%%: 1874-block 15
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1875:         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
    %%%%%: 1875-block 13
call    0 never executed
        -: 1876:      }
        -: 1877:   }
    #####: 1878:   if (n < comp) {
    %%%%%: 1878-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1879:      for (i=0; i < x*y; ++i) {
    %%%%%: 1879-block 19
    %%%%%: 1879-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1880:         output[i*comp + n] = data[i*comp + n]/255.0f;
    %%%%%: 1880-block 20
        -: 1881:      }
        -: 1882:   }
    #####: 1883:   STBI_FREE(data);
    #####: 1884:   return output;
    %%%%%: 1884-block 22
        -: 1885:}
        -: 1886:#endif
        -: 1887:
        -: 1888:#ifndef STBI_NO_HDR
        -: 1889:#define stbi__float2int(x)   ((int) (x))
function _ZL16stbi__hdr_to_ldrPfiii called 0 returned 0% blocks executed 0%
    #####: 1890:static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
        -: 1891:{
        -: 1892:   int i,k,n;
        -: 1893:   stbi_uc *output;
    #####: 1894:   if (!data) return NULL;
    %%%%%: 1894-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1894-block 3
    #####: 1895:   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
    %%%%%: 1895-block 4
call    0 never executed
    #####: 1896:   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1896-block 6
call    2 never executed
        -: 1897:   // compute number of non-alpha components
    #####: 1898:   if (comp & 1) n = comp; else n = comp-1;
    %%%%%: 1898-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1898-block 9
    %%%%%: 1898-block 10
    #####: 1899:   for (i=0; i < x*y; ++i) {
    %%%%%: 1899-block 11
    %%%%%: 1899-block 26
    %%%%%: 1899-block 27
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1900:      for (k=0; k < n; ++k) {
    %%%%%: 1900-block 12
    %%%%%: 1900-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1901:         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
    %%%%%: 1901-block 13
call    0 never executed
    #####: 1902:         if (z < 0) z = 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1902-block 15
    #####: 1903:         if (z > 255) z = 255;
    %%%%%: 1903-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1903-block 17
    #####: 1904:         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
    %%%%%: 1904-block 18
        -: 1905:      }
    #####: 1906:      if (k < comp) {
    %%%%%: 1906-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1907:         float z = data[i*comp+k] * 255 + 0.5f;
    #####: 1908:         if (z < 0) z = 0;
    %%%%%: 1908-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1908-block 22
    #####: 1909:         if (z > 255) z = 255;
    %%%%%: 1909-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1909-block 24
    #####: 1910:         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
    %%%%%: 1910-block 25
        -: 1911:      }
        -: 1912:   }
    #####: 1913:   STBI_FREE(data);
    #####: 1914:   return output;
    %%%%%: 1914-block 28
        -: 1915:}
        -: 1916:#endif
        -: 1917:
        -: 1918://////////////////////////////////////////////////////////////////////////////
        -: 1919://
        -: 1920://  "baseline" JPEG/JFIF decoder
        -: 1921://
        -: 1922://    simple implementation
        -: 1923://      - doesn't support delayed output of y-dimension
        -: 1924://      - simple interface (only one output format: 8-bit interleaved RGB)
        -: 1925://      - doesn't try to recover corrupt jpegs
        -: 1926://      - doesn't allow partial loading, loading multiple at once
        -: 1927://      - still fast on x86 (copying globals into locals doesn't help x86)
        -: 1928://      - allocates lots of intermediate memory (full size of all components)
        -: 1929://        - non-interleaved case requires this anyway
        -: 1930://        - allows good upsampling (see next)
        -: 1931://    high-quality
        -: 1932://      - upsampled channels are bilinearly interpolated, even across blocks
        -: 1933://      - quality integer IDCT derived from IJG's 'slow'
        -: 1934://    performance
        -: 1935://      - fast huffman; reasonable integer IDCT
        -: 1936://      - some SIMD kernels for common paths on targets with SSE2/NEON
        -: 1937://      - uses a lot of intermediate memory, could cache poorly
        -: 1938:
        -: 1939:#ifndef STBI_NO_JPEG
        -: 1940:
        -: 1941:// huffman decoding acceleration
        -: 1942:#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
        -: 1943:
        -: 1944:typedef struct
        -: 1945:{
        -: 1946:   stbi_uc  fast[1 << FAST_BITS];
        -: 1947:   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
        -: 1948:   stbi__uint16 code[256];
        -: 1949:   stbi_uc  values[256];
        -: 1950:   stbi_uc  size[257];
        -: 1951:   unsigned int maxcode[18];
        -: 1952:   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
        -: 1953:} stbi__huffman;
        -: 1954:
        -: 1955:typedef struct
        -: 1956:{
        -: 1957:   stbi__context *s;
        -: 1958:   stbi__huffman huff_dc[4];
        -: 1959:   stbi__huffman huff_ac[4];
        -: 1960:   stbi__uint16 dequant[4][64];
        -: 1961:   stbi__int16 fast_ac[4][1 << FAST_BITS];
        -: 1962:
        -: 1963:// sizes for components, interleaved MCUs
        -: 1964:   int img_h_max, img_v_max;
        -: 1965:   int img_mcu_x, img_mcu_y;
        -: 1966:   int img_mcu_w, img_mcu_h;
        -: 1967:
        -: 1968:// definition of jpeg image component
        -: 1969:   struct
        -: 1970:   {
        -: 1971:      int id;
        -: 1972:      int h,v;
        -: 1973:      int tq;
        -: 1974:      int hd,ha;
        -: 1975:      int dc_pred;
        -: 1976:
        -: 1977:      int x,y,w2,h2;
        -: 1978:      stbi_uc *data;
        -: 1979:      void *raw_data, *raw_coeff;
        -: 1980:      stbi_uc *linebuf;
        -: 1981:      short   *coeff;   // progressive only
        -: 1982:      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
        -: 1983:   } img_comp[4];
        -: 1984:
        -: 1985:   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
        -: 1986:   int            code_bits;   // number of valid bits
        -: 1987:   unsigned char  marker;      // marker seen while filling entropy buffer
        -: 1988:   int            nomore;      // flag if we saw a marker so must stop
        -: 1989:
        -: 1990:   int            progressive;
        -: 1991:   int            spec_start;
        -: 1992:   int            spec_end;
        -: 1993:   int            succ_high;
        -: 1994:   int            succ_low;
        -: 1995:   int            eob_run;
        -: 1996:   int            jfif;
        -: 1997:   int            app14_color_transform; // Adobe APP14 tag
        -: 1998:   int            rgb;
        -: 1999:
        -: 2000:   int scan_n, order[4];
        -: 2001:   int restart_interval, todo;
        -: 2002:
        -: 2003:// kernels
        -: 2004:   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
        -: 2005:   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
        -: 2006:   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
        -: 2007:} stbi__jpeg;
        -: 2008:
function _ZL19stbi__build_huffmanP13stbi__huffmanPi called 0 returned 0% blocks executed 0%
    #####: 2009:static int stbi__build_huffman(stbi__huffman *h, int *count)
        -: 2010:{
    #####: 2011:   int i,j,k=0;
        -: 2012:   unsigned int code;
        -: 2013:   // build size list for each symbol (from JPEG spec)
    #####: 2014:   for (i=0; i < 16; ++i) {
    %%%%%: 2014-block 2
    %%%%%: 2014-block 8
    %%%%%: 2014-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2015:      for (j=0; j < count[i]; ++j) {
    %%%%%: 2015-block 3
    %%%%%: 2015-block 6
    %%%%%: 2015-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2016:         h->size[k++] = (stbi_uc) (i+1);
    #####: 2017:         if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
    %%%%%: 2017-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2017-block 5
call    2 never executed
        -: 2018:      }
        -: 2019:   }
    #####: 2020:   h->size[k] = 0;
        -: 2021:
        -: 2022:   // compute actual symbols (from jpeg spec)
    #####: 2023:   code = 0;
    #####: 2024:   k = 0;
    #####: 2025:   for(j=1; j <= 16; ++j) {
    %%%%%: 2025-block 10
    %%%%%: 2025-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2026:      // compute delta to add to code to compute symbol id
    #####: 2027:      h->delta[j] = k - code;
    #####: 2028:      if (h->size[k] == j) {
    %%%%%: 2028-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2029:         while (h->size[k] == j)
    %%%%%: 2029-block 12
    %%%%%: 2029-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2030:            h->code[k++] = (stbi__uint16) (code++);
    %%%%%: 2030-block 13
    #####: 2031:         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
    %%%%%: 2031-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2031-block 16
call    2 never executed
        -: 2032:      }
        -: 2033:      // compute largest code + 1 for this size, preshifted as needed later
    #####: 2034:      h->maxcode[j] = code << (16-j);
    #####: 2035:      code <<= 1;
    %%%%%: 2035-block 17
        -: 2036:   }
    #####: 2037:   h->maxcode[j] = 0xffffffff;
        -: 2038:
        -: 2039:   // build non-spec acceleration table; 255 is flag for not-accelerated
    #####: 2040:   memset(h->fast, 255, 1 << FAST_BITS);
    #####: 2041:   for (i=0; i < k; ++i) {
    %%%%%: 2041-block 19
    %%%%%: 2041-block 24
    %%%%%: 2041-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2042:      int s = h->size[i];
    #####: 2043:      if (s <= FAST_BITS) {
    %%%%%: 2043-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2044:         int c = h->code[i] << (FAST_BITS-s);
    #####: 2045:         int m = 1 << (FAST_BITS-s);
    #####: 2046:         for (j=0; j < m; ++j) {
    %%%%%: 2046-block 21
    %%%%%: 2046-block 23
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2047:            h->fast[c+j] = (stbi_uc) i;
    %%%%%: 2047-block 22
        -: 2048:         }
        -: 2049:      }
        -: 2050:   }
    #####: 2051:   return 1;
    %%%%%: 2051-block 26
        -: 2052:}
        -: 2053:
        -: 2054:// build a table that decodes both magnitude and value of small ACs in
        -: 2055:// one go.
function _ZL19stbi__build_fast_acPsP13stbi__huffman called 0 returned 0% blocks executed 0%
    #####: 2056:static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
        -: 2057:{
        -: 2058:   int i;
    #####: 2059:   for (i=0; i < (1 << FAST_BITS); ++i) {
    %%%%%: 2059-block 2
    %%%%%: 2059-block 11
    %%%%%: 2059-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2060:      stbi_uc fast = h->fast[i];
    #####: 2061:      fast_ac[i] = 0;
    #####: 2062:      if (fast < 255) {
    %%%%%: 2062-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2063:         int rs = h->values[fast];
    #####: 2064:         int run = (rs >> 4) & 15;
    #####: 2065:         int magbits = rs & 15;
    #####: 2066:         int len = h->size[fast];
        -: 2067:
    #####: 2068:         if (magbits && len + magbits <= FAST_BITS) {
    %%%%%: 2068-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2068-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2069:            // magnitude code followed by receive_extend code
    #####: 2070:            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
    #####: 2071:            int m = 1 << (magbits - 1);
    #####: 2072:            if (k < m) k += (~0U << magbits) + 1;
    %%%%%: 2072-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2072-block 7
        -: 2073:            // if the result is small enough, we can fit it in fast_ac table
    #####: 2074:            if (k >= -128 && k <= 127)
    %%%%%: 2074-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2074-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2075:               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
    %%%%%: 2075-block 10
        -: 2076:         }
        -: 2077:      }
        -: 2078:   }
    #####: 2079:}
        -: 2080:
function _ZL24stbi__grow_buffer_unsafeP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2081:static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
        -: 2082:{
        -: 2083:   do {
    #####: 2084:      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
    %%%%%: 2084-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2084-block 3
call    2 never executed
    %%%%%: 2084-block 5
    #####: 2085:      if (b == 0xff) {
    %%%%%: 2085-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2086:         int c = stbi__get8(j->s);
    %%%%%: 2086-block 7
call    0 never executed
    #####: 2087:         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
    %%%%%: 2087-block 9
call    0 never executed
    %%%%%: 2087-block 11
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 2088:         if (c != 0) {
    %%%%%: 2088-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2089:            j->marker = (unsigned char) c;
    #####: 2090:            j->nomore = 1;
    #####: 2091:            return;
    %%%%%: 2091-block 13
        -: 2092:         }
        -: 2093:      }
    #####: 2094:      j->code_buffer |= b << (24 - j->code_bits);
    #####: 2095:      j->code_bits += 8;
    #####: 2096:   } while (j->code_bits <= 24);
    %%%%%: 2096-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2097:}
        -: 2098:
        -: 2099:// (1 << n) - 1
        -: 2100:static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
        -: 2101:
        -: 2102:// decode a jpeg huffman value from the bitstream
function _ZL22stbi__jpeg_huff_decodeP10stbi__jpegP13stbi__huffman called 0 returned 0% blocks executed 0%
    #####: 2103:stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
        -: 2104:{
        -: 2105:   unsigned int temp;
        -: 2106:   int c,k;
        -: 2107:
    #####: 2108:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2108-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2108-block 3
call    2 never executed
        -: 2109:
        -: 2110:   // look at the top FAST_BITS and determine what symbol ID it is,
        -: 2111:   // if the code is <= FAST_BITS
    #####: 2112:   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
    #####: 2113:   k = h->fast[c];
    #####: 2114:   if (k < 255) {
    %%%%%: 2114-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2115:      int s = h->size[k];
    #####: 2116:      if (s > j->code_bits)
    %%%%%: 2116-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2117:         return -1;
    %%%%%: 2117-block 6
    #####: 2118:      j->code_buffer <<= s;
    #####: 2119:      j->code_bits -= s;
    #####: 2120:      return h->values[k];
    %%%%%: 2120-block 7
        -: 2121:   }
        -: 2122:
        -: 2123:   // naive test is to shift the code_buffer down so k bits are
        -: 2124:   // valid, then test against maxcode. To speed this up, we've
        -: 2125:   // preshifted maxcode left so that it has (16-k) 0s at the
        -: 2126:   // end; in other words, regardless of the number of bits, it
        -: 2127:   // wants to be compared against something shifted to have 16;
        -: 2128:   // that way we don't need to shift inside the loop.
    #####: 2129:   temp = j->code_buffer >> 16;
    #####: 2130:   for (k=FAST_BITS+1 ; ; ++k)
    %%%%%: 2130-block 8
    %%%%%: 2130-block 11
    #####: 2131:      if (temp < h->maxcode[k])
    %%%%%: 2131-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2132:         break;
    %%%%%: 2132-block 10
    #####: 2133:   if (k == 17) {
    %%%%%: 2133-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2134:      // error! code not found
    #####: 2135:      j->code_bits -= 16;
    #####: 2136:      return -1;
    %%%%%: 2136-block 13
        -: 2137:   }
        -: 2138:
    #####: 2139:   if (k > j->code_bits)
    %%%%%: 2139-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2140:      return -1;
    %%%%%: 2140-block 15
        -: 2141:
        -: 2142:   // convert the huffman code to the symbol id
    #####: 2143:   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
    #####: 2144:   if(c < 0 || c >= 256) // symbol id out of bounds!
    %%%%%: 2144-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2144-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2145:       return -1;
    %%%%%: 2145-block 18
    #####: 2146:   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
    %%%%%: 2146-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2146-block 20
call    2 never executed
        -: 2147:
        -: 2148:   // convert the id to a symbol
    #####: 2149:   j->code_bits -= k;
    #####: 2150:   j->code_buffer <<= k;
    #####: 2151:   return h->values[c];
    %%%%%: 2151-block 21
        -: 2152:}
        -: 2153:
        -: 2154:// bias[n] = (-1<<n) + 1
        -: 2155:static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
        -: 2156:
        -: 2157:// combined JPEG 'receive' and JPEG 'extend', since baseline
        -: 2158:// always extends everything it receives.
function _ZL20stbi__extend_receiveP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 2159:stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
        -: 2160:{
        -: 2161:   unsigned int k;
        -: 2162:   int sgn;
    #####: 2163:   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
    %%%%%: 2163-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2163-block 3
call    2 never executed
    #####: 2164:   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
    %%%%%: 2164-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2164-block 5
        -: 2165:
    #####: 2166:   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
    #####: 2167:   k = stbi_lrot(j->code_buffer, n);
    #####: 2168:   j->code_buffer = k & ~stbi__bmask[n];
    #####: 2169:   k &= stbi__bmask[n];
    #####: 2170:   j->code_bits -= n;
    #####: 2171:   return k + (stbi__jbias[n] & (sgn - 1));
    %%%%%: 2171-block 6
        -: 2172:}
        -: 2173:
        -: 2174:// get some unsigned bits
function _ZL19stbi__jpeg_get_bitsP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 2175:stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
        -: 2176:{
        -: 2177:   unsigned int k;
    #####: 2178:   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
    %%%%%: 2178-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2178-block 3
call    2 never executed
    #####: 2179:   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
    %%%%%: 2179-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2179-block 5
    #####: 2180:   k = stbi_lrot(j->code_buffer, n);
    #####: 2181:   j->code_buffer = k & ~stbi__bmask[n];
    #####: 2182:   k &= stbi__bmask[n];
    #####: 2183:   j->code_bits -= n;
    #####: 2184:   return k;
    %%%%%: 2184-block 6
        -: 2185:}
        -: 2186:
function _ZL18stbi__jpeg_get_bitP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2187:stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
        -: 2188:{
        -: 2189:   unsigned int k;
    #####: 2190:   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
    %%%%%: 2190-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2190-block 3
call    2 never executed
    #####: 2191:   if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
    %%%%%: 2191-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2191-block 5
    #####: 2192:   k = j->code_buffer;
    #####: 2193:   j->code_buffer <<= 1;
    #####: 2194:   --j->code_bits;
    #####: 2195:   return k & 0x80000000;
    %%%%%: 2195-block 6
        -: 2196:}
        -: 2197:
        -: 2198:// given a value that's at position X in the zigzag stream,
        -: 2199:// where does it appear in the 8x8 matrix coded as row-major?
        -: 2200:static const stbi_uc stbi__jpeg_dezigzag[64+15] =
        -: 2201:{
        -: 2202:    0,  1,  8, 16,  9,  2,  3, 10,
        -: 2203:   17, 24, 32, 25, 18, 11,  4,  5,
        -: 2204:   12, 19, 26, 33, 40, 48, 41, 34,
        -: 2205:   27, 20, 13,  6,  7, 14, 21, 28,
        -: 2206:   35, 42, 49, 56, 57, 50, 43, 36,
        -: 2207:   29, 22, 15, 23, 30, 37, 44, 51,
        -: 2208:   58, 59, 52, 45, 38, 31, 39, 46,
        -: 2209:   53, 60, 61, 54, 47, 55, 62, 63,
        -: 2210:   // let corrupt input sample past end
        -: 2211:   63, 63, 63, 63, 63, 63, 63, 63,
        -: 2212:   63, 63, 63, 63, 63, 63, 63
        -: 2213:};
        -: 2214:
        -: 2215:// decode one 64-entry block--
function _ZL23stbi__jpeg_decode_blockP10stbi__jpegPsP13stbi__huffmanS3_S1_iPt called 0 returned 0% blocks executed 0%
    #####: 2216:static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
        -: 2217:{
        -: 2218:   int diff,dc,k;
        -: 2219:   int t;
        -: 2220:
    #####: 2221:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2221-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2221-block 3
call    2 never executed
    #####: 2222:   t = stbi__jpeg_huff_decode(j, hdc);
    %%%%%: 2222-block 4
call    0 never executed
    #####: 2223:   if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2223-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2223-block 7
call    4 never executed
        -: 2224:
        -: 2225:   // 0 all the ac values now so we can do it 32-bits at a time
    #####: 2226:   memset(data,0,64*sizeof(data[0]));
        -: 2227:
    #####: 2228:   diff = t ? stbi__extend_receive(j, t) : 0;
    %%%%%: 2228-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2228-block 9
call    2 never executed
    %%%%%: 2228-block 11
    #####: 2229:   if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
    %%%%%: 2229-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2229-block 14
call    3 never executed
    #####: 2230:   dc = j->img_comp[b].dc_pred + diff;
    #####: 2231:   j->img_comp[b].dc_pred = dc;
    #####: 2232:   if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2232-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2232-block 17
call    3 never executed
    #####: 2233:   data[0] = (short) (dc * dequant[0]);
        -: 2234:
        -: 2235:   // decode AC components, see JPEG spec
    #####: 2236:   k = 1;
    %%%%%: 2236-block 18
        -: 2237:   do {
        -: 2238:      unsigned int zig;
        -: 2239:      int c,r,s;
    #####: 2240:      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2240-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2240-block 20
call    2 never executed
    #####: 2241:      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
    #####: 2242:      r = fac[c];
    #####: 2243:      if (r) { // fast-AC path
    %%%%%: 2243-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2244:         k += (r >> 4) & 15; // run
    #####: 2245:         s = r & 15; // combined length
    #####: 2246:         if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
    %%%%%: 2246-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2246-block 23
call    2 never executed
    #####: 2247:         j->code_buffer <<= s;
    #####: 2248:         j->code_bits -= s;
        -: 2249:         // decode into unzigzag'd location
    #####: 2250:         zig = stbi__jpeg_dezigzag[k++];
    #####: 2251:         data[zig] = (short) ((r >> 8) * dequant[zig]);
    %%%%%: 2251-block 24
        -: 2252:      } else {
    #####: 2253:         int rs = stbi__jpeg_huff_decode(j, hac);
    %%%%%: 2253-block 25
call    0 never executed
    #####: 2254:         if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2254-block 27
call    2 never executed
    #####: 2255:         s = rs & 15;
    #####: 2256:         r = rs >> 4;
    #####: 2257:         if (s == 0) {
    %%%%%: 2257-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2258:            if (rs != 0xf0) break; // end block
    %%%%%: 2258-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2258-block 30
    #####: 2259:            k += 16;
    %%%%%: 2259-block 31
        -: 2260:         } else {
    #####: 2261:            k += r;
        -: 2262:            // decode into unzigzag'd location
    #####: 2263:            zig = stbi__jpeg_dezigzag[k++];
    #####: 2264:            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
    %%%%%: 2264-block 32
call    0 never executed
        -: 2265:         }
        -: 2266:      }
    #####: 2267:   } while (k < 64);
    %%%%%: 2267-block 34
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2268:   return 1;
    %%%%%: 2268-block 35
        -: 2269:}
        -: 2270:
function _ZL31stbi__jpeg_decode_block_prog_dcP10stbi__jpegPsP13stbi__huffmani called 0 returned 0% blocks executed 0%
    #####: 2271:static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
        -: 2272:{
        -: 2273:   int diff,dc;
        -: 2274:   int t;
    #####: 2275:   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2275-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2275-block 3
call    2 never executed
        -: 2276:
    #####: 2277:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2277-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2277-block 5
call    2 never executed
        -: 2278:
    #####: 2279:   if (j->succ_high == 0) {
    %%%%%: 2279-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2280:      // first scan for DC coefficient, must be first
    #####: 2281:      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
    #####: 2282:      t = stbi__jpeg_huff_decode(j, hdc);
    %%%%%: 2282-block 7
call    0 never executed
    #####: 2283:      if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2283-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2283-block 10
call    4 never executed
    #####: 2284:      diff = t ? stbi__extend_receive(j, t) : 0;
    %%%%%: 2284-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2284-block 12
call    2 never executed
    %%%%%: 2284-block 14
        -: 2285:
    #####: 2286:      if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
    %%%%%: 2286-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2286-block 17
call    3 never executed
    #####: 2287:      dc = j->img_comp[b].dc_pred + diff;
    #####: 2288:      j->img_comp[b].dc_pred = dc;
    #####: 2289:      if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2289-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2289-block 20
call    3 never executed
    #####: 2290:      data[0] = (short) (dc * (1 << j->succ_low));
    %%%%%: 2290-block 21
        -: 2291:   } else {
        -: 2292:      // refinement scan for DC coefficient
    #####: 2293:      if (stbi__jpeg_get_bit(j))
    %%%%%: 2293-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2294:         data[0] += (short) (1 << j->succ_low);
    %%%%%: 2294-block 24
        -: 2295:   }
    #####: 2296:   return 1;
    %%%%%: 2296-block 25
        -: 2297:}
        -: 2298:
        -: 2299:// @OPTIMIZE: store non-zigzagged during the decode passes,
        -: 2300:// and only de-zigzag when dequantizing
function _ZL31stbi__jpeg_decode_block_prog_acP10stbi__jpegPsP13stbi__huffmanS1_ called 0 returned 0% blocks executed 0%
    #####: 2301:static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
        -: 2302:{
        -: 2303:   int k;
    #####: 2304:   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2304-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2304-block 3
call    2 never executed
        -: 2305:
    #####: 2306:   if (j->succ_high == 0) {
    %%%%%: 2306-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2307:      int shift = j->succ_low;
        -: 2308:
    #####: 2309:      if (j->eob_run) {
    %%%%%: 2309-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2310:         --j->eob_run;
    #####: 2311:         return 1;
    %%%%%: 2311-block 6
        -: 2312:      }
        -: 2313:
    #####: 2314:      k = j->spec_start;
    %%%%%: 2314-block 7
        -: 2315:      do {
        -: 2316:         unsigned int zig;
        -: 2317:         int c,r,s;
    #####: 2318:         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2318-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2318-block 9
call    2 never executed
    #####: 2319:         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
    #####: 2320:         r = fac[c];
    #####: 2321:         if (r) { // fast-AC path
    %%%%%: 2321-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2322:            k += (r >> 4) & 15; // run
    #####: 2323:            s = r & 15; // combined length
    #####: 2324:            if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
    %%%%%: 2324-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2324-block 12
call    2 never executed
    #####: 2325:            j->code_buffer <<= s;
    #####: 2326:            j->code_bits -= s;
    #####: 2327:            zig = stbi__jpeg_dezigzag[k++];
    #####: 2328:            data[zig] = (short) ((r >> 8) * (1 << shift));
    %%%%%: 2328-block 13
        -: 2329:         } else {
    #####: 2330:            int rs = stbi__jpeg_huff_decode(j, hac);
    %%%%%: 2330-block 14
call    0 never executed
    #####: 2331:            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2331-block 16
call    2 never executed
    #####: 2332:            s = rs & 15;
    #####: 2333:            r = rs >> 4;
    #####: 2334:            if (s == 0) {
    %%%%%: 2334-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2335:               if (r < 15) {
    %%%%%: 2335-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2336:                  j->eob_run = (1 << r);
    #####: 2337:                  if (r)
    %%%%%: 2337-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2338:                     j->eob_run += stbi__jpeg_get_bits(j, r);
    %%%%%: 2338-block 20
call    0 never executed
    #####: 2339:                  --j->eob_run;
    #####: 2340:                  break;
    %%%%%: 2340-block 22
        -: 2341:               }
    #####: 2342:               k += 16;
    %%%%%: 2342-block 23
        -: 2343:            } else {
    #####: 2344:               k += r;
    #####: 2345:               zig = stbi__jpeg_dezigzag[k++];
    #####: 2346:               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
    %%%%%: 2346-block 24
call    0 never executed
        -: 2347:            }
        -: 2348:         }
    #####: 2349:      } while (k <= j->spec_end);
    %%%%%: 2349-block 26
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2350:   } else {
        -: 2351:      // refinement scan for these AC coefficients
        -: 2352:
    #####: 2353:      short bit = (short) (1 << j->succ_low);
        -: 2354:
    #####: 2355:      if (j->eob_run) {
    %%%%%: 2355-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2356:         --j->eob_run;
    #####: 2357:         for (k = j->spec_start; k <= j->spec_end; ++k) {
    %%%%%: 2357-block 29
    %%%%%: 2357-block 37
    %%%%%: 2357-block 38
branch  0 never executed
branch  1 never executed
    #####: 2358:            short *p = &data[stbi__jpeg_dezigzag[k]];
    #####: 2359:            if (*p != 0)
    %%%%%: 2359-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2360:               if (stbi__jpeg_get_bit(j))
    %%%%%: 2360-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2361:                  if ((*p & bit)==0) {
    %%%%%: 2361-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2362:                     if (*p > 0)
    %%%%%: 2362-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2363:                        *p += bit;
    %%%%%: 2363-block 35
        -: 2364:                     else
    #####: 2365:                        *p -= bit;
    %%%%%: 2365-block 36
        -: 2366:                  }
        -: 2367:         }
        -: 2368:      } else {
    #####: 2369:         k = j->spec_start;
    %%%%%: 2369-block 39
        -: 2370:         do {
        -: 2371:            int r,s;
    #####: 2372:            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
    %%%%%: 2372-block 40
call    0 never executed
    #####: 2373:            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2373-block 42
call    2 never executed
    #####: 2374:            s = rs & 15;
    #####: 2375:            r = rs >> 4;
    #####: 2376:            if (s == 0) {
    %%%%%: 2376-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2377:               if (r < 15) {
    %%%%%: 2377-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2378:                  j->eob_run = (1 << r) - 1;
    #####: 2379:                  if (r)
    %%%%%: 2379-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2380:                     j->eob_run += stbi__jpeg_get_bits(j, r);
    %%%%%: 2380-block 46
call    0 never executed
    #####: 2381:                  r = 64; // force end of block
    %%%%%: 2381-block 48
        -: 2382:               } else {
        -: 2383:                  // r=15 s=0 should write 16 0s, so we just do
        -: 2384:                  // a run of 15 0s and then write s (which is 0),
        -: 2385:                  // so we don't have to do anything special here
        -: 2386:               }
        -: 2387:            } else {
    #####: 2388:               if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
    %%%%%: 2388-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2388-block 50
call    2 never executed
        -: 2389:               // sign bit
    #####: 2390:               if (stbi__jpeg_get_bit(j))
    %%%%%: 2390-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2391:                  s = bit;
    %%%%%: 2391-block 53
        -: 2392:               else
    #####: 2393:                  s = -bit;
    %%%%%: 2393-block 54
        -: 2394:            }
        -: 2395:
        -: 2396:            // advance by r
    #####: 2397:            while (k <= j->spec_end) {
    %%%%%: 2397-block 55
    %%%%%: 2397-block 66
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2398:               short *p = &data[stbi__jpeg_dezigzag[k++]];
    #####: 2399:               if (*p != 0) {
    %%%%%: 2399-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2400:                  if (stbi__jpeg_get_bit(j))
    %%%%%: 2400-block 57
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2401:                     if ((*p & bit)==0) {
    %%%%%: 2401-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2402:                        if (*p > 0)
    %%%%%: 2402-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2403:                           *p += bit;
    %%%%%: 2403-block 61
        -: 2404:                        else
    #####: 2405:                           *p -= bit;
    %%%%%: 2405-block 62
        -: 2406:                     }
        -: 2407:               } else {
    #####: 2408:                  if (r == 0) {
    %%%%%: 2408-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2409:                     *p = (short) s;
    #####: 2410:                     break;
    %%%%%: 2410-block 64
        -: 2411:                  }
    #####: 2412:                  --r;
    %%%%%: 2412-block 65
        -: 2413:               }
        -: 2414:            }
    #####: 2415:         } while (k <= j->spec_end);
    %%%%%: 2415-block 67
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2416:      }
        -: 2417:   }
    #####: 2418:   return 1;
    %%%%%: 2418-block 68
        -: 2419:}
        -: 2420:
        -: 2421:// take a -128..127 value and stbi__clamp it and convert to 0..255
function _ZL11stbi__clampi called 0 returned 0% blocks executed 0%
    #####: 2422:stbi_inline static stbi_uc stbi__clamp(int x)
        -: 2423:{
        -: 2424:   // trick to use a single test to catch both cases
    #####: 2425:   if ((unsigned int) x > 255) {
    %%%%%: 2425-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2426:      if (x < 0) return 0;
    %%%%%: 2426-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2426-block 4
    #####: 2427:      if (x > 255) return 255;
    %%%%%: 2427-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2427-block 6
        -: 2428:   }
    #####: 2429:   return (stbi_uc) x;
    %%%%%: 2429-block 7
        -: 2430:}
        -: 2431:
        -: 2432:#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
        -: 2433:#define stbi__fsh(x)  ((x) * 4096)
        -: 2434:
        -: 2435:// derived from jidctint -- DCT_ISLOW
        -: 2436:#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
        -: 2437:   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
        -: 2438:   p2 = s2;                                    \
        -: 2439:   p3 = s6;                                    \
        -: 2440:   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
        -: 2441:   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
        -: 2442:   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
        -: 2443:   p2 = s0;                                    \
        -: 2444:   p3 = s4;                                    \
        -: 2445:   t0 = stbi__fsh(p2+p3);                      \
        -: 2446:   t1 = stbi__fsh(p2-p3);                      \
        -: 2447:   x0 = t0+t3;                                 \
        -: 2448:   x3 = t0-t3;                                 \
        -: 2449:   x1 = t1+t2;                                 \
        -: 2450:   x2 = t1-t2;                                 \
        -: 2451:   t0 = s7;                                    \
        -: 2452:   t1 = s5;                                    \
        -: 2453:   t2 = s3;                                    \
        -: 2454:   t3 = s1;                                    \
        -: 2455:   p3 = t0+t2;                                 \
        -: 2456:   p4 = t1+t3;                                 \
        -: 2457:   p1 = t0+t3;                                 \
        -: 2458:   p2 = t1+t2;                                 \
        -: 2459:   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
        -: 2460:   t0 = t0*stbi__f2f( 0.298631336f);           \
        -: 2461:   t1 = t1*stbi__f2f( 2.053119869f);           \
        -: 2462:   t2 = t2*stbi__f2f( 3.072711026f);           \
        -: 2463:   t3 = t3*stbi__f2f( 1.501321110f);           \
        -: 2464:   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
        -: 2465:   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
        -: 2466:   p3 = p3*stbi__f2f(-1.961570560f);           \
        -: 2467:   p4 = p4*stbi__f2f(-0.390180644f);           \
        -: 2468:   t3 += p1+p4;                                \
        -: 2469:   t2 += p2+p3;                                \
        -: 2470:   t1 += p2+p4;                                \
        -: 2471:   t0 += p1+p3;
        -: 2472:
function _ZL16stbi__idct_blockPhiPs called 0 returned 0% blocks executed 0%
    #####: 2473:static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
        -: 2474:{
    #####: 2475:   int i,val[64],*v=val;
        -: 2476:   stbi_uc *o;
    #####: 2477:   short *d = data;
        -: 2478:
        -: 2479:   // columns
    #####: 2480:   for (i=0; i < 8; ++i,++d, ++v) {
    %%%%%: 2480-block 2
    %%%%%: 2480-block 12
    %%%%%: 2480-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2481:      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
    #####: 2482:      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
    %%%%%: 2482-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2482-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2482-block 5
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2482-block 6
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2483:           && d[40]==0 && d[48]==0 && d[56]==0) {
    %%%%%: 2483-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2483-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2483-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 2484:         //    no shortcut                 0     seconds
        -: 2485:         //    (1|2|3|4|5|6|7)==0          0     seconds
        -: 2486:         //    all separate               -0.047 seconds
        -: 2487:         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
    #####: 2488:         int dcterm = d[0]*4;
    #####: 2489:         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
    #####: 2490:      } else {
    %%%%%: 2490-block 10
    #####: 2491:         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
        -: 2492:         // constants scaled things up by 1<<12; let's bring them back
        -: 2493:         // down, but keep 2 extra bits of precision
    #####: 2494:         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
    #####: 2495:         v[ 0] = (x0+t3) >> 10;
    #####: 2496:         v[56] = (x0-t3) >> 10;
    #####: 2497:         v[ 8] = (x1+t2) >> 10;
    #####: 2498:         v[48] = (x1-t2) >> 10;
    #####: 2499:         v[16] = (x2+t1) >> 10;
    #####: 2500:         v[40] = (x2-t1) >> 10;
    #####: 2501:         v[24] = (x3+t0) >> 10;
    #####: 2502:         v[32] = (x3-t0) >> 10;
    %%%%%: 2502-block 11
        -: 2503:      }
        -: 2504:   }
        -: 2505:
    #####: 2506:   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
    %%%%%: 2506-block 14
    %%%%%: 2506-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2507:      // no fast case since the first 1D IDCT spread components out
    #####: 2508:      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
        -: 2509:      // constants scaled things up by 1<<12, plus we had 1<<2 from first
        -: 2510:      // loop, plus horizontal and vertical each scale by sqrt(8) so together
        -: 2511:      // we've got an extra 1<<3, so 1<<17 total we need to remove.
        -: 2512:      // so we want to round that, which means adding 0.5 * 1<<17,
        -: 2513:      // aka 65536. Also, we'll end up with -128 to 127 that we want
        -: 2514:      // to encode as 0..255 by adding 128, so we'll add that before the shift
    #####: 2515:      x0 += 65536 + (128<<17);
    #####: 2516:      x1 += 65536 + (128<<17);
    #####: 2517:      x2 += 65536 + (128<<17);
    #####: 2518:      x3 += 65536 + (128<<17);
        -: 2519:      // tried computing the shifts into temps, or'ing the temps to see
        -: 2520:      // if any were out of range, but that was slower
    #####: 2521:      o[0] = stbi__clamp((x0+t3) >> 17);
    %%%%%: 2521-block 15
call    0 never executed
    #####: 2522:      o[7] = stbi__clamp((x0-t3) >> 17);
call    0 never executed
    #####: 2523:      o[1] = stbi__clamp((x1+t2) >> 17);
call    0 never executed
    #####: 2524:      o[6] = stbi__clamp((x1-t2) >> 17);
call    0 never executed
    #####: 2525:      o[2] = stbi__clamp((x2+t1) >> 17);
call    0 never executed
    #####: 2526:      o[5] = stbi__clamp((x2-t1) >> 17);
call    0 never executed
    #####: 2527:      o[3] = stbi__clamp((x3+t0) >> 17);
call    0 never executed
    #####: 2528:      o[4] = stbi__clamp((x3-t0) >> 17);
call    0 never executed
        -: 2529:   }
    #####: 2530:}
        -: 2531:
        -: 2532:#ifdef STBI_SSE2
        -: 2533:// sse2 integer IDCT. not the fastest possible implementation but it
        -: 2534:// produces bit-identical results to the generic C version so it's
        -: 2535:// fully "transparent".
function _ZL15stbi__idct_simdPhiPs called 0 returned 0% blocks executed 0%
    #####: 2536:static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
    %%%%%: 2536-block 2
        -: 2537:{
        -: 2538:   // This is constructed to match our regular (generic) integer IDCT exactly.
        -: 2539:   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
        -: 2540:   __m128i tmp;
        -: 2541:
        -: 2542:   // dot product constant: even elems=x, odd elems=y
        -: 2543:   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
        -: 2544:
        -: 2545:   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
        -: 2546:   // out(1) = c1[even]*x + c1[odd]*y
        -: 2547:   #define dct_rot(out0,out1, x,y,c0,c1) \
        -: 2548:      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
        -: 2549:      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
        -: 2550:      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
        -: 2551:      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
        -: 2552:      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
        -: 2553:      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
        -: 2554:
        -: 2555:   // out = in << 12  (in 16-bit, out 32-bit)
        -: 2556:   #define dct_widen(out, in) \
        -: 2557:      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
        -: 2558:      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
        -: 2559:
        -: 2560:   // wide add
        -: 2561:   #define dct_wadd(out, a, b) \
        -: 2562:      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
        -: 2563:      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
        -: 2564:
        -: 2565:   // wide sub
        -: 2566:   #define dct_wsub(out, a, b) \
        -: 2567:      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
        -: 2568:      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
        -: 2569:
        -: 2570:   // butterfly a/b, add bias, then shift by "s" and pack
        -: 2571:   #define dct_bfly32o(out0, out1, a,b,bias,s) \
        -: 2572:      { \
        -: 2573:         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
        -: 2574:         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
        -: 2575:         dct_wadd(sum, abiased, b); \
        -: 2576:         dct_wsub(dif, abiased, b); \
        -: 2577:         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
        -: 2578:         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
        -: 2579:      }
        -: 2580:
        -: 2581:   // 8-bit interleave step (for transposes)
        -: 2582:   #define dct_interleave8(a, b) \
        -: 2583:      tmp = a; \
        -: 2584:      a = _mm_unpacklo_epi8(a, b); \
        -: 2585:      b = _mm_unpackhi_epi8(tmp, b)
        -: 2586:
        -: 2587:   // 16-bit interleave step (for transposes)
        -: 2588:   #define dct_interleave16(a, b) \
        -: 2589:      tmp = a; \
        -: 2590:      a = _mm_unpacklo_epi16(a, b); \
        -: 2591:      b = _mm_unpackhi_epi16(tmp, b)
        -: 2592:
        -: 2593:   #define dct_pass(bias,shift) \
        -: 2594:      { \
        -: 2595:         /* even part */ \
        -: 2596:         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
        -: 2597:         __m128i sum04 = _mm_add_epi16(row0, row4); \
        -: 2598:         __m128i dif04 = _mm_sub_epi16(row0, row4); \
        -: 2599:         dct_widen(t0e, sum04); \
        -: 2600:         dct_widen(t1e, dif04); \
        -: 2601:         dct_wadd(x0, t0e, t3e); \
        -: 2602:         dct_wsub(x3, t0e, t3e); \
        -: 2603:         dct_wadd(x1, t1e, t2e); \
        -: 2604:         dct_wsub(x2, t1e, t2e); \
        -: 2605:         /* odd part */ \
        -: 2606:         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
        -: 2607:         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
        -: 2608:         __m128i sum17 = _mm_add_epi16(row1, row7); \
        -: 2609:         __m128i sum35 = _mm_add_epi16(row3, row5); \
        -: 2610:         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
        -: 2611:         dct_wadd(x4, y0o, y4o); \
        -: 2612:         dct_wadd(x5, y1o, y5o); \
        -: 2613:         dct_wadd(x6, y2o, y5o); \
        -: 2614:         dct_wadd(x7, y3o, y4o); \
        -: 2615:         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
        -: 2616:         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
        -: 2617:         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
        -: 2618:         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
        -: 2619:      }
        -: 2620:
    #####: 2621:   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
    %%%%%: 2621-block 6
    #####: 2622:   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
    %%%%%: 2622-block 10
    #####: 2623:   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
    %%%%%: 2623-block 14
    #####: 2624:   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
    %%%%%: 2624-block 18
    #####: 2625:   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
    %%%%%: 2625-block 22
    #####: 2626:   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
    %%%%%: 2626-block 26
    #####: 2627:   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
    %%%%%: 2627-block 30
    #####: 2628:   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
    %%%%%: 2628-block 34
        -: 2629:
        -: 2630:   // rounding biases in column/row passes, see stbi__idct_block for explanation.
    #####: 2631:   __m128i bias_0 = _mm_set1_epi32(512);
    %%%%%: 2631-block 38
    #####: 2632:   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
    %%%%%: 2632-block 42
        -: 2633:
        -: 2634:   // load
    #####: 2635:   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
    #####: 2636:   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
    %%%%%: 2636-block 44
    #####: 2637:   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
    %%%%%: 2637-block 46
    #####: 2638:   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
    %%%%%: 2638-block 48
    #####: 2639:   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
    %%%%%: 2639-block 50
    #####: 2640:   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
    %%%%%: 2640-block 52
    #####: 2641:   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
    %%%%%: 2641-block 54
    #####: 2642:   row7 = _mm_load_si128((const __m128i *) (data + 7*8));
    %%%%%: 2642-block 56
    %%%%%: 2642-block 58
        -: 2643:
        -: 2644:   // column pass
    #####: 2645:   dct_pass(bias_0, 10);
    %%%%%: 2645-block 60
    %%%%%: 2645-block 62
    %%%%%: 2645-block 64
    %%%%%: 2645-block 66
    %%%%%: 2645-block 68
    %%%%%: 2645-block 70
    %%%%%: 2645-block 72
    %%%%%: 2645-block 74
    %%%%%: 2645-block 76
    %%%%%: 2645-block 78
    %%%%%: 2645-block 80
    %%%%%: 2645-block 82
    %%%%%: 2645-block 84
    %%%%%: 2645-block 86
    %%%%%: 2645-block 88
    %%%%%: 2645-block 90
    %%%%%: 2645-block 92
    %%%%%: 2645-block 94
    %%%%%: 2645-block 96
    %%%%%: 2645-block 98
    %%%%%: 2645-block 100
    %%%%%: 2645-block 102
    %%%%%: 2645-block 104
    %%%%%: 2645-block 106
    %%%%%: 2645-block 108
    %%%%%: 2645-block 110
    %%%%%: 2645-block 112
    %%%%%: 2645-block 114
    %%%%%: 2645-block 116
    %%%%%: 2645-block 118
    %%%%%: 2645-block 120
    %%%%%: 2645-block 122
    %%%%%: 2645-block 124
    %%%%%: 2645-block 126
    %%%%%: 2645-block 128
    %%%%%: 2645-block 130
    %%%%%: 2645-block 132
    %%%%%: 2645-block 134
    %%%%%: 2645-block 136
    %%%%%: 2645-block 138
    %%%%%: 2645-block 140
    %%%%%: 2645-block 142
    %%%%%: 2645-block 144
    %%%%%: 2645-block 146
    %%%%%: 2645-block 148
    %%%%%: 2645-block 150
    %%%%%: 2645-block 152
    %%%%%: 2645-block 154
    %%%%%: 2645-block 156
    %%%%%: 2645-block 158
    %%%%%: 2645-block 160
    %%%%%: 2645-block 162
    %%%%%: 2645-block 164
    %%%%%: 2645-block 166
    %%%%%: 2645-block 168
    %%%%%: 2645-block 170
    %%%%%: 2645-block 172
    %%%%%: 2645-block 174
    %%%%%: 2645-block 176
    %%%%%: 2645-block 178
    %%%%%: 2645-block 180
    %%%%%: 2645-block 182
    %%%%%: 2645-block 184
    %%%%%: 2645-block 186
    %%%%%: 2645-block 188
    %%%%%: 2645-block 190
    %%%%%: 2645-block 192
    %%%%%: 2645-block 194
    %%%%%: 2645-block 196
    %%%%%: 2645-block 198
    %%%%%: 2645-block 200
    %%%%%: 2645-block 202
    %%%%%: 2645-block 204
    %%%%%: 2645-block 206
    %%%%%: 2645-block 208
    %%%%%: 2645-block 210
    %%%%%: 2645-block 212
    %%%%%: 2645-block 214
    %%%%%: 2645-block 216
    %%%%%: 2645-block 218
    %%%%%: 2645-block 220
    %%%%%: 2645-block 222
    %%%%%: 2645-block 224
    %%%%%: 2645-block 226
    %%%%%: 2645-block 228
    %%%%%: 2645-block 230
    %%%%%: 2645-block 232
    %%%%%: 2645-block 234
    %%%%%: 2645-block 236
    %%%%%: 2645-block 238
    %%%%%: 2645-block 240
    %%%%%: 2645-block 242
    %%%%%: 2645-block 244
    %%%%%: 2645-block 246
    %%%%%: 2645-block 248
    %%%%%: 2645-block 250
    %%%%%: 2645-block 252
    %%%%%: 2645-block 254
    %%%%%: 2645-block 256
    %%%%%: 2645-block 258
    %%%%%: 2645-block 260
    %%%%%: 2645-block 262
    %%%%%: 2645-block 264
        -: 2646:
        -: 2647:   {
        -: 2648:      // 16bit 8x8 transpose pass 1
    #####: 2649:      dct_interleave16(row0, row4);
    %%%%%: 2649-block 266
    %%%%%: 2649-block 268
    #####: 2650:      dct_interleave16(row1, row5);
    %%%%%: 2650-block 270
    %%%%%: 2650-block 272
    #####: 2651:      dct_interleave16(row2, row6);
    %%%%%: 2651-block 274
    %%%%%: 2651-block 276
    #####: 2652:      dct_interleave16(row3, row7);
    %%%%%: 2652-block 278
    %%%%%: 2652-block 280
        -: 2653:
        -: 2654:      // transpose pass 2
    #####: 2655:      dct_interleave16(row0, row2);
    %%%%%: 2655-block 282
    %%%%%: 2655-block 284
    #####: 2656:      dct_interleave16(row1, row3);
    %%%%%: 2656-block 286
    %%%%%: 2656-block 288
    #####: 2657:      dct_interleave16(row4, row6);
    %%%%%: 2657-block 290
    %%%%%: 2657-block 292
    #####: 2658:      dct_interleave16(row5, row7);
    %%%%%: 2658-block 294
    %%%%%: 2658-block 296
        -: 2659:
        -: 2660:      // transpose pass 3
    #####: 2661:      dct_interleave16(row0, row1);
    %%%%%: 2661-block 298
    %%%%%: 2661-block 300
    #####: 2662:      dct_interleave16(row2, row3);
    %%%%%: 2662-block 302
    %%%%%: 2662-block 304
    #####: 2663:      dct_interleave16(row4, row5);
    %%%%%: 2663-block 306
    %%%%%: 2663-block 308
    #####: 2664:      dct_interleave16(row6, row7);
    %%%%%: 2664-block 310
    %%%%%: 2664-block 312
    %%%%%: 2664-block 314
        -: 2665:   }
        -: 2666:
        -: 2667:   // row pass
    #####: 2668:   dct_pass(bias_1, 17);
    %%%%%: 2668-block 316
    %%%%%: 2668-block 318
    %%%%%: 2668-block 320
    %%%%%: 2668-block 322
    %%%%%: 2668-block 324
    %%%%%: 2668-block 326
    %%%%%: 2668-block 328
    %%%%%: 2668-block 330
    %%%%%: 2668-block 332
    %%%%%: 2668-block 334
    %%%%%: 2668-block 336
    %%%%%: 2668-block 338
    %%%%%: 2668-block 340
    %%%%%: 2668-block 342
    %%%%%: 2668-block 344
    %%%%%: 2668-block 346
    %%%%%: 2668-block 348
    %%%%%: 2668-block 350
    %%%%%: 2668-block 352
    %%%%%: 2668-block 354
    %%%%%: 2668-block 356
    %%%%%: 2668-block 358
    %%%%%: 2668-block 360
    %%%%%: 2668-block 362
    %%%%%: 2668-block 364
    %%%%%: 2668-block 366
    %%%%%: 2668-block 368
    %%%%%: 2668-block 370
    %%%%%: 2668-block 372
    %%%%%: 2668-block 374
    %%%%%: 2668-block 376
    %%%%%: 2668-block 378
    %%%%%: 2668-block 380
    %%%%%: 2668-block 382
    %%%%%: 2668-block 384
    %%%%%: 2668-block 386
    %%%%%: 2668-block 388
    %%%%%: 2668-block 390
    %%%%%: 2668-block 392
    %%%%%: 2668-block 394
    %%%%%: 2668-block 396
    %%%%%: 2668-block 398
    %%%%%: 2668-block 400
    %%%%%: 2668-block 402
    %%%%%: 2668-block 404
    %%%%%: 2668-block 406
    %%%%%: 2668-block 408
    %%%%%: 2668-block 410
    %%%%%: 2668-block 412
    %%%%%: 2668-block 414
    %%%%%: 2668-block 416
    %%%%%: 2668-block 418
    %%%%%: 2668-block 420
    %%%%%: 2668-block 422
    %%%%%: 2668-block 424
    %%%%%: 2668-block 426
    %%%%%: 2668-block 428
    %%%%%: 2668-block 430
    %%%%%: 2668-block 432
    %%%%%: 2668-block 434
    %%%%%: 2668-block 436
    %%%%%: 2668-block 438
    %%%%%: 2668-block 440
    %%%%%: 2668-block 442
    %%%%%: 2668-block 444
    %%%%%: 2668-block 446
    %%%%%: 2668-block 448
    %%%%%: 2668-block 450
    %%%%%: 2668-block 452
    %%%%%: 2668-block 454
    %%%%%: 2668-block 456
    %%%%%: 2668-block 458
    %%%%%: 2668-block 460
    %%%%%: 2668-block 462
    %%%%%: 2668-block 464
    %%%%%: 2668-block 466
    %%%%%: 2668-block 468
    %%%%%: 2668-block 470
    %%%%%: 2668-block 472
    %%%%%: 2668-block 474
    %%%%%: 2668-block 476
    %%%%%: 2668-block 478
    %%%%%: 2668-block 480
    %%%%%: 2668-block 482
    %%%%%: 2668-block 484
    %%%%%: 2668-block 486
    %%%%%: 2668-block 488
    %%%%%: 2668-block 490
    %%%%%: 2668-block 492
    %%%%%: 2668-block 494
    %%%%%: 2668-block 496
    %%%%%: 2668-block 498
    %%%%%: 2668-block 500
    %%%%%: 2668-block 502
    %%%%%: 2668-block 504
    %%%%%: 2668-block 506
    %%%%%: 2668-block 508
    %%%%%: 2668-block 510
    %%%%%: 2668-block 512
    %%%%%: 2668-block 514
    %%%%%: 2668-block 516
    %%%%%: 2668-block 518
    %%%%%: 2668-block 520
    %%%%%: 2668-block 522
        -: 2669:
        -: 2670:   {
        -: 2671:      // pack
    #####: 2672:      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
    %%%%%: 2672-block 524
    #####: 2673:      __m128i p1 = _mm_packus_epi16(row2, row3);
    %%%%%: 2673-block 526
    #####: 2674:      __m128i p2 = _mm_packus_epi16(row4, row5);
    %%%%%: 2674-block 528
    #####: 2675:      __m128i p3 = _mm_packus_epi16(row6, row7);
        -: 2676:
        -: 2677:      // 8bit 8x8 transpose pass 1
    #####: 2678:      dct_interleave8(p0, p2); // a0e0a1e1...
    %%%%%: 2678-block 530
    %%%%%: 2678-block 532
    #####: 2679:      dct_interleave8(p1, p3); // c0g0c1g1...
    %%%%%: 2679-block 534
    %%%%%: 2679-block 536
        -: 2680:
        -: 2681:      // transpose pass 2
    #####: 2682:      dct_interleave8(p0, p1); // a0c0e0g0...
    %%%%%: 2682-block 538
    %%%%%: 2682-block 540
    #####: 2683:      dct_interleave8(p2, p3); // b0d0f0h0...
    %%%%%: 2683-block 542
    %%%%%: 2683-block 544
        -: 2684:
        -: 2685:      // transpose pass 3
    #####: 2686:      dct_interleave8(p0, p2); // a0b0c0d0...
    %%%%%: 2686-block 546
    %%%%%: 2686-block 548
    #####: 2687:      dct_interleave8(p1, p3); // a4b4c4d4...
    %%%%%: 2687-block 550
    %%%%%: 2687-block 552
    %%%%%: 2687-block 554
        -: 2688:
        -: 2689:      // store
    #####: 2690:      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
    #####: 2691:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
    %%%%%: 2691-block 555
    %%%%%: 2691-block 556
    #####: 2692:      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
    #####: 2693:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
    %%%%%: 2693-block 557
    %%%%%: 2693-block 558
    #####: 2694:      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
    #####: 2695:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
    %%%%%: 2695-block 559
    %%%%%: 2695-block 560
    #####: 2696:      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
    #####: 2697:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
    %%%%%: 2697-block 561
        -: 2698:   }
        -: 2699:
        -: 2700:#undef dct_const
        -: 2701:#undef dct_rot
        -: 2702:#undef dct_widen
        -: 2703:#undef dct_wadd
        -: 2704:#undef dct_wsub
        -: 2705:#undef dct_bfly32o
        -: 2706:#undef dct_interleave8
        -: 2707:#undef dct_interleave16
        -: 2708:#undef dct_pass
    #####: 2709:}
        -: 2710:
        -: 2711:#endif // STBI_SSE2
        -: 2712:
        -: 2713:#ifdef STBI_NEON
        -: 2714:
        -: 2715:// NEON integer IDCT. should produce bit-identical
        -: 2716:// results to the generic C version.
        -: 2717:static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
        -: 2718:{
        -: 2719:   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
        -: 2720:
        -: 2721:   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
        -: 2722:   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
        -: 2723:   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
        -: 2724:   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
        -: 2725:   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
        -: 2726:   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
        -: 2727:   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
        -: 2728:   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
        -: 2729:   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
        -: 2730:   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
        -: 2731:   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
        -: 2732:   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
        -: 2733:
        -: 2734:#define dct_long_mul(out, inq, coeff) \
        -: 2735:   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
        -: 2736:   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
        -: 2737:
        -: 2738:#define dct_long_mac(out, acc, inq, coeff) \
        -: 2739:   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
        -: 2740:   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
        -: 2741:
        -: 2742:#define dct_widen(out, inq) \
        -: 2743:   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
        -: 2744:   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
        -: 2745:
        -: 2746:// wide add
        -: 2747:#define dct_wadd(out, a, b) \
        -: 2748:   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
        -: 2749:   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
        -: 2750:
        -: 2751:// wide sub
        -: 2752:#define dct_wsub(out, a, b) \
        -: 2753:   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
        -: 2754:   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
        -: 2755:
        -: 2756:// butterfly a/b, then shift using "shiftop" by "s" and pack
        -: 2757:#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
        -: 2758:   { \
        -: 2759:      dct_wadd(sum, a, b); \
        -: 2760:      dct_wsub(dif, a, b); \
        -: 2761:      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
        -: 2762:      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
        -: 2763:   }
        -: 2764:
        -: 2765:#define dct_pass(shiftop, shift) \
        -: 2766:   { \
        -: 2767:      /* even part */ \
        -: 2768:      int16x8_t sum26 = vaddq_s16(row2, row6); \
        -: 2769:      dct_long_mul(p1e, sum26, rot0_0); \
        -: 2770:      dct_long_mac(t2e, p1e, row6, rot0_1); \
        -: 2771:      dct_long_mac(t3e, p1e, row2, rot0_2); \
        -: 2772:      int16x8_t sum04 = vaddq_s16(row0, row4); \
        -: 2773:      int16x8_t dif04 = vsubq_s16(row0, row4); \
        -: 2774:      dct_widen(t0e, sum04); \
        -: 2775:      dct_widen(t1e, dif04); \
        -: 2776:      dct_wadd(x0, t0e, t3e); \
        -: 2777:      dct_wsub(x3, t0e, t3e); \
        -: 2778:      dct_wadd(x1, t1e, t2e); \
        -: 2779:      dct_wsub(x2, t1e, t2e); \
        -: 2780:      /* odd part */ \
        -: 2781:      int16x8_t sum15 = vaddq_s16(row1, row5); \
        -: 2782:      int16x8_t sum17 = vaddq_s16(row1, row7); \
        -: 2783:      int16x8_t sum35 = vaddq_s16(row3, row5); \
        -: 2784:      int16x8_t sum37 = vaddq_s16(row3, row7); \
        -: 2785:      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
        -: 2786:      dct_long_mul(p5o, sumodd, rot1_0); \
        -: 2787:      dct_long_mac(p1o, p5o, sum17, rot1_1); \
        -: 2788:      dct_long_mac(p2o, p5o, sum35, rot1_2); \
        -: 2789:      dct_long_mul(p3o, sum37, rot2_0); \
        -: 2790:      dct_long_mul(p4o, sum15, rot2_1); \
        -: 2791:      dct_wadd(sump13o, p1o, p3o); \
        -: 2792:      dct_wadd(sump24o, p2o, p4o); \
        -: 2793:      dct_wadd(sump23o, p2o, p3o); \
        -: 2794:      dct_wadd(sump14o, p1o, p4o); \
        -: 2795:      dct_long_mac(x4, sump13o, row7, rot3_0); \
        -: 2796:      dct_long_mac(x5, sump24o, row5, rot3_1); \
        -: 2797:      dct_long_mac(x6, sump23o, row3, rot3_2); \
        -: 2798:      dct_long_mac(x7, sump14o, row1, rot3_3); \
        -: 2799:      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
        -: 2800:      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
        -: 2801:      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
        -: 2802:      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
        -: 2803:   }
        -: 2804:
        -: 2805:   // load
        -: 2806:   row0 = vld1q_s16(data + 0*8);
        -: 2807:   row1 = vld1q_s16(data + 1*8);
        -: 2808:   row2 = vld1q_s16(data + 2*8);
        -: 2809:   row3 = vld1q_s16(data + 3*8);
        -: 2810:   row4 = vld1q_s16(data + 4*8);
        -: 2811:   row5 = vld1q_s16(data + 5*8);
        -: 2812:   row6 = vld1q_s16(data + 6*8);
        -: 2813:   row7 = vld1q_s16(data + 7*8);
        -: 2814:
        -: 2815:   // add DC bias
        -: 2816:   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
        -: 2817:
        -: 2818:   // column pass
        -: 2819:   dct_pass(vrshrn_n_s32, 10);
        -: 2820:
        -: 2821:   // 16bit 8x8 transpose
        -: 2822:   {
        -: 2823:// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
        -: 2824:// whether compilers actually get this is another story, sadly.
        -: 2825:#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
        -: 2826:#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
        -: 2827:#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
        -: 2828:
        -: 2829:      // pass 1
        -: 2830:      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
        -: 2831:      dct_trn16(row2, row3);
        -: 2832:      dct_trn16(row4, row5);
        -: 2833:      dct_trn16(row6, row7);
        -: 2834:
        -: 2835:      // pass 2
        -: 2836:      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
        -: 2837:      dct_trn32(row1, row3);
        -: 2838:      dct_trn32(row4, row6);
        -: 2839:      dct_trn32(row5, row7);
        -: 2840:
        -: 2841:      // pass 3
        -: 2842:      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
        -: 2843:      dct_trn64(row1, row5);
        -: 2844:      dct_trn64(row2, row6);
        -: 2845:      dct_trn64(row3, row7);
        -: 2846:
        -: 2847:#undef dct_trn16
        -: 2848:#undef dct_trn32
        -: 2849:#undef dct_trn64
        -: 2850:   }
        -: 2851:
        -: 2852:   // row pass
        -: 2853:   // vrshrn_n_s32 only supports shifts up to 16, we need
        -: 2854:   // 17. so do a non-rounding shift of 16 first then follow
        -: 2855:   // up with a rounding shift by 1.
        -: 2856:   dct_pass(vshrn_n_s32, 16);
        -: 2857:
        -: 2858:   {
        -: 2859:      // pack and round
        -: 2860:      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
        -: 2861:      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
        -: 2862:      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
        -: 2863:      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
        -: 2864:      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
        -: 2865:      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
        -: 2866:      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
        -: 2867:      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
        -: 2868:
        -: 2869:      // again, these can translate into one instruction, but often don't.
        -: 2870:#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
        -: 2871:#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
        -: 2872:#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
        -: 2873:
        -: 2874:      // sadly can't use interleaved stores here since we only write
        -: 2875:      // 8 bytes to each scan line!
        -: 2876:
        -: 2877:      // 8x8 8-bit transpose pass 1
        -: 2878:      dct_trn8_8(p0, p1);
        -: 2879:      dct_trn8_8(p2, p3);
        -: 2880:      dct_trn8_8(p4, p5);
        -: 2881:      dct_trn8_8(p6, p7);
        -: 2882:
        -: 2883:      // pass 2
        -: 2884:      dct_trn8_16(p0, p2);
        -: 2885:      dct_trn8_16(p1, p3);
        -: 2886:      dct_trn8_16(p4, p6);
        -: 2887:      dct_trn8_16(p5, p7);
        -: 2888:
        -: 2889:      // pass 3
        -: 2890:      dct_trn8_32(p0, p4);
        -: 2891:      dct_trn8_32(p1, p5);
        -: 2892:      dct_trn8_32(p2, p6);
        -: 2893:      dct_trn8_32(p3, p7);
        -: 2894:
        -: 2895:      // store
        -: 2896:      vst1_u8(out, p0); out += out_stride;
        -: 2897:      vst1_u8(out, p1); out += out_stride;
        -: 2898:      vst1_u8(out, p2); out += out_stride;
        -: 2899:      vst1_u8(out, p3); out += out_stride;
        -: 2900:      vst1_u8(out, p4); out += out_stride;
        -: 2901:      vst1_u8(out, p5); out += out_stride;
        -: 2902:      vst1_u8(out, p6); out += out_stride;
        -: 2903:      vst1_u8(out, p7);
        -: 2904:
        -: 2905:#undef dct_trn8_8
        -: 2906:#undef dct_trn8_16
        -: 2907:#undef dct_trn8_32
        -: 2908:   }
        -: 2909:
        -: 2910:#undef dct_long_mul
        -: 2911:#undef dct_long_mac
        -: 2912:#undef dct_widen
        -: 2913:#undef dct_wadd
        -: 2914:#undef dct_wsub
        -: 2915:#undef dct_bfly32o
        -: 2916:#undef dct_pass
        -: 2917:}
        -: 2918:
        -: 2919:#endif // STBI_NEON
        -: 2920:
        -: 2921:#define STBI__MARKER_none  0xff
        -: 2922:// if there's a pending marker from the entropy stream, return that
        -: 2923:// otherwise, fetch from the stream and get a marker. if there's no
        -: 2924:// marker, return 0xff, which is never a valid marker value
function _ZL16stbi__get_markerP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2925:static stbi_uc stbi__get_marker(stbi__jpeg *j)
        -: 2926:{
        -: 2927:   stbi_uc x;
    #####: 2928:   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
    %%%%%: 2928-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2928-block 3
    #####: 2929:   x = stbi__get8(j->s);
    %%%%%: 2929-block 4
call    0 never executed
    #####: 2930:   if (x != 0xff) return STBI__MARKER_none;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2930-block 6
    #####: 2931:   while (x == 0xff)
    %%%%%: 2931-block 7
    %%%%%: 2931-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2932:      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
    %%%%%: 2932-block 8
call    0 never executed
    #####: 2933:   return x;
    %%%%%: 2933-block 11
        -: 2934:}
        -: 2935:
        -: 2936:// in each scan, we'll have scan_n components, and the order
        -: 2937:// of the components is specified by order[]
        -: 2938:#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
        -: 2939:
        -: 2940:// after a restart interval, stbi__jpeg_reset the entropy decoder and
        -: 2941:// the dc prediction
function _ZL16stbi__jpeg_resetP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2942:static void stbi__jpeg_reset(stbi__jpeg *j)
        -: 2943:{
    #####: 2944:   j->code_bits = 0;
    #####: 2945:   j->code_buffer = 0;
    #####: 2946:   j->nomore = 0;
    #####: 2947:   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
    #####: 2948:   j->marker = STBI__MARKER_none;
    #####: 2949:   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
    %%%%%: 2949-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2949-block 3
    %%%%%: 2949-block 4
    #####: 2950:   j->eob_run = 0;
        -: 2951:   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
        -: 2952:   // since we don't even allow 1<<30 pixels
    #####: 2953:}
        -: 2954:
function _ZL30stbi__parse_entropy_coded_dataP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2955:static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
        -: 2956:{
    #####: 2957:   stbi__jpeg_reset(z);
    %%%%%: 2957-block 2
call    0 never executed
    #####: 2958:   if (!z->progressive) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2959:      if (z->scan_n == 1) {
    %%%%%: 2959-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2960:         int i,j;
        -: 2961:         STBI_SIMD_ALIGN(short, data[64]);
    #####: 2962:         int n = z->order[0];
        -: 2963:         // non-interleaved data, we just need to process one block at a time,
        -: 2964:         // in trivial scanline order
        -: 2965:         // number of blocks to do just depends on how many actual "pixels" this
        -: 2966:         // component has, independent of interleaved MCU blocking and such
    #####: 2967:         int w = (z->img_comp[n].x+7) >> 3;
    #####: 2968:         int h = (z->img_comp[n].y+7) >> 3;
    #####: 2969:         for (j=0; j < h; ++j) {
    %%%%%: 2969-block 5
    %%%%%: 2969-block 20
    %%%%%: 2969-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2970:            for (i=0; i < w; ++i) {
    %%%%%: 2970-block 6
    %%%%%: 2970-block 18
    %%%%%: 2970-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2971:               int ha = z->img_comp[n].ha;
    #####: 2972:               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
    %%%%%: 2972-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2972-block 8
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2972-block 9
    #####: 2973:               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
    %%%%%: 2973-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2974:               // every data block is an MCU, so countdown the restart interval
    #####: 2975:               if (--z->todo <= 0) {
    %%%%%: 2975-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2976:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 2976-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2976-block 13
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 2977:                  // if it's NOT a restart, then just bail, so we get corrupt data
        -: 2978:                  // rather than no data
    #####: 2979:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 2979-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2979-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2979-block 16
    #####: 2980:                  stbi__jpeg_reset(z);
    %%%%%: 2980-block 17
call    0 never executed
        -: 2981:               }
        -: 2982:            }
        -: 2983:         }
    #####: 2984:         return 1;
    %%%%%: 2984-block 22
        -: 2985:      } else { // interleaved
        -: 2986:         int i,j,k,x,y;
        -: 2987:         STBI_SIMD_ALIGN(short, data[64]);
    #####: 2988:         for (j=0; j < z->img_mcu_y; ++j) {
    %%%%%: 2988-block 24
    %%%%%: 2988-block 48
    %%%%%: 2988-block 49
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2989:            for (i=0; i < z->img_mcu_x; ++i) {
    %%%%%: 2989-block 25
    %%%%%: 2989-block 46
    %%%%%: 2989-block 47
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2990:               // scan an interleaved mcu... process scan_n components in order
    #####: 2991:               for (k=0; k < z->scan_n; ++k) {
    %%%%%: 2991-block 26
    %%%%%: 2991-block 37
    %%%%%: 2991-block 38
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2992:                  int n = z->order[k];
        -: 2993:                  // scan out an mcu's worth of this component; that's just determined
        -: 2994:                  // by the basic H and V specified for the component
    #####: 2995:                  for (y=0; y < z->img_comp[n].v; ++y) {
    %%%%%: 2995-block 27
    %%%%%: 2995-block 35
    %%%%%: 2995-block 36
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2996:                     for (x=0; x < z->img_comp[n].h; ++x) {
    %%%%%: 2996-block 28
    %%%%%: 2996-block 33
    %%%%%: 2996-block 34
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2997:                        int x2 = (i*z->img_comp[n].h + x)*8;
    #####: 2998:                        int y2 = (j*z->img_comp[n].v + y)*8;
    #####: 2999:                        int ha = z->img_comp[n].ha;
    #####: 3000:                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
    %%%%%: 3000-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3000-block 30
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3000-block 31
    #####: 3001:                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
    %%%%%: 3001-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3002:                     }
        -: 3003:                  }
        -: 3004:               }
        -: 3005:               // after all interleaved components, that's an interleaved MCU,
        -: 3006:               // so now count down the restart interval
    #####: 3007:               if (--z->todo <= 0) {
    %%%%%: 3007-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3008:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 3008-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3008-block 41
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 3009:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 3009-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3009-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3009-block 44
    #####: 3010:                  stbi__jpeg_reset(z);
    %%%%%: 3010-block 45
call    0 never executed
        -: 3011:               }
        -: 3012:            }
        -: 3013:         }
    #####: 3014:         return 1;
    %%%%%: 3014-block 50
        -: 3015:      }
        -: 3016:   } else {
    #####: 3017:      if (z->scan_n == 1) {
    %%%%%: 3017-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3018:         int i,j;
    #####: 3019:         int n = z->order[0];
        -: 3020:         // non-interleaved data, we just need to process one block at a time,
        -: 3021:         // in trivial scanline order
        -: 3022:         // number of blocks to do just depends on how many actual "pixels" this
        -: 3023:         // component has, independent of interleaved MCU blocking and such
    #####: 3024:         int w = (z->img_comp[n].x+7) >> 3;
    #####: 3025:         int h = (z->img_comp[n].y+7) >> 3;
    #####: 3026:         for (j=0; j < h; ++j) {
    %%%%%: 3026-block 53
    %%%%%: 3026-block 71
    %%%%%: 3026-block 72
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3027:            for (i=0; i < w; ++i) {
    %%%%%: 3027-block 54
    %%%%%: 3027-block 69
    %%%%%: 3027-block 70
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3028:               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
    #####: 3029:               if (z->spec_start == 0) {
    %%%%%: 3029-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3030:                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
    %%%%%: 3030-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3031:                     return 0;
    %%%%%: 3031-block 58
        -: 3032:               } else {
    #####: 3033:                  int ha = z->img_comp[n].ha;
    #####: 3034:                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
    %%%%%: 3034-block 59
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3035:                     return 0;
    %%%%%: 3035-block 61
        -: 3036:               }
        -: 3037:               // every data block is an MCU, so countdown the restart interval
    #####: 3038:               if (--z->todo <= 0) {
    %%%%%: 3038-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3039:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 3039-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3039-block 64
call    2 never executed
    #####: 3040:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 3040-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3040-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3040-block 67
    #####: 3041:                  stbi__jpeg_reset(z);
    %%%%%: 3041-block 68
call    0 never executed
        -: 3042:               }
        -: 3043:            }
        -: 3044:         }
    #####: 3045:         return 1;
    %%%%%: 3045-block 73
        -: 3046:      } else { // interleaved
        -: 3047:         int i,j,k,x,y;
    #####: 3048:         for (j=0; j < z->img_mcu_y; ++j) {
    %%%%%: 3048-block 74
    %%%%%: 3048-block 97
    %%%%%: 3048-block 98
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3049:            for (i=0; i < z->img_mcu_x; ++i) {
    %%%%%: 3049-block 75
    %%%%%: 3049-block 95
    %%%%%: 3049-block 96
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3050:               // scan an interleaved mcu... process scan_n components in order
    #####: 3051:               for (k=0; k < z->scan_n; ++k) {
    %%%%%: 3051-block 76
    %%%%%: 3051-block 86
    %%%%%: 3051-block 87
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3052:                  int n = z->order[k];
        -: 3053:                  // scan out an mcu's worth of this component; that's just determined
        -: 3054:                  // by the basic H and V specified for the component
    #####: 3055:                  for (y=0; y < z->img_comp[n].v; ++y) {
    %%%%%: 3055-block 77
    %%%%%: 3055-block 84
    %%%%%: 3055-block 85
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3056:                     for (x=0; x < z->img_comp[n].h; ++x) {
    %%%%%: 3056-block 78
    %%%%%: 3056-block 82
    %%%%%: 3056-block 83
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3057:                        int x2 = (i*z->img_comp[n].h + x);
    #####: 3058:                        int y2 = (j*z->img_comp[n].v + y);
    #####: 3059:                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
    #####: 3060:                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
    %%%%%: 3060-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3061:                           return 0;
    %%%%%: 3061-block 81
        -: 3062:                     }
        -: 3063:                  }
        -: 3064:               }
        -: 3065:               // after all interleaved components, that's an interleaved MCU,
        -: 3066:               // so now count down the restart interval
    #####: 3067:               if (--z->todo <= 0) {
    %%%%%: 3067-block 88
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3068:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 3068-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3068-block 90
call    2 never executed
    #####: 3069:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 3069-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3069-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3069-block 93
    #####: 3070:                  stbi__jpeg_reset(z);
    %%%%%: 3070-block 94
call    0 never executed
        -: 3071:               }
        -: 3072:            }
        -: 3073:         }
    #####: 3074:         return 1;
    %%%%%: 3074-block 99
        -: 3075:      }
        -: 3076:   }
        -: 3077:}
        -: 3078:
function _ZL21stbi__jpeg_dequantizePsPt called 0 returned 0% blocks executed 0%
    #####: 3079:static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
        -: 3080:{
        -: 3081:   int i;
    #####: 3082:   for (i=0; i < 64; ++i)
    %%%%%: 3082-block 2
    %%%%%: 3082-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3083:      data[i] *= dequant[i];
    %%%%%: 3083-block 3
    #####: 3084:}
        -: 3085:
function _ZL17stbi__jpeg_finishP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3086:static void stbi__jpeg_finish(stbi__jpeg *z)
        -: 3087:{
    #####: 3088:   if (z->progressive) {
    %%%%%: 3088-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3089:      // dequantize and idct the data
        -: 3090:      int i,j,n;
    #####: 3091:      for (n=0; n < z->s->img_n; ++n) {
    %%%%%: 3091-block 3
    %%%%%: 3091-block 12
    %%%%%: 3091-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3092:         int w = (z->img_comp[n].x+7) >> 3;
    #####: 3093:         int h = (z->img_comp[n].y+7) >> 3;
    #####: 3094:         for (j=0; j < h; ++j) {
    %%%%%: 3094-block 4
    %%%%%: 3094-block 10
    %%%%%: 3094-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3095:            for (i=0; i < w; ++i) {
    %%%%%: 3095-block 5
    %%%%%: 3095-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3096:               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
    #####: 3097:               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
    %%%%%: 3097-block 6
call    0 never executed
    #####: 3098:               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
call    0 never executed
        -: 3099:            }
        -: 3100:         }
        -: 3101:      }
        -: 3102:   }
    #####: 3103:}
        -: 3104:
function _ZL20stbi__process_markerP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 3105:static int stbi__process_marker(stbi__jpeg *z, int m)
        -: 3106:{
        -: 3107:   int L;
    #####: 3108:   switch (m) {
    %%%%%: 3108-block 2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3109:      case STBI__MARKER_none: // no marker found
    #####: 3110:         return stbi__err("expected marker","Corrupt JPEG");
    %%%%%: 3110-block 3
call    0 never executed
        -: 3111:
    #####: 3112:      case 0xDD: // DRI - specify restart interval
    #####: 3113:         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
    %%%%%: 3113-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3113-block 6
call    3 never executed
    #####: 3114:         z->restart_interval = stbi__get16be(z->s);
    %%%%%: 3114-block 7
call    0 never executed
    #####: 3115:         return 1;
        -: 3116:
    #####: 3117:      case 0xDB: // DQT - define quantization table
    #####: 3118:         L = stbi__get16be(z->s)-2;
    %%%%%: 3118-block 9
call    0 never executed
    #####: 3119:         while (L > 0) {
    %%%%%: 3119-block 29
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3120:            int q = stbi__get8(z->s);
    %%%%%: 3120-block 11
call    0 never executed
    #####: 3121:            int p = q >> 4, sixteen = (p != 0);
    #####: 3122:            int t = q & 15,i;
    #####: 3123:            if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3123-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3123-block 14
call    4 never executed
    #####: 3124:            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
    %%%%%: 3124-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3124-block 16
call    2 never executed
        -: 3125:
    #####: 3126:            for (i=0; i < 64; ++i)
    %%%%%: 3126-block 17
    %%%%%: 3126-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3127:               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
    %%%%%: 3127-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3127-block 19
call    2 never executed
    %%%%%: 3127-block 21
call    3 never executed
    %%%%%: 3127-block 23
    #####: 3128:            L -= (sixteen ? 129 : 65);
    %%%%%: 3128-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3128-block 26
    %%%%%: 3128-block 27
    %%%%%: 3128-block 28
        -: 3129:         }
    #####: 3130:         return L==0;
    %%%%%: 3130-block 30
        -: 3131:
    #####: 3132:      case 0xC4: // DHT - define huffman table
    #####: 3133:         L = stbi__get16be(z->s)-2;
    %%%%%: 3133-block 31
call    0 never executed
    #####: 3134:         while (L > 0) {
    %%%%%: 3134-block 60
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3135:            stbi_uc *v;
    #####: 3136:            int sizes[16],i,n=0;
    #####: 3137:            int q = stbi__get8(z->s);
    %%%%%: 3137-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3138:            int tc = q >> 4;
    #####: 3139:            int th = q & 15;
    #####: 3140:            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
    %%%%%: 3140-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3140-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3140-block 36
call    4 never executed
    %%%%%: 3140-block 59
    #####: 3141:            for (i=0; i < 16; ++i) {
    %%%%%: 3141-block 37
    %%%%%: 3141-block 40
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3142:               sizes[i] = stbi__get8(z->s);
    %%%%%: 3142-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3143:               n += sizes[i];
    %%%%%: 3143-block 39
        -: 3144:            }
    #####: 3145:            if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
    %%%%%: 3145-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3145-block 42
call    2 never executed
    #####: 3146:            L -= 17;
    #####: 3147:            if (tc == 0) {
    %%%%%: 3147-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3148:               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
    %%%%%: 3148-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3148-block 46
    #####: 3149:               v = z->huff_dc[th].values;
    %%%%%: 3149-block 47
        -: 3150:            } else {
    #####: 3151:               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
    %%%%%: 3151-block 48
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3151-block 50
    #####: 3152:               v = z->huff_ac[th].values;
    %%%%%: 3152-block 51
        -: 3153:            }
    #####: 3154:            for (i=0; i < n; ++i)
    %%%%%: 3154-block 52
    %%%%%: 3154-block 55
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3155:               v[i] = stbi__get8(z->s);
    %%%%%: 3155-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3155-block 54
    #####: 3156:            if (tc != 0)
    %%%%%: 3156-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3157:               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
    %%%%%: 3157-block 57
call    0 never executed
    #####: 3158:            L -= n;
    %%%%%: 3158-block 58
        -: 3159:         }
    #####: 3160:         return L==0;
    %%%%%: 3160-block 61
        -: 3161:   }
        -: 3162:
        -: 3163:   // check for comment block or APP blocks
    #####: 3164:   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
    %%%%%: 3164-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3164-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3164-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3165:      L = stbi__get16be(z->s);
    %%%%%: 3165-block 65
call    0 never executed
    #####: 3166:      if (L < 2) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3167:         if (m == 0xFE)
    %%%%%: 3167-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3168:            return stbi__err("bad COM len","Corrupt JPEG");
    %%%%%: 3168-block 68
call    0 never executed
        -: 3169:         else
    #####: 3170:            return stbi__err("bad APP len","Corrupt JPEG");
    %%%%%: 3170-block 69
call    0 never executed
        -: 3171:      }
    #####: 3172:      L -= 2;
        -: 3173:
    #####: 3174:      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
    %%%%%: 3174-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3174-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3175:         static const unsigned char tag[5] = {'J','F','I','F','\0'};
    #####: 3176:         int ok = 1;
        -: 3177:         int i;
    #####: 3178:         for (i=0; i < 5; ++i)
    %%%%%: 3178-block 72
    %%%%%: 3178-block 76
    %%%%%: 3178-block 77
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3179:            if (stbi__get8(z->s) != tag[i])
    %%%%%: 3179-block 73
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3180:               ok = 0;
    %%%%%: 3180-block 75
    #####: 3181:         L -= 5;
    #####: 3182:         if (ok)
    %%%%%: 3182-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3183:            z->jfif = 1;
    %%%%%: 3183-block 79
    #####: 3184:      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
    %%%%%: 3184-block 80
    %%%%%: 3184-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3184-block 82
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3185:         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
    #####: 3186:         int ok = 1;
        -: 3187:         int i;
    #####: 3188:         for (i=0; i < 6; ++i)
    %%%%%: 3188-block 83
    %%%%%: 3188-block 87
    %%%%%: 3188-block 88
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3189:            if (stbi__get8(z->s) != tag[i])
    %%%%%: 3189-block 84
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3190:               ok = 0;
    %%%%%: 3190-block 86
    #####: 3191:         L -= 6;
    #####: 3192:         if (ok) {
    %%%%%: 3192-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3193:            stbi__get8(z->s); // version
    %%%%%: 3193-block 90
call    0 never executed
    #####: 3194:            stbi__get16be(z->s); // flags0
call    0 never executed
    #####: 3195:            stbi__get16be(z->s); // flags1
call    0 never executed
    #####: 3196:            z->app14_color_transform = stbi__get8(z->s); // color transform
call    0 never executed
    #####: 3197:            L -= 6;
        -: 3198:         }
        -: 3199:      }
        -: 3200:
    #####: 3201:      stbi__skip(z->s, L);
    %%%%%: 3201-block 95
call    0 never executed
    #####: 3202:      return 1;
        -: 3203:   }
        -: 3204:
    #####: 3205:   return stbi__err("unknown marker","Corrupt JPEG");
    %%%%%: 3205-block 97
call    0 never executed
        -: 3206:}
        -: 3207:
        -: 3208:// after we see SOS
function _ZL25stbi__process_scan_headerP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3209:static int stbi__process_scan_header(stbi__jpeg *z)
        -: 3210:{
        -: 3211:   int i;
    #####: 3212:   int Ls = stbi__get16be(z->s);
    %%%%%: 3212-block 2
call    0 never executed
    #####: 3213:   z->scan_n = stbi__get8(z->s);
call    0 never executed
    #####: 3214:   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3214-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3214-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3214-block 7
call    6 never executed
    #####: 3215:   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
    %%%%%: 3215-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3215-block 9
call    2 never executed
    #####: 3216:   for (i=0; i < z->scan_n; ++i) {
    %%%%%: 3216-block 10
    %%%%%: 3216-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3217:      int id = stbi__get8(z->s), which;
    %%%%%: 3217-block 11
call    0 never executed
    #####: 3218:      int q = stbi__get8(z->s);
call    0 never executed
    #####: 3219:      for (which = 0; which < z->s->img_n; ++which)
    %%%%%: 3219-block 16
    %%%%%: 3219-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3220:         if (z->img_comp[which].id == id)
    %%%%%: 3220-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3221:            break;
    %%%%%: 3221-block 15
    #####: 3222:      if (which == z->s->img_n) return 0; // no match
    %%%%%: 3222-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3222-block 19
    #####: 3223:      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
    %%%%%: 3223-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3223-block 21
call    2 never executed
    #####: 3224:      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
    %%%%%: 3224-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3224-block 23
call    2 never executed
    #####: 3225:      z->order[i] = which;
    %%%%%: 3225-block 24
        -: 3226:   }
        -: 3227:
        -: 3228:   {
        -: 3229:      int aa;
    #####: 3230:      z->spec_start = stbi__get8(z->s);
    %%%%%: 3230-block 26
call    0 never executed
    #####: 3231:      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
call    0 never executed
    #####: 3232:      aa = stbi__get8(z->s);
call    0 never executed
    #####: 3233:      z->succ_high = (aa >> 4);
    #####: 3234:      z->succ_low  = (aa & 15);
    #####: 3235:      if (z->progressive) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3236:         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
    %%%%%: 3236-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3236-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3236-block 32
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3236-block 33
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3236-block 34
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 3237:            return stbi__err("bad SOS", "Corrupt JPEG");
    %%%%%: 3237-block 35
call    0 never executed
        -: 3238:      } else {
    #####: 3239:         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
    %%%%%: 3239-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3239-block 37
call    2 never executed
    #####: 3240:         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
    %%%%%: 3240-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3240-block 39
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3240-block 40
call    4 never executed
    #####: 3241:         z->spec_end = 63;
    %%%%%: 3241-block 41
        -: 3242:      }
        -: 3243:   }
        -: 3244:
    #####: 3245:   return 1;
    %%%%%: 3245-block 42
        -: 3246:}
        -: 3247:
function _ZL26stbi__free_jpeg_componentsP10stbi__jpegii called 0 returned 0% blocks executed 0%
    #####: 3248:static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
        -: 3249:{
        -: 3250:   int i;
    #####: 3251:   for (i=0; i < ncomp; ++i) {
    %%%%%: 3251-block 2
    %%%%%: 3251-block 9
    %%%%%: 3251-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3252:      if (z->img_comp[i].raw_data) {
    %%%%%: 3252-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3253:         STBI_FREE(z->img_comp[i].raw_data);
    #####: 3254:         z->img_comp[i].raw_data = NULL;
    #####: 3255:         z->img_comp[i].data = NULL;
    %%%%%: 3255-block 4
        -: 3256:      }
    #####: 3257:      if (z->img_comp[i].raw_coeff) {
    %%%%%: 3257-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3258:         STBI_FREE(z->img_comp[i].raw_coeff);
    #####: 3259:         z->img_comp[i].raw_coeff = 0;
    #####: 3260:         z->img_comp[i].coeff = 0;
    %%%%%: 3260-block 6
        -: 3261:      }
    #####: 3262:      if (z->img_comp[i].linebuf) {
    %%%%%: 3262-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3263:         STBI_FREE(z->img_comp[i].linebuf);
    #####: 3264:         z->img_comp[i].linebuf = NULL;
    %%%%%: 3264-block 8
        -: 3265:      }
        -: 3266:   }
    #####: 3267:   return why;
    %%%%%: 3267-block 11
        -: 3268:}
        -: 3269:
function _ZL26stbi__process_frame_headerP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 3270:static int stbi__process_frame_header(stbi__jpeg *z, int scan)
        -: 3271:{
    #####: 3272:   stbi__context *s = z->s;
    #####: 3273:   int Lf,p,i,q, h_max=1,v_max=1,c;
    #####: 3274:   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
    %%%%%: 3274-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3274-block 4
call    3 never executed
    #####: 3275:   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
    %%%%%: 3275-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3275-block 7
call    3 never executed
    #####: 3276:   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
    %%%%%: 3276-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3276-block 10
call    3 never executed
    #####: 3277:   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
    %%%%%: 3277-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3277-block 13
call    3 never executed
    #####: 3278:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    %%%%%: 3278-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3278-block 15
call    2 never executed
    #####: 3279:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    %%%%%: 3279-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3279-block 17
call    2 never executed
    #####: 3280:   c = stbi__get8(s);
    %%%%%: 3280-block 18
call    0 never executed
    #####: 3281:   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3281-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3281-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3281-block 22
call    6 never executed
    #####: 3282:   s->img_n = c;
    #####: 3283:   for (i=0; i < c; ++i) {
    %%%%%: 3283-block 23
    %%%%%: 3283-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3284:      z->img_comp[i].data = NULL;
    #####: 3285:      z->img_comp[i].linebuf = NULL;
    %%%%%: 3285-block 24
        -: 3286:   }
        -: 3287:
    #####: 3288:   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
    %%%%%: 3288-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3288-block 27
call    2 never executed
        -: 3289:
    #####: 3290:   z->rgb = 0;
    #####: 3291:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3291-block 28
    %%%%%: 3291-block 43
    %%%%%: 3291-block 44
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3292:      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
    #####: 3293:      z->img_comp[i].id = stbi__get8(s);
    %%%%%: 3293-block 29
call    0 never executed
    #####: 3294:      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3294-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3295:         ++z->rgb;
    %%%%%: 3295-block 32
    #####: 3296:      q = stbi__get8(s);
    %%%%%: 3296-block 33
call    0 never executed
    #####: 3297:      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3297-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3297-block 36
call    4 never executed
    #####: 3298:      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
    %%%%%: 3298-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3298-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3298-block 39
call    4 never executed
    #####: 3299:      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
    %%%%%: 3299-block 40
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3299-block 42
call    3 never executed
        -: 3300:   }
        -: 3301:
    #####: 3302:   if (scan != STBI__SCAN_load) return 1;
    %%%%%: 3302-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3302-block 46
        -: 3303:
    #####: 3304:   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
    %%%%%: 3304-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3304-block 49
call    3 never executed
        -: 3305:
    #####: 3306:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3306-block 50
    %%%%%: 3306-block 55
    %%%%%: 3306-block 56
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3307:      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
    %%%%%: 3307-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3307-block 52
    #####: 3308:      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
    %%%%%: 3308-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3308-block 54
        -: 3309:   }
        -: 3310:
        -: 3311:   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
        -: 3312:   // and I've never seen a non-corrupted JPEG file actually use them
    #####: 3313:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3313-block 57
    %%%%%: 3313-block 62
    %%%%%: 3313-block 63
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3314:      if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
    %%%%%: 3314-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3314-block 59
call    2 never executed
    #####: 3315:      if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
    %%%%%: 3315-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3315-block 61
call    2 never executed
        -: 3316:   }
        -: 3317:
        -: 3318:   // compute interleaved mcu info
    #####: 3319:   z->img_h_max = h_max;
    #####: 3320:   z->img_v_max = v_max;
    #####: 3321:   z->img_mcu_w = h_max * 8;
    #####: 3322:   z->img_mcu_h = v_max * 8;
        -: 3323:   // these sizes can't be more than 17 bits
    #####: 3324:   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
    #####: 3325:   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
        -: 3326:
    #####: 3327:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3327-block 64
    %%%%%: 3327-block 75
    %%%%%: 3327-block 76
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3328:      // number of effective pixels (e.g. for non-interleaved MCU)
    #####: 3329:      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
    #####: 3330:      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
        -: 3331:      // to simplify generation, we'll allocate enough memory to decode
        -: 3332:      // the bogus oversized data from using interleaved MCUs and their
        -: 3333:      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
        -: 3334:      // discard the extra data until colorspace conversion
        -: 3335:      //
        -: 3336:      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
        -: 3337:      // so these muls can't overflow with 32-bit ints (which we require)
    #####: 3338:      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
    #####: 3339:      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
    #####: 3340:      z->img_comp[i].coeff = 0;
    #####: 3341:      z->img_comp[i].raw_coeff = 0;
    #####: 3342:      z->img_comp[i].linebuf = NULL;
    #####: 3343:      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
    %%%%%: 3343-block 65
call    0 never executed
    #####: 3344:      if (z->img_comp[i].raw_data == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3345:         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
    %%%%%: 3345-block 67
call    0 never executed
call    1 never executed
        -: 3346:      // align blocks for idct using mmx/sse
    #####: 3347:      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
    #####: 3348:      if (z->progressive) {
    %%%%%: 3348-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3349:         // w2, h2 are multiples of 8 (see above)
    #####: 3350:         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
    #####: 3351:         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
    #####: 3352:         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
    %%%%%: 3352-block 70
call    0 never executed
    #####: 3353:         if (z->img_comp[i].raw_coeff == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3354:            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
    %%%%%: 3354-block 72
call    0 never executed
call    1 never executed
    #####: 3355:         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
    %%%%%: 3355-block 74
        -: 3356:      }
        -: 3357:   }
        -: 3358:
    #####: 3359:   return 1;
    %%%%%: 3359-block 77
        -: 3360:}
        -: 3361:
        -: 3362:// use comparisons since in some cases we handle more than one case (e.g. SOF)
        -: 3363:#define stbi__DNL(x)         ((x) == 0xdc)
        -: 3364:#define stbi__SOI(x)         ((x) == 0xd8)
        -: 3365:#define stbi__EOI(x)         ((x) == 0xd9)
        -: 3366:#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
        -: 3367:#define stbi__SOS(x)         ((x) == 0xda)
        -: 3368:
        -: 3369:#define stbi__SOF_progressive(x)   ((x) == 0xc2)
        -: 3370:
function _ZL24stbi__decode_jpeg_headerP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 3371:static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
        -: 3372:{
        -: 3373:   int m;
    #####: 3374:   z->jfif = 0;
    #####: 3375:   z->app14_color_transform = -1; // valid values are 0,1,2
    #####: 3376:   z->marker = STBI__MARKER_none; // initialize cached marker to empty
    #####: 3377:   m = stbi__get_marker(z);
    %%%%%: 3377-block 2
call    0 never executed
    #####: 3378:   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3378-block 4
call    2 never executed
    #####: 3379:   if (scan == STBI__SCAN_type) return 1;
    %%%%%: 3379-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3379-block 6
    #####: 3380:   m = stbi__get_marker(z);
    %%%%%: 3380-block 7
call    0 never executed
    #####: 3381:   while (!stbi__SOF(m)) {
    %%%%%: 3381-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3381-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3381-block 22
branch  4 never executed
branch  5 never executed (fallthrough)
    #####: 3382:      if (!stbi__process_marker(z,m)) return 0;
    %%%%%: 3382-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3382-block 11
    #####: 3383:      m = stbi__get_marker(z);
    %%%%%: 3383-block 12
call    0 never executed
    #####: 3384:      while (m == STBI__MARKER_none) {
    %%%%%: 3384-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3385:         // some files have extra padding after their blocks, so ok, we'll scan
    #####: 3386:         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
    %%%%%: 3386-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3386-block 16
call    3 never executed
    #####: 3387:         m = stbi__get_marker(z);
    %%%%%: 3387-block 17
call    0 never executed
        -: 3388:      }
        -: 3389:   }
    #####: 3390:   z->progressive = stbi__SOF_progressive(m);
    #####: 3391:   if (!stbi__process_frame_header(z, scan)) return 0;
    %%%%%: 3391-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3391-block 25
    #####: 3392:   return 1;
    %%%%%: 3392-block 26
        -: 3393:}
        -: 3394:
function _ZL27stbi__skip_jpeg_junk_at_endP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3395:static stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
        -: 3396:{
        -: 3397:   // some JPEGs have junk at end, skip over it but if we find what looks
        -: 3398:   // like a valid marker, resume there
    #####: 3399:   while (!stbi__at_eof(j->s)) {
    %%%%%: 3399-block 2
    %%%%%: 3399-block 13
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 3400:      stbi_uc x = stbi__get8(j->s);
    %%%%%: 3400-block 3
call    0 never executed
    #####: 3401:      while (x == 0xff) { // might be a marker
    %%%%%: 3401-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3402:         if (stbi__at_eof(j->s)) return STBI__MARKER_none;
    %%%%%: 3402-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3402-block 7
    #####: 3403:         x = stbi__get8(j->s);
    %%%%%: 3403-block 8
call    0 never executed
    #####: 3404:         if (x != 0x00 && x != 0xff) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3404-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3405:            // not a stuffed zero or lead-in to another marker, looks
        -: 3406:            // like an actual marker, return it
    #####: 3407:            return x;
    %%%%%: 3407-block 11
        -: 3408:         }
        -: 3409:         // stuffed zero has x=0 now which ends the loop, meaning we go
        -: 3410:         // back to regular scan loop.
        -: 3411:         // repeated 0xff keeps trying to read the next byte of the marker.
        -: 3412:      }
        -: 3413:   }
    #####: 3414:   return STBI__MARKER_none;
    %%%%%: 3414-block 15
        -: 3415:}
        -: 3416:
        -: 3417:// decode image to YCbCr format
function _ZL23stbi__decode_jpeg_imageP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3418:static int stbi__decode_jpeg_image(stbi__jpeg *j)
        -: 3419:{
        -: 3420:   int m;
    #####: 3421:   for (m = 0; m < 4; m++) {
    %%%%%: 3421-block 2
    %%%%%: 3421-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3422:      j->img_comp[m].raw_data = NULL;
    #####: 3423:      j->img_comp[m].raw_coeff = NULL;
    %%%%%: 3423-block 3
        -: 3424:   }
    #####: 3425:   j->restart_interval = 0;
    #####: 3426:   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
    %%%%%: 3426-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3426-block 7
    #####: 3427:   m = stbi__get_marker(j);
    %%%%%: 3427-block 8
call    0 never executed
    #####: 3428:   while (!stbi__EOI(m)) {
    %%%%%: 3428-block 39
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3429:      if (stbi__SOS(m)) {
    %%%%%: 3429-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3430:         if (!stbi__process_scan_header(j)) return 0;
    %%%%%: 3430-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3430-block 13
    #####: 3431:         if (!stbi__parse_entropy_coded_data(j)) return 0;
    %%%%%: 3431-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3431-block 16
    #####: 3432:         if (j->marker == STBI__MARKER_none ) {
    %%%%%: 3432-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3433:         j->marker = stbi__skip_jpeg_junk_at_end(j);
    %%%%%: 3433-block 18
call    0 never executed
        -: 3434:            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
        -: 3435:         }
    #####: 3436:         m = stbi__get_marker(j);
    %%%%%: 3436-block 20
call    0 never executed
    #####: 3437:         if (STBI__RESTART(m))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3437-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3438:            m = stbi__get_marker(j);
    %%%%%: 3438-block 23
call    0 never executed
    #####: 3439:      } else if (stbi__DNL(m)) {
    %%%%%: 3439-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3440:         int Ld = stbi__get16be(j->s);
    %%%%%: 3440-block 26
call    0 never executed
    #####: 3441:         stbi__uint32 NL = stbi__get16be(j->s);
call    0 never executed
    #####: 3442:         if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3442-block 29
call    2 never executed
    #####: 3443:         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
    %%%%%: 3443-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3443-block 31
call    2 never executed
    #####: 3444:         m = stbi__get_marker(j);
    %%%%%: 3444-block 32
call    0 never executed
        -: 3445:      } else {
    #####: 3446:         if (!stbi__process_marker(j, m)) return 1;
    %%%%%: 3446-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3446-block 36
    #####: 3447:         m = stbi__get_marker(j);
    %%%%%: 3447-block 37
call    0 never executed
        -: 3448:      }
        -: 3449:   }
    #####: 3450:   if (j->progressive)
    %%%%%: 3450-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3451:      stbi__jpeg_finish(j);
    %%%%%: 3451-block 41
call    0 never executed
    #####: 3452:   return 1;
    %%%%%: 3452-block 42
        -: 3453:}
        -: 3454:
        -: 3455:// static jfif-centered resampling (across block boundaries)
        -: 3456:
        -: 3457:typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
        -: 3458:                                    int w, int hs);
        -: 3459:
        -: 3460:#define stbi__div4(x) ((stbi_uc) ((x) >> 2))
        -: 3461:
function _ZL14resample_row_1PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3462:static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3463:{
        -: 3464:   STBI_NOTUSED(out);
        -: 3465:   STBI_NOTUSED(in_far);
        -: 3466:   STBI_NOTUSED(w);
        -: 3467:   STBI_NOTUSED(hs);
    #####: 3468:   return in_near;
    %%%%%: 3468-block 2
        -: 3469:}
        -: 3470:
function _ZL22stbi__resample_row_v_2PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3471:static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3472:{
        -: 3473:   // need to generate two samples vertically for every one in input
        -: 3474:   int i;
        -: 3475:   STBI_NOTUSED(hs);
    #####: 3476:   for (i=0; i < w; ++i)
    %%%%%: 3476-block 2
    %%%%%: 3476-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3477:      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
    %%%%%: 3477-block 3
    #####: 3478:   return out;
    %%%%%: 3478-block 5
        -: 3479:}
        -: 3480:
function _ZL22stbi__resample_row_h_2PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3481:static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3482:{
        -: 3483:   // need to generate two samples horizontally for every one in input
        -: 3484:   int i;
    #####: 3485:   stbi_uc *input = in_near;
        -: 3486:
    #####: 3487:   if (w == 1) {
    %%%%%: 3487-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3488:      // if only one sample, can't do any interpolation
    #####: 3489:      out[0] = out[1] = input[0];
    #####: 3490:      return out;
    %%%%%: 3490-block 3
        -: 3491:   }
        -: 3492:
    #####: 3493:   out[0] = input[0];
    #####: 3494:   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
    #####: 3495:   for (i=1; i < w-1; ++i) {
    %%%%%: 3495-block 4
    %%%%%: 3495-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3496:      int n = 3*input[i]+2;
    #####: 3497:      out[i*2+0] = stbi__div4(n+input[i-1]);
    #####: 3498:      out[i*2+1] = stbi__div4(n+input[i+1]);
    %%%%%: 3498-block 5
        -: 3499:   }
    #####: 3500:   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
    #####: 3501:   out[i*2+1] = input[w-1];
        -: 3502:
        -: 3503:   STBI_NOTUSED(in_far);
        -: 3504:   STBI_NOTUSED(hs);
        -: 3505:
    #####: 3506:   return out;
    %%%%%: 3506-block 7
        -: 3507:}
        -: 3508:
        -: 3509:#define stbi__div16(x) ((stbi_uc) ((x) >> 4))
        -: 3510:
function _ZL23stbi__resample_row_hv_2PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3511:static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3512:{
        -: 3513:   // need to generate 2x2 samples for every one in input
        -: 3514:   int i,t0,t1;
    #####: 3515:   if (w == 1) {
    %%%%%: 3515-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3516:      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
    #####: 3517:      return out;
    %%%%%: 3517-block 3
        -: 3518:   }
        -: 3519:
    #####: 3520:   t1 = 3*in_near[0] + in_far[0];
    #####: 3521:   out[0] = stbi__div4(t1+2);
    #####: 3522:   for (i=1; i < w; ++i) {
    %%%%%: 3522-block 4
    %%%%%: 3522-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3523:      t0 = t1;
    #####: 3524:      t1 = 3*in_near[i]+in_far[i];
    #####: 3525:      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
    #####: 3526:      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
    %%%%%: 3526-block 5
        -: 3527:   }
    #####: 3528:   out[w*2-1] = stbi__div4(t1+2);
        -: 3529:
        -: 3530:   STBI_NOTUSED(hs);
        -: 3531:
    #####: 3532:   return out;
    %%%%%: 3532-block 7
        -: 3533:}
        -: 3534:
        -: 3535:#if defined(STBI_SSE2) || defined(STBI_NEON)
function _ZL28stbi__resample_row_hv_2_simdPhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3536:static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3537:{
        -: 3538:   // need to generate 2x2 samples for every one in input
    #####: 3539:   int i=0,t0,t1;
        -: 3540:
    #####: 3541:   if (w == 1) {
    %%%%%: 3541-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3542:      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
    #####: 3543:      return out;
    %%%%%: 3543-block 3
        -: 3544:   }
        -: 3545:
    #####: 3546:   t1 = 3*in_near[0] + in_far[0];
        -: 3547:   // process groups of 8 pixels for as long as we can.
        -: 3548:   // note we can't handle the last pixel in a row in this loop
        -: 3549:   // because we need to handle the filter boundary conditions.
    #####: 3550:   for (; i < ((w-1) & ~7); i += 8) {
    %%%%%: 3550-block 4
    %%%%%: 3550-block 57
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3551:#if defined(STBI_SSE2)
        -: 3552:      // load and perform the vertical filtering pass
        -: 3553:      // this uses 3*x + y = 4*x + (y - x)
    #####: 3554:      __m128i zero  = _mm_setzero_si128();
    #####: 3555:      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
    %%%%%: 3555-block 7
    #####: 3556:      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
    %%%%%: 3556-block 13
    %%%%%: 3556-block 19
    #####: 3557:      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
    %%%%%: 3557-block 21
    #####: 3558:      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
    %%%%%: 3558-block 23
    #####: 3559:      __m128i diff  = _mm_sub_epi16(farw, nearw);
    %%%%%: 3559-block 25
    #####: 3560:      __m128i nears = _mm_slli_epi16(nearw, 2);
    %%%%%: 3560-block 27
    #####: 3561:      __m128i curr  = _mm_add_epi16(nears, diff); // current row
        -: 3562:
        -: 3563:      // horizontal filter works the same based on shifted vers of current
        -: 3564:      // row. "prev" is current row shifted right by 1 pixel; we need to
        -: 3565:      // insert the previous pixel value (from t1).
        -: 3566:      // "next" is current row shifted left by 1 pixel, with first pixel
        -: 3567:      // of next block of 8 pixels added in.
    #####: 3568:      __m128i prv0 = _mm_slli_si128(curr, 2);
    #####: 3569:      __m128i nxt0 = _mm_srli_si128(curr, 2);
    #####: 3570:      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
    #####: 3571:      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
    %%%%%: 3571-block 29
        -: 3572:
        -: 3573:      // horizontal filter, polyphase implementation since it's convenient:
        -: 3574:      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
        -: 3575:      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
        -: 3576:      // note the shared term.
    #####: 3577:      __m128i bias  = _mm_set1_epi16(8);
    %%%%%: 3577-block 33
    #####: 3578:      __m128i curs = _mm_slli_epi16(curr, 2);
    %%%%%: 3578-block 35
    #####: 3579:      __m128i prvd = _mm_sub_epi16(prev, curr);
    %%%%%: 3579-block 37
    #####: 3580:      __m128i nxtd = _mm_sub_epi16(next, curr);
    %%%%%: 3580-block 39
    #####: 3581:      __m128i curb = _mm_add_epi16(curs, bias);
    %%%%%: 3581-block 41
    #####: 3582:      __m128i even = _mm_add_epi16(prvd, curb);
    %%%%%: 3582-block 43
    #####: 3583:      __m128i odd  = _mm_add_epi16(nxtd, curb);
    %%%%%: 3583-block 45
        -: 3584:
        -: 3585:      // interleave even and odd pixels, then undo scaling.
    #####: 3586:      __m128i int0 = _mm_unpacklo_epi16(even, odd);
    %%%%%: 3586-block 47
    #####: 3587:      __m128i int1 = _mm_unpackhi_epi16(even, odd);
    %%%%%: 3587-block 49
    #####: 3588:      __m128i de0  = _mm_srli_epi16(int0, 4);
    %%%%%: 3588-block 51
    #####: 3589:      __m128i de1  = _mm_srli_epi16(int1, 4);
    %%%%%: 3589-block 53
        -: 3590:
        -: 3591:      // pack and write output
    #####: 3592:      __m128i outv = _mm_packus_epi16(de0, de1);
    #####: 3593:      _mm_storeu_si128((__m128i *) (out + i*2), outv);
    %%%%%: 3593-block 55
        -: 3594:#elif defined(STBI_NEON)
        -: 3595:      // load and perform the vertical filtering pass
        -: 3596:      // this uses 3*x + y = 4*x + (y - x)
        -: 3597:      uint8x8_t farb  = vld1_u8(in_far + i);
        -: 3598:      uint8x8_t nearb = vld1_u8(in_near + i);
        -: 3599:      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
        -: 3600:      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
        -: 3601:      int16x8_t curr  = vaddq_s16(nears, diff); // current row
        -: 3602:
        -: 3603:      // horizontal filter works the same based on shifted vers of current
        -: 3604:      // row. "prev" is current row shifted right by 1 pixel; we need to
        -: 3605:      // insert the previous pixel value (from t1).
        -: 3606:      // "next" is current row shifted left by 1 pixel, with first pixel
        -: 3607:      // of next block of 8 pixels added in.
        -: 3608:      int16x8_t prv0 = vextq_s16(curr, curr, 7);
        -: 3609:      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
        -: 3610:      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
        -: 3611:      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
        -: 3612:
        -: 3613:      // horizontal filter, polyphase implementation since it's convenient:
        -: 3614:      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
        -: 3615:      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
        -: 3616:      // note the shared term.
        -: 3617:      int16x8_t curs = vshlq_n_s16(curr, 2);
        -: 3618:      int16x8_t prvd = vsubq_s16(prev, curr);
        -: 3619:      int16x8_t nxtd = vsubq_s16(next, curr);
        -: 3620:      int16x8_t even = vaddq_s16(curs, prvd);
        -: 3621:      int16x8_t odd  = vaddq_s16(curs, nxtd);
        -: 3622:
        -: 3623:      // undo scaling and round, then store with even/odd phases interleaved
        -: 3624:      uint8x8x2_t o;
        -: 3625:      o.val[0] = vqrshrun_n_s16(even, 4);
        -: 3626:      o.val[1] = vqrshrun_n_s16(odd,  4);
        -: 3627:      vst2_u8(out + i*2, o);
        -: 3628:#endif
        -: 3629:
        -: 3630:      // "previous" value for next iter
    #####: 3631:      t1 = 3*in_near[i+7] + in_far[i+7];
    %%%%%: 3631-block 56
        -: 3632:   }
        -: 3633:
    #####: 3634:   t0 = t1;
    #####: 3635:   t1 = 3*in_near[i] + in_far[i];
    #####: 3636:   out[i*2] = stbi__div16(3*t1 + t0 + 8);
        -: 3637:
    #####: 3638:   for (++i; i < w; ++i) {
    %%%%%: 3638-block 58
    %%%%%: 3638-block 60
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3639:      t0 = t1;
    #####: 3640:      t1 = 3*in_near[i]+in_far[i];
    #####: 3641:      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
    #####: 3642:      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
    %%%%%: 3642-block 59
        -: 3643:   }
    #####: 3644:   out[w*2-1] = stbi__div4(t1+2);
        -: 3645:
        -: 3646:   STBI_NOTUSED(hs);
        -: 3647:
    #####: 3648:   return out;
    %%%%%: 3648-block 61
        -: 3649:}
        -: 3650:#endif
        -: 3651:
function _ZL26stbi__resample_row_genericPhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3652:static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3653:{
        -: 3654:   // resample with nearest-neighbor
        -: 3655:   int i,j;
        -: 3656:   STBI_NOTUSED(in_far);
    #####: 3657:   for (i=0; i < w; ++i)
    %%%%%: 3657-block 2
    %%%%%: 3657-block 6
    %%%%%: 3657-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3658:      for (j=0; j < hs; ++j)
    %%%%%: 3658-block 3
    %%%%%: 3658-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3659:         out[i*hs+j] = in_near[i];
    %%%%%: 3659-block 4
    #####: 3660:   return out;
    %%%%%: 3660-block 8
        -: 3661:}
        -: 3662:
        -: 3663:// this is a reduced-precision calculation of YCbCr-to-RGB introduced
        -: 3664:// to make sure the code produces the same results in both SIMD and scalar
        -: 3665:#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
function _ZL22stbi__YCbCr_to_RGB_rowPhPKhS1_S1_ii called 0 returned 0% blocks executed 0%
    #####: 3666:static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
        -: 3667:{
        -: 3668:   int i;
    #####: 3669:   for (i=0; i < count; ++i) {
    %%%%%: 3669-block 2
    %%%%%: 3669-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3670:      int y_fixed = (y[i] << 20) + (1<<19); // rounding
        -: 3671:      int r,g,b;
    #####: 3672:      int cr = pcr[i] - 128;
    #####: 3673:      int cb = pcb[i] - 128;
    #####: 3674:      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
    #####: 3675:      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
    #####: 3676:      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
    #####: 3677:      r >>= 20;
    #####: 3678:      g >>= 20;
    #####: 3679:      b >>= 20;
    #####: 3680:      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
    %%%%%: 3680-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3680-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3680-block 5
    %%%%%: 3680-block 6
    #####: 3681:      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
    %%%%%: 3681-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3681-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3681-block 9
    %%%%%: 3681-block 10
    #####: 3682:      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
    %%%%%: 3682-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3682-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3682-block 13
    %%%%%: 3682-block 14
    #####: 3683:      out[0] = (stbi_uc)r;
    #####: 3684:      out[1] = (stbi_uc)g;
    #####: 3685:      out[2] = (stbi_uc)b;
    #####: 3686:      out[3] = 255;
    #####: 3687:      out += step;
    %%%%%: 3687-block 15
        -: 3688:   }
    #####: 3689:}
        -: 3690:
        -: 3691:#if defined(STBI_SSE2) || defined(STBI_NEON)
function _ZL23stbi__YCbCr_to_RGB_simdPhPKhS1_S1_ii called 0 returned 0% blocks executed 0%
    #####: 3692:static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
        -: 3693:{
    #####: 3694:   int i = 0;
        -: 3695:
        -: 3696:#ifdef STBI_SSE2
        -: 3697:   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
        -: 3698:   // it's useful in practice (you wouldn't use it for textures, for example).
        -: 3699:   // so just accelerate step == 4 case.
    #####: 3700:   if (step == 4) {
    %%%%%: 3700-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3701:      // this is a fairly straightforward implementation and not super-optimized.
    #####: 3702:      __m128i signflip  = _mm_set1_epi8(-0x80);
    %%%%%: 3702-block 7
    #####: 3703:      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
    %%%%%: 3703-block 11
    #####: 3704:      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
    %%%%%: 3704-block 15
    #####: 3705:      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
    %%%%%: 3705-block 19
    #####: 3706:      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
    %%%%%: 3706-block 23
    #####: 3707:      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
    %%%%%: 3707-block 27
    #####: 3708:      __m128i xw = _mm_set1_epi16(255); // alpha channel
        -: 3709:
    #####: 3710:      for (; i+7 < count; i += 8) {
    %%%%%: 3710-block 31
    %%%%%: 3710-block 103
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3711:         // load
    #####: 3712:         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
    %%%%%: 3712-block 32
    #####: 3713:         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
    %%%%%: 3713-block 38
    #####: 3714:         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
    %%%%%: 3714-block 44
    %%%%%: 3714-block 50
    #####: 3715:         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
    %%%%%: 3715-block 52
    #####: 3716:         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
    %%%%%: 3716-block 54
        -: 3717:
        -: 3718:         // unpack to short (and left-shift cr, cb by 8)
    #####: 3719:         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
    %%%%%: 3719-block 56
    #####: 3720:         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
    %%%%%: 3720-block 58
    %%%%%: 3720-block 60
    #####: 3721:         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
    %%%%%: 3721-block 62
    %%%%%: 3721-block 64
        -: 3722:
        -: 3723:         // color transform
    #####: 3724:         __m128i yws = _mm_srli_epi16(yw, 4);
    %%%%%: 3724-block 66
    #####: 3725:         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
    %%%%%: 3725-block 68
    #####: 3726:         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
    %%%%%: 3726-block 70
    #####: 3727:         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
    %%%%%: 3727-block 72
    #####: 3728:         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
    %%%%%: 3728-block 74
    #####: 3729:         __m128i rws = _mm_add_epi16(cr0, yws);
    %%%%%: 3729-block 76
    #####: 3730:         __m128i gwt = _mm_add_epi16(cb0, yws);
    %%%%%: 3730-block 78
    #####: 3731:         __m128i bws = _mm_add_epi16(yws, cb1);
    %%%%%: 3731-block 80
    #####: 3732:         __m128i gws = _mm_add_epi16(gwt, cr1);
    %%%%%: 3732-block 82
        -: 3733:
        -: 3734:         // descale
    #####: 3735:         __m128i rw = _mm_srai_epi16(rws, 4);
    %%%%%: 3735-block 84
    #####: 3736:         __m128i bw = _mm_srai_epi16(bws, 4);
    %%%%%: 3736-block 86
    #####: 3737:         __m128i gw = _mm_srai_epi16(gws, 4);
    %%%%%: 3737-block 88
        -: 3738:
        -: 3739:         // back to byte, set up for transpose
    #####: 3740:         __m128i brb = _mm_packus_epi16(rw, bw);
    %%%%%: 3740-block 90
    #####: 3741:         __m128i gxb = _mm_packus_epi16(gw, xw);
    %%%%%: 3741-block 92
        -: 3742:
        -: 3743:         // transpose to interleave channels
    #####: 3744:         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
    %%%%%: 3744-block 94
    #####: 3745:         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
    %%%%%: 3745-block 96
    #####: 3746:         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
    %%%%%: 3746-block 98
    #####: 3747:         __m128i o1 = _mm_unpackhi_epi16(t0, t1);
    %%%%%: 3747-block 100
        -: 3748:
        -: 3749:         // store
        -: 3750:         _mm_storeu_si128((__m128i *) (out + 0), o0);
    #####: 3751:         _mm_storeu_si128((__m128i *) (out + 16), o1);
    %%%%%: 3751-block 101
    #####: 3752:         out += 32;
    %%%%%: 3752-block 102
        -: 3753:      }
        -: 3754:   }
        -: 3755:#endif
        -: 3756:
        -: 3757:#ifdef STBI_NEON
        -: 3758:   // in this version, step=3 support would be easy to add. but is there demand?
        -: 3759:   if (step == 4) {
        -: 3760:      // this is a fairly straightforward implementation and not super-optimized.
        -: 3761:      uint8x8_t signflip = vdup_n_u8(0x80);
        -: 3762:      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
        -: 3763:      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
        -: 3764:      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
        -: 3765:      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
        -: 3766:
        -: 3767:      for (; i+7 < count; i += 8) {
        -: 3768:         // load
        -: 3769:         uint8x8_t y_bytes  = vld1_u8(y + i);
        -: 3770:         uint8x8_t cr_bytes = vld1_u8(pcr + i);
        -: 3771:         uint8x8_t cb_bytes = vld1_u8(pcb + i);
        -: 3772:         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
        -: 3773:         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
        -: 3774:
        -: 3775:         // expand to s16
        -: 3776:         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
        -: 3777:         int16x8_t crw = vshll_n_s8(cr_biased, 7);
        -: 3778:         int16x8_t cbw = vshll_n_s8(cb_biased, 7);
        -: 3779:
        -: 3780:         // color transform
        -: 3781:         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
        -: 3782:         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
        -: 3783:         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
        -: 3784:         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
        -: 3785:         int16x8_t rws = vaddq_s16(yws, cr0);
        -: 3786:         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
        -: 3787:         int16x8_t bws = vaddq_s16(yws, cb1);
        -: 3788:
        -: 3789:         // undo scaling, round, convert to byte
        -: 3790:         uint8x8x4_t o;
        -: 3791:         o.val[0] = vqrshrun_n_s16(rws, 4);
        -: 3792:         o.val[1] = vqrshrun_n_s16(gws, 4);
        -: 3793:         o.val[2] = vqrshrun_n_s16(bws, 4);
        -: 3794:         o.val[3] = vdup_n_u8(255);
        -: 3795:
        -: 3796:         // store, interleaving r/g/b/a
        -: 3797:         vst4_u8(out, o);
        -: 3798:         out += 8*4;
        -: 3799:      }
        -: 3800:   }
        -: 3801:#endif
        -: 3802:
    #####: 3803:   for (; i < count; ++i) {
    %%%%%: 3803-block 104
    %%%%%: 3803-block 118
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3804:      int y_fixed = (y[i] << 20) + (1<<19); // rounding
        -: 3805:      int r,g,b;
    #####: 3806:      int cr = pcr[i] - 128;
    #####: 3807:      int cb = pcb[i] - 128;
    #####: 3808:      r = y_fixed + cr* stbi__float2fixed(1.40200f);
    #####: 3809:      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
    #####: 3810:      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
    #####: 3811:      r >>= 20;
    #####: 3812:      g >>= 20;
    #####: 3813:      b >>= 20;
    #####: 3814:      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
    %%%%%: 3814-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3814-block 106
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3814-block 107
    %%%%%: 3814-block 108
    #####: 3815:      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
    %%%%%: 3815-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3815-block 110
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3815-block 111
    %%%%%: 3815-block 112
    #####: 3816:      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
    %%%%%: 3816-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3816-block 114
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3816-block 115
    %%%%%: 3816-block 116
    #####: 3817:      out[0] = (stbi_uc)r;
    #####: 3818:      out[1] = (stbi_uc)g;
    #####: 3819:      out[2] = (stbi_uc)b;
    #####: 3820:      out[3] = 255;
    #####: 3821:      out += step;
    %%%%%: 3821-block 117
        -: 3822:   }
    #####: 3823:}
        -: 3824:#endif
        -: 3825:
        -: 3826:// set up the kernels
function _ZL16stbi__setup_jpegP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3827:static void stbi__setup_jpeg(stbi__jpeg *j)
        -: 3828:{
    #####: 3829:   j->idct_block_kernel = stbi__idct_block;
    #####: 3830:   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
    #####: 3831:   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
        -: 3832:
        -: 3833:#ifdef STBI_SSE2
    #####: 3834:   if (stbi__sse2_available()) {
    %%%%%: 3834-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3835:      j->idct_block_kernel = stbi__idct_simd;
    #####: 3836:      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
    #####: 3837:      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
    %%%%%: 3837-block 4
        -: 3838:   }
        -: 3839:#endif
        -: 3840:
        -: 3841:#ifdef STBI_NEON
        -: 3842:   j->idct_block_kernel = stbi__idct_simd;
        -: 3843:   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
        -: 3844:   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
        -: 3845:#endif
    #####: 3846:}
        -: 3847:
        -: 3848:// clean up the temporary component buffers
function _ZL18stbi__cleanup_jpegP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3849:static void stbi__cleanup_jpeg(stbi__jpeg *j)
        -: 3850:{
    #####: 3851:   stbi__free_jpeg_components(j, j->s->img_n, 0);
    %%%%%: 3851-block 2
call    0 never executed
    #####: 3852:}
        -: 3853:
        -: 3854:typedef struct
        -: 3855:{
        -: 3856:   resample_row_func resample;
        -: 3857:   stbi_uc *line0,*line1;
        -: 3858:   int hs,vs;   // expansion factor in each axis
        -: 3859:   int w_lores; // horizontal pixels pre-expansion
        -: 3860:   int ystep;   // how far through vertical expansion we are
        -: 3861:   int ypos;    // which pre-expansion row we're on
        -: 3862:} stbi__resample;
        -: 3863:
        -: 3864:// fast 0..255 * 0..255 => 0..255 rounded multiplication
function _ZL15stbi__blinn_8x8hh called 0 returned 0% blocks executed 0%
    #####: 3865:static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
        -: 3866:{
    #####: 3867:   unsigned int t = x*y + 128;
    #####: 3868:   return (stbi_uc) ((t + (t >>8)) >> 8);
    %%%%%: 3868-block 2
        -: 3869:}
        -: 3870:
function _ZL15load_jpeg_imageP10stbi__jpegPiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 3871:static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
        -: 3872:{
        -: 3873:   int n, decode_n, is_rgb;
    #####: 3874:   z->s->img_n = 0; // make stbi__cleanup_jpeg safe
        -: 3875:
        -: 3876:   // validate req_comp
    #####: 3877:   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
    %%%%%: 3877-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3877-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3877-block 4
call    4 never executed
        -: 3878:
        -: 3879:   // load a jpeg image from whichever source, but leave in YCbCr format
    #####: 3880:   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
    %%%%%: 3880-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3880-block 8
call    3 never executed
        -: 3881:
        -: 3882:   // determine actual number of components to generate
    #####: 3883:   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
    %%%%%: 3883-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3883-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3883-block 12
    %%%%%: 3883-block 13
    %%%%%: 3883-block 14
    %%%%%: 3883-block 15
        -: 3884:
    #####: 3885:   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
    %%%%%: 3885-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3885-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3885-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3885-block 19
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3885-block 20
    %%%%%: 3885-block 21
        -: 3886:
    #####: 3887:   if (z->s->img_n == 3 && n < 3 && !is_rgb)
    %%%%%: 3887-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3887-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3887-block 24
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3888:      decode_n = 1;
    %%%%%: 3888-block 25
        -: 3889:   else
    #####: 3890:      decode_n = z->s->img_n;
    %%%%%: 3890-block 26
        -: 3891:
        -: 3892:   // nothing to do if no components requested; check this now to avoid
        -: 3893:   // accessing uninitialized coutput[0] later
    #####: 3894:   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
    %%%%%: 3894-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3894-block 28
call    2 never executed
        -: 3895:
        -: 3896:   // resample and color-convert
        -: 3897:   {
        -: 3898:      int k;
        -: 3899:      unsigned int i,j;
        -: 3900:      stbi_uc *output;
    #####: 3901:      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
        -: 3902:
        -: 3903:      stbi__resample res_comp[4];
        -: 3904:
    #####: 3905:      for (k=0; k < decode_n; ++k) {
    %%%%%: 3905-block 30
    %%%%%: 3905-block 49
    %%%%%: 3905-block 50
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3906:         stbi__resample *r = &res_comp[k];
        -: 3907:
        -: 3908:         // allocate line buffer big enough for upsampling off the edges
        -: 3909:         // with upsample factor of 4
    #####: 3910:         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
    %%%%%: 3910-block 31
call    0 never executed
    #####: 3911:         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3911-block 33
call    2 never executed
call    3 never executed
        -: 3912:
    #####: 3913:         r->hs      = z->img_h_max / z->img_comp[k].h;
    #####: 3914:         r->vs      = z->img_v_max / z->img_comp[k].v;
    #####: 3915:         r->ystep   = r->vs >> 1;
    #####: 3916:         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
    #####: 3917:         r->ypos    = 0;
    #####: 3918:         r->line0   = r->line1 = z->img_comp[k].data;
        -: 3919:
    #####: 3920:         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
    %%%%%: 3920-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3920-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3920-block 38
    #####: 3921:         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
    %%%%%: 3921-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3921-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3921-block 41
    #####: 3922:         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
    %%%%%: 3922-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3922-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3922-block 44
    #####: 3923:         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
    %%%%%: 3923-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3923-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3923-block 47
    #####: 3924:         else                               r->resample = stbi__resample_row_generic;
    %%%%%: 3924-block 48
        -: 3925:      }
        -: 3926:
        -: 3927:      // can't error after this so, this is safe
    #####: 3928:      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
    %%%%%: 3928-block 51
call    0 never executed
    #####: 3929:      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3929-block 53
call    2 never executed
call    3 never executed
        -: 3930:
        -: 3931:      // now go ahead and resample
    #####: 3932:      for (j=0; j < z->s->img_y; ++j) {
    %%%%%: 3932-block 56
    %%%%%: 3932-block 131
    %%%%%: 3932-block 132
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3933:         stbi_uc *out = output + n * z->s->img_x * j;
    #####: 3934:         for (k=0; k < decode_n; ++k) {
    %%%%%: 3934-block 57
    %%%%%: 3934-block 68
    %%%%%: 3934-block 69
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3935:            stbi__resample *r = &res_comp[k];
    #####: 3936:            int y_bot = r->ystep >= (r->vs >> 1);
    #####: 3937:            coutput[k] = r->resample(z->img_comp[k].linebuf,
    %%%%%: 3937-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3937-block 59
    %%%%%: 3937-block 60
    %%%%%: 3937-block 61
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3937-block 62
    %%%%%: 3937-block 63
    %%%%%: 3937-block 64
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        -: 3938:                                     y_bot ? r->line1 : r->line0,
        -: 3939:                                     y_bot ? r->line0 : r->line1,
        -: 3940:                                     r->w_lores, r->hs);
    #####: 3941:            if (++r->ystep >= r->vs) {
    %%%%%: 3941-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3942:               r->ystep = 0;
    #####: 3943:               r->line0 = r->line1;
    #####: 3944:               if (++r->ypos < z->img_comp[k].y)
    %%%%%: 3944-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3945:                  r->line1 += z->img_comp[k].w2;
    %%%%%: 3945-block 67
        -: 3946:            }
        -: 3947:         }
    #####: 3948:         if (n >= 3) {
    %%%%%: 3948-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3949:            stbi_uc *y = coutput[0];
    #####: 3950:            if (z->s->img_n == 3) {
    %%%%%: 3950-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3951:               if (is_rgb) {
    %%%%%: 3951-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3952:                  for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3952-block 73
    %%%%%: 3952-block 75
branch  0 never executed
branch  1 never executed
    #####: 3953:                     out[0] = y[i];
    #####: 3954:                     out[1] = coutput[1][i];
    #####: 3955:                     out[2] = coutput[2][i];
    #####: 3956:                     out[3] = 255;
    #####: 3957:                     out += n;
    %%%%%: 3957-block 74
        -: 3958:                  }
        -: 3959:               } else {
    #####: 3960:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
    %%%%%: 3960-block 76
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3961:               }
    #####: 3962:            } else if (z->s->img_n == 4) {
    %%%%%: 3962-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3963:               if (z->app14_color_transform == 0) { // CMYK
    %%%%%: 3963-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3964:                  for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3964-block 79
    %%%%%: 3964-block 84
branch  0 never executed
branch  1 never executed
    #####: 3965:                     stbi_uc m = coutput[3][i];
    #####: 3966:                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
    %%%%%: 3966-block 80
call    0 never executed
    #####: 3967:                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
call    0 never executed
    #####: 3968:                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
call    0 never executed
    #####: 3969:                     out[3] = 255;
    #####: 3970:                     out += n;
        -: 3971:                  }
    #####: 3972:               } else if (z->app14_color_transform == 2) { // YCCK
    %%%%%: 3972-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3973:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
    %%%%%: 3973-block 86
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3974:                  for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3974-block 87
    %%%%%: 3974-block 92
branch  0 never executed
branch  1 never executed
    #####: 3975:                     stbi_uc m = coutput[3][i];
    #####: 3976:                     out[0] = stbi__blinn_8x8(255 - out[0], m);
    %%%%%: 3976-block 88
call    0 never executed
    #####: 3977:                     out[1] = stbi__blinn_8x8(255 - out[1], m);
call    0 never executed
    #####: 3978:                     out[2] = stbi__blinn_8x8(255 - out[2], m);
call    0 never executed
    #####: 3979:                     out += n;
        -: 3980:                  }
        -: 3981:               } else { // YCbCr + alpha?  Ignore the fourth channel for now
    #####: 3982:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
    %%%%%: 3982-block 93
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3983:               }
        -: 3984:            } else
    #####: 3985:               for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3985-block 94
    %%%%%: 3985-block 96
branch  0 never executed
branch  1 never executed
    #####: 3986:                  out[0] = out[1] = out[2] = y[i];
    #####: 3987:                  out[3] = 255; // not used if n==3
    #####: 3988:                  out += n;
    %%%%%: 3988-block 95
        -: 3989:               }
        -: 3990:         } else {
    #####: 3991:            if (is_rgb) {
    %%%%%: 3991-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3992:               if (n == 1)
    %%%%%: 3992-block 98
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3993:                  for (i=0; i < z->s->img_x; ++i)
    %%%%%: 3993-block 99
    %%%%%: 3993-block 102
branch  0 never executed
branch  1 never executed
    #####: 3994:                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
    %%%%%: 3994-block 100
call    0 never executed
        -: 3995:               else {
    #####: 3996:                  for (i=0; i < z->s->img_x; ++i, out += 2) {
    %%%%%: 3996-block 103
    %%%%%: 3996-block 106
branch  0 never executed
branch  1 never executed
    #####: 3997:                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
    %%%%%: 3997-block 104
call    0 never executed
    #####: 3998:                     out[1] = 255;
        -: 3999:                  }
        -: 4000:               }
    #####: 4001:            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
    %%%%%: 4001-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4001-block 108
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4002:               for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 4002-block 109
    %%%%%: 4002-block 115
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4003:                  stbi_uc m = coutput[3][i];
    #####: 4004:                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
    %%%%%: 4004-block 110
call    0 never executed
    #####: 4005:                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
call    0 never executed
    #####: 4006:                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
call    0 never executed
    #####: 4007:                  out[0] = stbi__compute_y(r, g, b);
call    0 never executed
    #####: 4008:                  out[1] = 255;
    #####: 4009:                  out += n;
        -: 4010:               }
    #####: 4011:            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
    %%%%%: 4011-block 116
    %%%%%: 4011-block 117
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4011-block 118
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4012:               for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 4012-block 119
    %%%%%: 4012-block 122
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4013:                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
    %%%%%: 4013-block 120
call    0 never executed
    #####: 4014:                  out[1] = 255;
    #####: 4015:                  out += n;
        -: 4016:               }
        -: 4017:            } else {
    #####: 4018:               stbi_uc *y = coutput[0];
    #####: 4019:               if (n == 1)
    %%%%%: 4019-block 124
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4020:                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
    %%%%%: 4020-block 125
    %%%%%: 4020-block 126
    %%%%%: 4020-block 127
branch  0 never executed
branch  1 never executed
        -: 4021:               else
    #####: 4022:                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
    %%%%%: 4022-block 128
    %%%%%: 4022-block 129
    %%%%%: 4022-block 130
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4023:            }
        -: 4024:         }
        -: 4025:      }
    #####: 4026:      stbi__cleanup_jpeg(z);
    %%%%%: 4026-block 133
call    0 never executed
    #####: 4027:      *out_x = z->s->img_x;
    #####: 4028:      *out_y = z->s->img_y;
    #####: 4029:      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4029-block 135
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4029-block 136
    %%%%%: 4029-block 137
    %%%%%: 4029-block 138
    #####: 4030:      return output;
    %%%%%: 4030-block 139
        -: 4031:   }
        -: 4032:}
        -: 4033:
function _ZL15stbi__jpeg_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 4034:static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 4035:{
        -: 4036:   unsigned char* result;
    #####: 4037:   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
    %%%%%: 4037-block 2
call    0 never executed
    #####: 4038:   if (!j) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4038-block 4
call    2 never executed
    #####: 4039:   memset(j, 0, sizeof(stbi__jpeg));
        -: 4040:   STBI_NOTUSED(ri);
    #####: 4041:   j->s = s;
    #####: 4042:   stbi__setup_jpeg(j);
    %%%%%: 4042-block 6
call    0 never executed
    #####: 4043:   result = load_jpeg_image(j, x,y,comp,req_comp);
call    0 never executed
    #####: 4044:   STBI_FREE(j);
    #####: 4045:   return result;
        -: 4046:}
        -: 4047:
function _ZL15stbi__jpeg_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 4048:static int stbi__jpeg_test(stbi__context *s)
        -: 4049:{
        -: 4050:   int r;
    #####: 4051:   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
    %%%%%: 4051-block 2
call    0 never executed
    #####: 4052:   if (!j) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4052-block 4
call    2 never executed
    #####: 4053:   memset(j, 0, sizeof(stbi__jpeg));
    #####: 4054:   j->s = s;
    #####: 4055:   stbi__setup_jpeg(j);
    %%%%%: 4055-block 5
call    0 never executed
    #####: 4056:   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
call    0 never executed
    #####: 4057:   stbi__rewind(s);
call    0 never executed
    #####: 4058:   STBI_FREE(j);
    #####: 4059:   return r;
        -: 4060:}
        -: 4061:
function _ZL19stbi__jpeg_info_rawP10stbi__jpegPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 4062:static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
        -: 4063:{
    #####: 4064:   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
    %%%%%: 4064-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4065:      stbi__rewind( j->s );
    %%%%%: 4065-block 4
call    0 never executed
    #####: 4066:      return 0;
        -: 4067:   }
    #####: 4068:   if (x) *x = j->s->img_x;
    %%%%%: 4068-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4068-block 7
    #####: 4069:   if (y) *y = j->s->img_y;
    %%%%%: 4069-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4069-block 9
    #####: 4070:   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
    %%%%%: 4070-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4070-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4070-block 12
    %%%%%: 4070-block 13
    %%%%%: 4070-block 14
    #####: 4071:   return 1;
    %%%%%: 4071-block 15
        -: 4072:}
        -: 4073:
function _ZL15stbi__jpeg_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 4074:static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
        -: 4075:{
        -: 4076:   int result;
    #####: 4077:   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
    %%%%%: 4077-block 2
call    0 never executed
    #####: 4078:   if (!j) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4078-block 4
call    2 never executed
    #####: 4079:   memset(j, 0, sizeof(stbi__jpeg));
    #####: 4080:   j->s = s;
    #####: 4081:   result = stbi__jpeg_info_raw(j, x, y, comp);
    %%%%%: 4081-block 5
call    0 never executed
    #####: 4082:   STBI_FREE(j);
    #####: 4083:   return result;
        -: 4084:}
        -: 4085:#endif
        -: 4086:
        -: 4087:// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
        -: 4088://    simple implementation
        -: 4089://      - all input must be provided in an upfront buffer
        -: 4090://      - all output is written to a single output buffer (can malloc/realloc)
        -: 4091://    performance
        -: 4092://      - fast huffman
        -: 4093:
        -: 4094:#ifndef STBI_NO_ZLIB
        -: 4095:
        -: 4096:// fast-way is faster to check than jpeg huffman, but slow way is slower
        -: 4097:#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
        -: 4098:#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
        -: 4099:#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
        -: 4100:
        -: 4101:// zlib-style huffman encoding
        -: 4102:// (jpegs packs from left, zlib from right, so can't share code)
        -: 4103:typedef struct
        -: 4104:{
        -: 4105:   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
        -: 4106:   stbi__uint16 firstcode[16];
        -: 4107:   int maxcode[17];
        -: 4108:   stbi__uint16 firstsymbol[16];
        -: 4109:   stbi_uc  size[STBI__ZNSYMS];
        -: 4110:   stbi__uint16 value[STBI__ZNSYMS];
        -: 4111:} stbi__zhuffman;
        -: 4112:
function _ZL18stbi__bitreverse16i called 779642 returned 100% blocks executed 100%
   779642: 4113:stbi_inline static int stbi__bitreverse16(int n)
        -: 4114:{
   779642: 4115:  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
   779642: 4116:  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
   779642: 4117:  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
   779642: 4118:  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
   779642: 4119:  return n;
   779642: 4119-block 2
        -: 4120:}
        -: 4121:
function _ZL17stbi__bit_reverseii called 779642 returned 100% blocks executed 80%
   779642: 4122:stbi_inline static int stbi__bit_reverse(int v, int bits)
        -: 4123:{
  779642*: 4124:   STBI_ASSERT(bits <= 16);
   779642: 4124-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 779642
    %%%%%: 4124-block 3
call    2 never executed
        -: 4125:   // to bit reverse n bits, reverse 16 and shift
        -: 4126:   // e.g. 11 bits, bit reverse and shift away 5
   779642: 4127:   return stbi__bitreverse16(v) >> (16-bits);
   779642: 4127-block 4
call    0 returned 779642
        -: 4128:}
        -: 4129:
function _ZL20stbi__zbuild_huffmanP14stbi__zhuffmanPKhi called 2124 returned 100% blocks executed 93%
     2124: 4130:static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
        -: 4131:{
     2124: 4132:   int i,k=0;
        -: 4133:   int code, next_code[16], sizes[17];
        -: 4134:
        -: 4135:   // DEFLATE spec for generating codes
     2124: 4136:   memset(sizes, 0, sizeof(sizes));
     2124: 4137:   memset(z->fast, 0, sizeof(z->fast));
   222086: 4138:   for (i=0; i < num; ++i)
     2124: 4138-block 2
   222086: 4138-block 4
branch  0 taken 219962
branch  1 taken 2124 (fallthrough)
   219962: 4139:      ++sizes[sizelist[i]];
   219962: 4139-block 3
     2124: 4140:   sizes[0] = 0;
    33984: 4141:   for (i=1; i < 16; ++i)
     2124: 4141-block 5
    31860: 4141-block 8
    33984: 4141-block 9
branch  0 taken 31860
branch  1 taken 2124 (fallthrough)
    31860: 4142:      if (sizes[i] > (1 << i))
    31860: 4142-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 31860
    #####: 4143:         return stbi__err("bad sizes", "Corrupt PNG");
    %%%%%: 4143-block 7
call    0 never executed
     2124: 4144:   code = 0;
    33984: 4145:   for (i=1; i < 16; ++i) {
     2124: 4145-block 10
    33984: 4145-block 15
branch  0 taken 31860
branch  1 taken 2124 (fallthrough)
    31860: 4146:      next_code[i] = code;
    31860: 4147:      z->firstcode[i] = (stbi__uint16) code;
    31860: 4148:      z->firstsymbol[i] = (stbi__uint16) k;
    31860: 4149:      code = (code + sizes[i]);
    31860: 4150:      if (sizes[i])
    31860: 4150-block 11
branch  0 taken 17334 (fallthrough)
branch  1 taken 14526
   17334*: 4151:         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
    17334: 4151-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 17334
    %%%%%: 4151-block 13
call    2 never executed
    31860: 4152:      z->maxcode[i] = code << (16-i); // preshift for inner loop
    31860: 4153:      code <<= 1;
    31860: 4154:      k += sizes[i];
    31860: 4154-block 14
        -: 4155:   }
     2124: 4156:   z->maxcode[16] = 0x10000; // sentinel
   222086: 4157:   for (i=0; i < num; ++i) {
     2124: 4157-block 16
   219962: 4157-block 24
   222086: 4157-block 25
branch  0 taken 219962
branch  1 taken 2124 (fallthrough)
   219962: 4158:      int s = sizelist[i];
   219962: 4159:      if (s) {
   219962: 4159-block 17
branch  0 taken 209167 (fallthrough)
branch  1 taken 10795
   209167: 4160:         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
   209167: 4161:         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
   209167: 4162:         z->size [c] = (stbi_uc     ) s;
   209167: 4163:         z->value[c] = (stbi__uint16) i;
   209167: 4164:         if (s <= STBI__ZFAST_BITS) {
   209167: 4164-block 18
branch  0 taken 160043 (fallthrough)
branch  1 taken 49124
   160043: 4165:            int j = stbi__bit_reverse(next_code[s],s);
   160043: 4165-block 19
call    0 returned 160043
  1231424: 4166:            while (j < (1 << STBI__ZFAST_BITS)) {
  1231424: 4166-block 22
branch  0 taken 1071381
branch  1 taken 160043 (fallthrough)
  1071381: 4167:               z->fast[j] = fastv;
  1071381: 4168:               j += (1 << s);
  1071381: 4168-block 21
        -: 4169:            }
        -: 4170:         }
   209167: 4171:         ++next_code[s];
   209167: 4171-block 23
        -: 4172:      }
        -: 4173:   }
     2124: 4174:   return 1;
     2124: 4174-block 26
        -: 4175:}
        -: 4176:
        -: 4177:// zlib-from-memory implementation for PNG reading
        -: 4178://    because PNG allows splitting the zlib stream arbitrarily,
        -: 4179://    and it's annoying structurally to have PNG call ZLIB call PNG,
        -: 4180://    we require PNG read all the IDATs and combine them into a single
        -: 4181://    memory buffer
        -: 4182:
        -: 4183:typedef struct
        -: 4184:{
        -: 4185:   stbi_uc *zbuffer, *zbuffer_end;
        -: 4186:   int num_bits;
        -: 4187:   int hit_zeof_once;
        -: 4188:   stbi__uint32 code_buffer;
        -: 4189:
        -: 4190:   char *zout;
        -: 4191:   char *zout_start;
        -: 4192:   char *zout_end;
        -: 4193:   int   z_expandable;
        -: 4194:
        -: 4195:   stbi__zhuffman z_length, z_distance;
        -: 4196:} stbi__zbuf;
        -: 4197:
function _ZL10stbi__zeofP10stbi__zbuf called 20886014 returned 100% blocks executed 100%
 20886014: 4198:stbi_inline static int stbi__zeof(stbi__zbuf *z)
        -: 4199:{
 20886014: 4200:   return (z->zbuffer >= z->zbuffer_end);
 20886014: 4200-block 2
        -: 4201:}
        -: 4202:
function _ZL11stbi__zget8P10stbi__zbuf called 14569980 returned 100% blocks executed 83%
 14569980: 4203:stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
        -: 4204:{
14569980*: 4205:   return stbi__zeof(z) ? 0 : *z->zbuffer++;
 14569980: 4205-block 2
call    0 returned 14569980
branch  1 taken 14569980 (fallthrough)
branch  2 taken 0
 14569980: 4205-block 4
    %%%%%: 4205-block 5
 14569980: 4205-block 6
        -: 4206:}
        -: 4207:
function _ZL15stbi__fill_bitsP10stbi__zbuf called 6330352 returned 100% blocks executed 80%
 14569974: 4208:static void stbi__fill_bits(stbi__zbuf *z)
        -: 4209:{
        -: 4210:   do {
 14569974: 4211:      if (z->code_buffer >= (1U << z->num_bits)) {
 14569974: 4211-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 14569974
    #####: 4212:        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
    #####: 4213:        return;
    %%%%%: 4213-block 3
        -: 4214:      }
 14569974: 4215:      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
 14569974: 4215-block 4
call    0 returned 14569974
 14569974: 4216:      z->num_bits += 8;
 14569974: 4217:   } while (z->num_bits <= 24);
branch  0 taken 8239622
branch  1 taken 6330352 (fallthrough)
        -: 4218:}
        -: 4219:
function _ZL14stbi__zreceiveP10stbi__zbufi called 3244165 returned 100% blocks executed 100%
  3244165: 4220:stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
        -: 4221:{
        -: 4222:   unsigned int k;
  3244165: 4223:   if (z->num_bits < n) stbi__fill_bits(z);
  3244165: 4223-block 2
branch  0 taken 14321 (fallthrough)
branch  1 taken 3229844
    14321: 4223-block 3
call    2 returned 14321
  3244165: 4224:   k = z->code_buffer & ((1 << n) - 1);
  3244165: 4225:   z->code_buffer >>= n;
  3244165: 4226:   z->num_bits -= n;
  3244165: 4227:   return k;
  3244165: 4227-block 4
        -: 4228:}
        -: 4229:
function _ZL30stbi__zhuffman_decode_slowpathP10stbi__zbufP14stbi__zhuffman called 619599 returned 100% blocks executed 77%
   619599: 4230:static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
        -: 4231:{
        -: 4232:   int b,s,k;
        -: 4233:   // not resolved by fast table, so compute it the slow way
        -: 4234:   // use jpeg approach, which requires MSbits at top
   619599: 4235:   k = stbi__bit_reverse(a->code_buffer, 16);
   619599: 4235-block 2
call    0 returned 619599
   743819: 4236:   for (s=STBI__ZFAST_BITS+1; ; ++s)
   124220: 4236-block 6
   743819: 4237:      if (k < z->maxcode[s])
   743819: 4237-block 4
branch  0 taken 619599 (fallthrough)
branch  1 taken 124220
   619599: 4238:         break;
   619599: 4238-block 5
  619599*: 4239:   if (s >= 16) return -1; // invalid code!
   619599: 4239-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 619599
    %%%%%: 4239-block 8
        -: 4240:   // code size is s, so:
   619599: 4241:   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
  619599*: 4242:   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
   619599: 4242-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 619599
    %%%%%: 4242-block 10
  619599*: 4243:   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
   619599: 4243-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 619599
    %%%%%: 4243-block 12
   619599: 4244:   a->code_buffer >>= s;
   619599: 4245:   a->num_bits -= s;
   619599: 4246:   return z->value[b];
   619599: 4246-block 13
        -: 4247:}
        -: 4248:
function _ZL21stbi__zhuffman_decodeP10stbi__zbufP14stbi__zhuffman called 14935144 returned 100% blocks executed 73%
 14935144: 4249:stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
        -: 4250:{
        -: 4251:   int b,s;
 14935144: 4252:   if (a->num_bits < 16) {
 14935144: 4252-block 2
branch  0 taken 6316031 (fallthrough)
branch  1 taken 8619113
  6316031: 4253:      if (stbi__zeof(a)) {
  6316031: 4253-block 3
call    0 returned 6316031
branch  1 taken 0 (fallthrough)
branch  2 taken 6316031
    #####: 4254:         if (!a->hit_zeof_once) {
    %%%%%: 4254-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4255:            // This is the first time we hit eof, insert 16 extra padding btis
        -: 4256:            // to allow us to keep going; if we actually consume any of them
        -: 4257:            // though, that is invalid data. This is caught later.
    #####: 4258:            a->hit_zeof_once = 1;
    #####: 4259:            a->num_bits += 16; // add 16 implicit zero bits
    %%%%%: 4259-block 6
        -: 4260:         } else {
        -: 4261:            // We already inserted our extra 16 padding bits and are again
        -: 4262:            // out, this stream is actually prematurely terminated.
    #####: 4263:            return -1;
    %%%%%: 4263-block 7
        -: 4264:         }
        -: 4265:      } else {
  6316031: 4266:         stbi__fill_bits(a);
  6316031: 4266-block 8
call    0 returned 6316031
        -: 4267:      }
        -: 4268:   }
 14935144: 4269:   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
 14935144: 4270:   if (b) {
 14935144: 4270-block 9
branch  0 taken 14315545 (fallthrough)
branch  1 taken 619599
 14315545: 4271:      s = b >> 9;
 14315545: 4272:      a->code_buffer >>= s;
 14315545: 4273:      a->num_bits -= s;
 14315545: 4274:      return b & 511;
 14315545: 4274-block 10
        -: 4275:   }
   619599: 4276:   return stbi__zhuffman_decode_slowpath(a, z);
   619599: 4276-block 11
call    0 returned 619599
        -: 4277:}
        -: 4278:
function _ZL13stbi__zexpandP10stbi__zbufPci called 0 returned 0% blocks executed 0%
    #####: 4279:static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
        -: 4280:{
        -: 4281:   char *q;
        -: 4282:   unsigned int cur, limit, old_limit;
    #####: 4283:   z->zout = zout;
    #####: 4284:   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
    %%%%%: 4284-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4284-block 3
call    2 never executed
    #####: 4285:   cur   = (unsigned int) (z->zout - z->zout_start);
    #####: 4286:   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
    #####: 4287:   if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4287-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4287-block 5
call    2 never executed
    #####: 4288:   while (cur + n > limit) {
    %%%%%: 4288-block 6
    %%%%%: 4288-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4289:      if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4289-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4289-block 8
call    2 never executed
    #####: 4290:      limit *= 2;
    %%%%%: 4290-block 9
        -: 4291:   }
    #####: 4292:   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
        -: 4293:   STBI_NOTUSED(old_limit);
    #####: 4294:   if (q == NULL) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4294-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4294-block 12
call    2 never executed
    #####: 4295:   z->zout_start = q;
    #####: 4296:   z->zout       = q + cur;
    #####: 4297:   z->zout_end   = q + limit;
    #####: 4298:   return 1;
    %%%%%: 4298-block 13
        -: 4299:}
        -: 4300:
        -: 4301:static const int stbi__zlength_base[31] = {
        -: 4302:   3,4,5,6,7,8,9,10,11,13,
        -: 4303:   15,17,19,23,27,31,35,43,51,59,
        -: 4304:   67,83,99,115,131,163,195,227,258,0,0 };
        -: 4305:
        -: 4306:static const int stbi__zlength_extra[31]=
        -: 4307:{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
        -: 4308:
        -: 4309:static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
        -: 4310:257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
        -: 4311:
        -: 4312:static const int stbi__zdist_extra[32] =
        -: 4313:{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
        -: 4314:
function _ZL25stbi__parse_huffman_blockP10stbi__zbuf called 708 returned 100% blocks executed 62%
      708: 4315:static int stbi__parse_huffman_block(stbi__zbuf *a)
        -: 4316:{
      708: 4317:   char *zout = a->zout;
      708: 4317-block 2
        -: 4318:   for(;;) {
 11583122: 4319:      int z = stbi__zhuffman_decode(a, &a->z_length);
 11583122: 4319-block 3
call    0 returned 11583122
 11583122: 4320:      if (z < 256) {
branch  0 taken 8366649 (fallthrough)
branch  1 taken 3216473
 8366649*: 4321:         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
  8366649: 4321-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 8366649
    %%%%%: 4321-block 6
call    2 never executed
  8366649: 4322:         if (zout >= a->zout_end) {
  8366649: 4322-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 8366649
    #####: 4323:            if (!stbi__zexpand(a, zout, 1)) return 0;
    %%%%%: 4323-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4323-block 10
    #####: 4324:            zout = a->zout;
    %%%%%: 4324-block 11
        -: 4325:         }
  8366649: 4326:         *zout++ = (char) z;
  8366649: 4326-block 12
        -: 4327:      } else {
        -: 4328:         stbi_uc *p;
        -: 4329:         int len,dist;
  3216473: 4330:         if (z == 256) {
  3216473: 4330-block 13
branch  0 taken 708 (fallthrough)
branch  1 taken 3215765
      708: 4331:            a->zout = zout;
     708*: 4332:            if (a->hit_zeof_once && a->num_bits < 16) {
      708: 4332-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 708
    %%%%%: 4332-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4333:               // The first time we hit zeof, we inserted 16 extra zero bits into our bit
        -: 4334:               // buffer so the decoder can just do its speculative decoding. But if we
        -: 4335:               // actually consumed any of those bits (which is the case when num_bits < 16),
        -: 4336:               // the stream actually read past the end so it is malformed.
    #####: 4337:               return stbi__err("unexpected end","Corrupt PNG");
    %%%%%: 4337-block 16
call    0 never executed
        -: 4338:            }
      708: 4339:            return 1;
      708: 4339-block 17
        -: 4340:         }
 3215765*: 4341:         if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
  3215765: 4341-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 3215765
    %%%%%: 4341-block 19
call    2 never executed
  3215765: 4342:         z -= 257;
  3215765: 4343:         len = stbi__zlength_base[z];
 3215765*: 4344:         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
  3215765: 4344-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 3215765
    %%%%%: 4344-block 21
call    2 never executed
  3215765: 4345:         z = stbi__zhuffman_decode(a, &a->z_distance);
  3215765: 4345-block 23
call    0 returned 3215765
 3215765*: 4346:         if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
branch  0 taken 3215765 (fallthrough)
branch  1 taken 0
  3215765: 4346-block 25
branch  2 taken 0 (fallthrough)
branch  3 taken 3215765
    %%%%%: 4346-block 26
call    4 never executed
  3215765: 4347:         dist = stbi__zdist_base[z];
  3215765: 4348:         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
  3215765: 4348-block 27
branch  0 taken 3212502 (fallthrough)
branch  1 taken 3263
  3212502: 4348-block 28
call    2 returned 3212502
 3215765*: 4349:         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
  3215765: 4349-block 30
branch  0 taken 0 (fallthrough)
branch  1 taken 3215765
    %%%%%: 4349-block 31
call    2 never executed
  3215765: 4350:         if (len > a->zout_end - zout) {
  3215765: 4350-block 32
branch  0 taken 0 (fallthrough)
branch  1 taken 3215765
    #####: 4351:            if (!stbi__zexpand(a, zout, len)) return 0;
    %%%%%: 4351-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4351-block 35
    #####: 4352:            zout = a->zout;
    %%%%%: 4352-block 36
        -: 4353:         }
  3215765: 4354:         p = (stbi_uc *) (zout - dist);
  3215765: 4355:         if (dist == 1) { // run of one byte; common in images.
  3215765: 4355-block 37
branch  0 taken 292 (fallthrough)
branch  1 taken 3215473
      292: 4356:            stbi_uc v = *p;
      933: 4357:            if (len) { do *zout++ = v; while (--len); }
      292: 4357-block 38
branch  0 taken 292 (fallthrough)
branch  1 taken 0
      933: 4357-block 39
branch  2 taken 641
branch  3 taken 292
        -: 4358:         } else {
 12607010: 4359:            if (len) { do *zout++ = *p++; while (--len); }
  3215473: 4359-block 40
branch  0 taken 3215473 (fallthrough)
branch  1 taken 0
 12607010: 4359-block 41
branch  2 taken 9391537
branch  3 taken 3215473 (fallthrough)
        -: 4360:         }
        -: 4361:      }
 11582414: 4362:   }
 11582414: 4362-block 42
        -: 4363:}
        -: 4364:
function _ZL27stbi__compute_huffman_codesP10stbi__zbuf called 708 returned 100% blocks executed 75%
      708: 4365:static int stbi__compute_huffman_codes(stbi__zbuf *a)
        -: 4366:{
        -: 4367:   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
        -: 4368:   stbi__zhuffman z_codelength;
        -: 4369:   stbi_uc lencodes[286+32+137];//padding for maximum single op
        -: 4370:   stbi_uc codelength_sizes[19];
        -: 4371:   int i,n;
        -: 4372:
      708: 4373:   int hlit  = stbi__zreceive(a,5) + 257;
      708: 4373-block 2
call    0 returned 708
      708: 4374:   int hdist = stbi__zreceive(a,5) + 1;
call    0 returned 708
      708: 4375:   int hclen = stbi__zreceive(a,4) + 4;
call    0 returned 708
      708: 4376:   int ntot  = hlit + hdist;
        -: 4377:
      708: 4378:   memset(codelength_sizes, 0, sizeof(codelength_sizes));
    11705: 4379:   for (i=0; i < hclen; ++i) {
    11705: 4379-block 8
branch  0 taken 10997
branch  1 taken 708 (fallthrough)
    10997: 4380:      int s = stbi__zreceive(a,3);
    10997: 4380-block 6
call    0 returned 10997
    10997: 4381:      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
        -: 4382:   }
     708*: 4383:   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
      708: 4383-block 9
call    0 returned 708
branch  1 taken 0 (fallthrough)
branch  2 taken 708
    %%%%%: 4383-block 11
        -: 4384:
      708: 4385:   n = 0;
   136965: 4386:   while (n < ntot) {
      708: 4386-block 12
   136965: 4386-block 34
branch  0 taken 136257
branch  1 taken 708 (fallthrough)
   136257: 4387:      int c = stbi__zhuffman_decode(a, &z_codelength);
   136257: 4387-block 13
call    0 returned 136257
  136257*: 4388:      if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
branch  0 taken 136257 (fallthrough)
branch  1 taken 0
   136257: 4388-block 15
branch  2 taken 0 (fallthrough)
branch  3 taken 136257
    %%%%%: 4388-block 16
call    4 never executed
   136257: 4389:      if (c < 16)
   136257: 4389-block 17
branch  0 taken 119131 (fallthrough)
branch  1 taken 17126
   119131: 4390:         lencodes[n++] = (stbi_uc) c;
   119131: 4390-block 18
        -: 4391:      else {
    17126: 4392:         stbi_uc fill = 0;
    17126: 4393:         if (c == 16) {
    17126: 4393-block 19
branch  0 taken 16763 (fallthrough)
branch  1 taken 363
    16763: 4394:            c = stbi__zreceive(a,2)+3;
    16763: 4394-block 20
call    0 returned 16763
   16763*: 4395:            if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
branch  0 taken 0 (fallthrough)
branch  1 taken 16763
    %%%%%: 4395-block 22
call    2 never executed
    16763: 4396:            fill = lencodes[n-1];
    16763: 4396-block 23
      363: 4397:         } else if (c == 17) {
      363: 4397-block 24
branch  0 taken 363 (fallthrough)
branch  1 taken 0
      363: 4398:            c = stbi__zreceive(a,3)+3;
      363: 4398-block 25
call    0 returned 363
    #####: 4399:         } else if (c == 18) {
    %%%%%: 4399-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4400:            c = stbi__zreceive(a,7)+11;
    %%%%%: 4400-block 28
call    0 never executed
        -: 4401:         } else {
    #####: 4402:            return stbi__err("bad codelengths", "Corrupt PNG");
    %%%%%: 4402-block 30
call    0 never executed
        -: 4403:         }
   17126*: 4404:         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
    17126: 4404-block 31
branch  0 taken 0 (fallthrough)
branch  1 taken 17126
    %%%%%: 4404-block 32
call    2 never executed
    17126: 4405:         memset(lencodes+n, fill, c);
    17126: 4406:         n += c;
    17126: 4406-block 33
        -: 4407:      }
        -: 4408:   }
     708*: 4409:   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
      708: 4409-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 708
    %%%%%: 4409-block 36
call    2 never executed
     708*: 4410:   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
      708: 4410-block 37
call    0 returned 708
branch  1 taken 0 (fallthrough)
branch  2 taken 708
    %%%%%: 4410-block 39
     708*: 4411:   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
      708: 4411-block 40
call    0 returned 708
branch  1 taken 0 (fallthrough)
branch  2 taken 708
    %%%%%: 4411-block 42
      708: 4412:   return 1;
      708: 4412-block 43
        -: 4413:}
        -: 4414:
function _ZL30stbi__parse_uncompressed_blockP10stbi__zbuf called 0 returned 0% blocks executed 0%
    #####: 4415:static int stbi__parse_uncompressed_block(stbi__zbuf *a)
        -: 4416:{
        -: 4417:   stbi_uc header[4];
        -: 4418:   int len,nlen,k;
    #####: 4419:   if (a->num_bits & 7)
    %%%%%: 4419-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4420:      stbi__zreceive(a, a->num_bits & 7); // discard
    %%%%%: 4420-block 3
call    0 never executed
        -: 4421:   // drain the bit-packed data into header
    #####: 4422:   k = 0;
    #####: 4423:   while (a->num_bits > 0) {
    %%%%%: 4423-block 4
    %%%%%: 4423-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4424:      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
    #####: 4425:      a->code_buffer >>= 8;
    #####: 4426:      a->num_bits -= 8;
    %%%%%: 4426-block 5
        -: 4427:   }
    #####: 4428:   if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
    %%%%%: 4428-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4428-block 8
call    2 never executed
        -: 4429:   // now fill header the normal way
    #####: 4430:   while (k < 4)
    %%%%%: 4430-block 9
    %%%%%: 4430-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4431:      header[k++] = stbi__zget8(a);
    %%%%%: 4431-block 10
call    0 never executed
    #####: 4432:   len  = header[1] * 256 + header[0];
    #####: 4433:   nlen = header[3] * 256 + header[2];
    #####: 4434:   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
    %%%%%: 4434-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4434-block 14
call    2 never executed
    #####: 4435:   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
    %%%%%: 4435-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4435-block 16
call    2 never executed
    #####: 4436:   if (a->zout + len > a->zout_end)
    %%%%%: 4436-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4437:      if (!stbi__zexpand(a, a->zout, len)) return 0;
    %%%%%: 4437-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4437-block 20
    #####: 4438:   memcpy(a->zout, a->zbuffer, len);
    #####: 4439:   a->zbuffer += len;
    #####: 4440:   a->zout += len;
    #####: 4441:   return 1;
    %%%%%: 4441-block 21
        -: 4442:}
        -: 4443:
function _ZL23stbi__parse_zlib_headerP10stbi__zbuf called 3 returned 100% blocks executed 69%
        3: 4444:static int stbi__parse_zlib_header(stbi__zbuf *a)
        -: 4445:{
        3: 4446:   int cmf   = stbi__zget8(a);
        3: 4446-block 2
call    0 returned 3
        3: 4447:   int cm    = cmf & 15;
        -: 4448:   /* int cinfo = cmf >> 4; */
        3: 4449:   int flg   = stbi__zget8(a);
call    0 returned 3
       3*: 4450:   if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    %%%%%: 4450-block 6
call    3 never executed
       3*: 4451:   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
        3: 4451-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 4451-block 8
call    2 never executed
       3*: 4452:   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
        3: 4452-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 4452-block 10
call    2 never executed
       3*: 4453:   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
        3: 4453-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 4453-block 12
call    2 never executed
        -: 4454:   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
        3: 4455:   return 1;
        3: 4455-block 13
        -: 4456:}
        -: 4457:
        -: 4458:static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
        -: 4459:{
        -: 4460:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4461:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4462:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4463:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4464:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4465:   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4466:   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4467:   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4468:   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
        -: 4469:};
        -: 4470:static const stbi_uc stbi__zdefault_distance[32] =
        -: 4471:{
        -: 4472:   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
        -: 4473:};
        -: 4474:/*
        -: 4475:Init algorithm:
        -: 4476:{
        -: 4477:   int i;   // use <= to match clearly with spec
        -: 4478:   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
        -: 4479:   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
        -: 4480:   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
        -: 4481:   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
        -: 4482:
        -: 4483:   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
        -: 4484:}
        -: 4485:*/
        -: 4486:
function _ZL16stbi__parse_zlibP10stbi__zbufi called 3 returned 100% blocks executed 55%
        3: 4487:static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
        -: 4488:{
        -: 4489:   int final, type;
        3: 4490:   if (parse_header)
        3: 4490-block 2
branch  0 taken 3 (fallthrough)
branch  1 taken 0
       3*: 4491:      if (!stbi__parse_zlib_header(a)) return 0;
        3: 4491-block 3
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    %%%%%: 4491-block 5
        3: 4492:   a->num_bits = 0;
        3: 4493:   a->code_buffer = 0;
        3: 4494:   a->hit_zeof_once = 0;
        3: 4494-block 6
        -: 4495:   do {
      708: 4496:      final = stbi__zreceive(a,1);
      708: 4496-block 7
call    0 returned 708
      708: 4497:      type = stbi__zreceive(a,2);
call    0 returned 708
      708: 4498:      if (type == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 708
    #####: 4499:         if (!stbi__parse_uncompressed_block(a)) return 0;
    %%%%%: 4499-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4499-block 12
      708: 4500:      } else if (type == 3) {
      708: 4500-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 708
    #####: 4501:         return 0;
    %%%%%: 4501-block 14
        -: 4502:      } else {
      708: 4503:         if (type == 1) {
      708: 4503-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 708
        -: 4504:            // use fixed code lengths
    #####: 4505:            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
    %%%%%: 4505-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4505-block 18
    #####: 4506:            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
    %%%%%: 4506-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4506-block 21
        -: 4507:         } else {
     708*: 4508:            if (!stbi__compute_huffman_codes(a)) return 0;
      708: 4508-block 22
call    0 returned 708
branch  1 taken 0 (fallthrough)
branch  2 taken 708
    %%%%%: 4508-block 24
        -: 4509:         }
     708*: 4510:         if (!stbi__parse_huffman_block(a)) return 0;
      708: 4510-block 25
call    0 returned 708
branch  1 taken 0 (fallthrough)
branch  2 taken 708
    %%%%%: 4510-block 27
        -: 4511:      }
      708: 4512:   } while (!final);
      708: 4512-block 28
branch  0 taken 705
branch  1 taken 3 (fallthrough)
        3: 4513:   return 1;
        3: 4513-block 29
        -: 4514:}
        -: 4515:
function _ZL13stbi__do_zlibP10stbi__zbufPciii called 3 returned 100% blocks executed 100%
        3: 4516:static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
        -: 4517:{
        3: 4518:   a->zout_start = obuf;
        3: 4519:   a->zout       = obuf;
        3: 4520:   a->zout_end   = obuf + olen;
        3: 4521:   a->z_expandable = exp;
        -: 4522:
        3: 4523:   return stbi__parse_zlib(a, parse_header);
        3: 4523-block 2
call    0 returned 3
        -: 4524:}
        -: 4525:
function stbi_zlib_decode_malloc_guesssize called 0 returned 0% blocks executed 0%
    #####: 4526:STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
        -: 4527:{
        -: 4528:   stbi__zbuf a;
    #####: 4529:   char *p = (char *) stbi__malloc(initial_size);
    %%%%%: 4529-block 2
call    0 never executed
    #####: 4530:   if (p == NULL) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4530-block 4
    #####: 4531:   a.zbuffer = (stbi_uc *) buffer;
    #####: 4532:   a.zbuffer_end = (stbi_uc *) buffer + len;
    #####: 4533:   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
    %%%%%: 4533-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4534:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
    %%%%%: 4534-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4534-block 8
    #####: 4535:      return a.zout_start;
    %%%%%: 4535-block 9
        -: 4536:   } else {
    #####: 4537:      STBI_FREE(a.zout_start);
    #####: 4538:      return NULL;
    %%%%%: 4538-block 10
        -: 4539:   }
        -: 4540:}
        -: 4541:
function stbi_zlib_decode_malloc called 0 returned 0% blocks executed 0%
    #####: 4542:STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
        -: 4543:{
    #####: 4544:   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
    %%%%%: 4544-block 2
call    0 never executed
        -: 4545:}
        -: 4546:
function stbi_zlib_decode_malloc_guesssize_headerflag called 3 returned 100% blocks executed 82%
        3: 4547:STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
        -: 4548:{
        -: 4549:   stbi__zbuf a;
        3: 4550:   char *p = (char *) stbi__malloc(initial_size);
        3: 4550-block 2
call    0 returned 3
       3*: 4551:   if (p == NULL) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 4551-block 4
        3: 4552:   a.zbuffer = (stbi_uc *) buffer;
        3: 4553:   a.zbuffer_end = (stbi_uc *) buffer + len;
        3: 4554:   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
        3: 4554-block 5
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0
        3: 4555:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
        3: 4555-block 7
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 4555-block 8
        3: 4556:      return a.zout_start;
        3: 4556-block 9
        -: 4557:   } else {
    #####: 4558:      STBI_FREE(a.zout_start);
    #####: 4559:      return NULL;
    %%%%%: 4559-block 10
        -: 4560:   }
        -: 4561:}
        -: 4562:
function stbi_zlib_decode_buffer called 0 returned 0% blocks executed 0%
    #####: 4563:STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
        -: 4564:{
        -: 4565:   stbi__zbuf a;
    #####: 4566:   a.zbuffer = (stbi_uc *) ibuffer;
    #####: 4567:   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
    #####: 4568:   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
    %%%%%: 4568-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4569:      return (int) (a.zout - a.zout_start);
    %%%%%: 4569-block 4
        -: 4570:   else
    #####: 4571:      return -1;
    %%%%%: 4571-block 5
        -: 4572:}
        -: 4573:
function stbi_zlib_decode_noheader_malloc called 0 returned 0% blocks executed 0%
    #####: 4574:STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
        -: 4575:{
        -: 4576:   stbi__zbuf a;
    #####: 4577:   char *p = (char *) stbi__malloc(16384);
    %%%%%: 4577-block 2
call    0 never executed
    #####: 4578:   if (p == NULL) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4578-block 4
    #####: 4579:   a.zbuffer = (stbi_uc *) buffer;
    #####: 4580:   a.zbuffer_end = (stbi_uc *) buffer+len;
    #####: 4581:   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
    %%%%%: 4581-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4582:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
    %%%%%: 4582-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4582-block 8
    #####: 4583:      return a.zout_start;
    %%%%%: 4583-block 9
        -: 4584:   } else {
    #####: 4585:      STBI_FREE(a.zout_start);
    #####: 4586:      return NULL;
    %%%%%: 4586-block 10
        -: 4587:   }
        -: 4588:}
        -: 4589:
function stbi_zlib_decode_noheader_buffer called 0 returned 0% blocks executed 0%
    #####: 4590:STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
        -: 4591:{
        -: 4592:   stbi__zbuf a;
    #####: 4593:   a.zbuffer = (stbi_uc *) ibuffer;
    #####: 4594:   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
    #####: 4595:   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
    %%%%%: 4595-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4596:      return (int) (a.zout - a.zout_start);
    %%%%%: 4596-block 4
        -: 4597:   else
    #####: 4598:      return -1;
    %%%%%: 4598-block 5
        -: 4599:}
        -: 4600:#endif
        -: 4601:
        -: 4602:// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
        -: 4603://    simple implementation
        -: 4604://      - only 8-bit samples
        -: 4605://      - no CRC checking
        -: 4606://      - allocates lots of intermediate memory
        -: 4607://        - avoids problem of streaming data between subsystems
        -: 4608://        - avoids explicit window management
        -: 4609://    performance
        -: 4610://      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
        -: 4611:
        -: 4612:#ifndef STBI_NO_PNG
        -: 4613:typedef struct
        -: 4614:{
        -: 4615:   stbi__uint32 length;
        -: 4616:   stbi__uint32 type;
        -: 4617:} stbi__pngchunk;
        -: 4618:
function _ZL22stbi__get_chunk_headerP13stbi__context called 1824 returned 100% blocks executed 100%
     1824: 4619:static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
        -: 4620:{
        -: 4621:   stbi__pngchunk c;
     1824: 4622:   c.length = stbi__get32be(s);
     1824: 4622-block 2
call    0 returned 1824
branch  1 taken 1824 (fallthrough)
branch  2 taken 0 (throw)
     1824: 4623:   c.type   = stbi__get32be(s);
     1824: 4623-block 3
call    0 returned 1824
branch  1 taken 1824 (fallthrough)
branch  2 taken 0 (throw)
     1824: 4624:   return c;
     1824: 4624-block 4
     1824: 4624-block 5
        -: 4625:}
        -: 4626:
function _ZL22stbi__check_png_headerP13stbi__context called 6 returned 100% blocks executed 88%
        6: 4627:static int stbi__check_png_header(stbi__context *s)
        -: 4628:{
        -: 4629:   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
        -: 4630:   int i;
       54: 4631:   for (i=0; i < 8; ++i)
        6: 4631-block 2
       48: 4631-block 6
       54: 4631-block 7
branch  0 taken 48
branch  1 taken 6 (fallthrough)
      48*: 4632:      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
       48: 4632-block 3
call    0 returned 48
branch  1 taken 0 (fallthrough)
branch  2 taken 48
    %%%%%: 4632-block 5
call    3 never executed
        6: 4633:   return 1;
        6: 4633-block 8
        -: 4634:}
        -: 4635:
        -: 4636:typedef struct
        -: 4637:{
        -: 4638:   stbi__context *s;
        -: 4639:   stbi_uc *idata, *expanded, *out;
        -: 4640:   int depth;
        -: 4641:} stbi__png;
        -: 4642:
        -: 4643:
        -: 4644:enum {
        -: 4645:   STBI__F_none=0,
        -: 4646:   STBI__F_sub=1,
        -: 4647:   STBI__F_up=2,
        -: 4648:   STBI__F_avg=3,
        -: 4649:   STBI__F_paeth=4,
        -: 4650:   // synthetic filter used for first scanline to avoid needing a dummy row of 0s
        -: 4651:   STBI__F_avg_first
        -: 4652:};
        -: 4653:
        -: 4654:static stbi_uc first_row_filter[5] =
        -: 4655:{
        -: 4656:   STBI__F_none,
        -: 4657:   STBI__F_sub,
        -: 4658:   STBI__F_none,
        -: 4659:   STBI__F_avg_first,
        -: 4660:   STBI__F_sub // Paeth with b=c=0 turns out to be equivalent to sub
        -: 4661:};
        -: 4662:
function _ZL11stbi__paethiii called 3948780 returned 100% blocks executed 100%
  3948780: 4663:static int stbi__paeth(int a, int b, int c)
        -: 4664:{
        -: 4665:   // This formulation looks very different from the reference in the PNG spec, but is
        -: 4666:   // actually equivalent and has favorable data dependencies and admits straightforward
        -: 4667:   // generation of branch-free code, which helps performance significantly.
  3948780: 4668:   int thresh = c*3 - (a + b);
  3948780: 4669:   int lo = a < b ? a : b;
  3948780: 4669-block 2
branch  0 taken 1336568 (fallthrough)
branch  1 taken 2612212
  1336568: 4669-block 3
  2612212: 4669-block 4
  3948780: 4670:   int hi = a < b ? b : a;
  3948780: 4670-block 5
branch  0 taken 1336568 (fallthrough)
branch  1 taken 2612212
  1336568: 4670-block 6
  2612212: 4670-block 7
  3948780: 4671:   int t0 = (hi <= thresh) ? lo : c;
  3948780: 4671-block 8
branch  0 taken 2378742 (fallthrough)
branch  1 taken 1570038
  2378742: 4671-block 9
  1570038: 4671-block 10
  3948780: 4672:   int t1 = (thresh <= lo) ? hi : t0;
  3948780: 4672-block 11
branch  0 taken 2372621 (fallthrough)
branch  1 taken 1576159
  2372621: 4672-block 12
  1576159: 4672-block 13
  3948780: 4673:   return t1;
  3948780: 4673-block 14
        -: 4674:}
        -: 4675:
        -: 4676:static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
        -: 4677:
        -: 4678:// adds an extra all-255 alpha channel
        -: 4679:// dest == src is legal
        -: 4680:// img_n must be 1 or 3
function _ZL30stbi__create_png_alpha_expand8PhS_ji called 0 returned 0% blocks executed 0%
    #####: 4681:static void stbi__create_png_alpha_expand8(stbi_uc *dest, stbi_uc *src, stbi__uint32 x, int img_n)
        -: 4682:{
        -: 4683:   int i;
        -: 4684:   // must process data backwards since we allow dest==src
    #####: 4685:   if (img_n == 1) {
    %%%%%: 4685-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4686:      for (i=x-1; i >= 0; --i) {
    %%%%%: 4686-block 3
    %%%%%: 4686-block 5
branch  0 never executed
branch  1 never executed
    #####: 4687:         dest[i*2+1] = 255;
    #####: 4688:         dest[i*2+0] = src[i];
    %%%%%: 4688-block 4
        -: 4689:      }
        -: 4690:   } else {
    #####: 4691:      STBI_ASSERT(img_n == 3);
    %%%%%: 4691-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4691-block 7
call    2 never executed
    #####: 4692:      for (i=x-1; i >= 0; --i) {
    %%%%%: 4692-block 8
    %%%%%: 4692-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4693:         dest[i*4+3] = 255;
    #####: 4694:         dest[i*4+2] = src[i*3+2];
    #####: 4695:         dest[i*4+1] = src[i*3+1];
    #####: 4696:         dest[i*4+0] = src[i*3+0];
    %%%%%: 4696-block 9
        -: 4697:      }
        -: 4698:   }
    #####: 4699:}
        -: 4700:
        -: 4701:// create the png data from post-deflated data
function _ZL26stbi__create_png_image_rawP9stbi__pngPhjijjii called 3 returned 100% blocks executed 56%
        3: 4702:static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
        -: 4703:{
       3*: 4704:   int bytes = (depth == 16 ? 2 : 1);
        3: 4704-block 2
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 4704-block 3
    %%%%%: 4704-block 4
        3: 4705:   stbi__context *s = a->s;
        3: 4706:   stbi__uint32 i,j,stride = x*out_n*bytes;
        -: 4707:   stbi__uint32 img_len, img_width_bytes;
        -: 4708:   stbi_uc *filter_buf;
        3: 4709:   int all_ok = 1;
        -: 4710:   int k;
        3: 4711:   int img_n = s->img_n; // copy it into a local for later
        -: 4712:
        3: 4713:   int output_bytes = out_n*bytes;
        3: 4714:   int filter_bytes = img_n*bytes;
        3: 4715:   int width = x;
        -: 4716:
       3*: 4717:   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
        3: 4717-block 5
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2: 4717-block 6
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    %%%%%: 4717-block 7
call    4 never executed
        3: 4718:   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
        3: 4718-block 8
call    0 returned 3
       3*: 4719:   if (!a->out) return stbi__err("outofmem", "Out of memory");
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 4719-block 10
call    2 never executed
        -: 4720:
        -: 4721:   // note: error exits here don't need to clean up a->out individually,
        -: 4722:   // stbi__do_png always does on error.
       3*: 4723:   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
        3: 4723-block 11
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    %%%%%: 4723-block 13
call    3 never executed
        3: 4724:   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
       3*: 4725:   if (!stbi__mad2sizes_valid(img_width_bytes, y, img_width_bytes)) return stbi__err("too large", "Corrupt PNG");
        3: 4725-block 14
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    %%%%%: 4725-block 16
call    3 never executed
        3: 4726:   img_len = (img_width_bytes + 1) * y;
        -: 4727:
        -: 4728:   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
        -: 4729:   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
        -: 4730:   // so just check for raw_len < img_len always.
       3*: 4731:   if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
        3: 4731-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 4731-block 18
call    2 never executed
        -: 4732:
        -: 4733:   // Allocate two scan lines worth of filter workspace buffer.
        3: 4734:   filter_buf = (stbi_uc *) stbi__malloc_mad2(img_width_bytes, 2, 0);
        3: 4734-block 19
call    0 returned 3
       3*: 4735:   if (!filter_buf) return stbi__err("outofmem", "Out of memory");
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 4735-block 21
call    2 never executed
        -: 4736:
        -: 4737:   // Filtering for low-bit-depth images
        3: 4738:   if (depth < 8) {
        3: 4738-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 4739:      filter_bytes = 1;
    #####: 4740:      width = img_width_bytes;
    %%%%%: 4740-block 23
        -: 4741:   }
        -: 4742:
     3075: 4743:   for (j=0; j < y; ++j) {
        3: 4743-block 24
     3072: 4743-block 104
     3075: 4743-block 105
branch  0 taken 3072
branch  1 taken 3 (fallthrough)
        -: 4744:      // cur/prior filter buffers alternate
     3072: 4745:      stbi_uc *cur = filter_buf + (j & 1)*img_width_bytes;
     3072: 4746:      stbi_uc *prior = filter_buf + (~j & 1)*img_width_bytes;
     3072: 4747:      stbi_uc *dest = a->out + stride*j;
     3072: 4748:      int nk = width * filter_bytes;
     3072: 4749:      int filter = *raw++;
        -: 4750:
        -: 4751:      // check filter type
     3072: 4752:      if (filter > 4) {
     3072: 4752-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 3072
    #####: 4753:         all_ok = stbi__err("invalid filter","Corrupt PNG");
    %%%%%: 4753-block 26
call    0 never executed
    #####: 4754:         break;
        -: 4755:      }
        -: 4756:
        -: 4757:      // if first row, use special filter that doesn't sample previous row
     3072: 4758:      if (j == 0) filter = first_row_filter[filter];
     3072: 4758-block 28
branch  0 taken 3 (fallthrough)
branch  1 taken 3069
        3: 4758-block 29
        -: 4759:
        -: 4760:      // perform actual filtering
     3072: 4761:      switch (filter) {
     3072: 4761-block 30
branch  0 taken 0
branch  1 taken 683
branch  2 taken 1220
branch  3 taken 581
branch  4 taken 588
branch  5 taken 0
branch  6 taken 0
    #####: 4762:      case STBI__F_none:
    #####: 4763:         memcpy(cur, raw, nk);
    #####: 4764:         break;
    %%%%%: 4764-block 31
      683: 4765:      case STBI__F_sub:
      683: 4766:         memcpy(cur, raw, filter_bytes);
  4675793: 4767:         for (k = filter_bytes; k < nk; ++k)
      683: 4767-block 32
  4675793: 4767-block 34
branch  0 taken 4675110
branch  1 taken 683 (fallthrough)
  4675110: 4768:            cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]);
  4675110: 4768-block 33
      683: 4769:         break;
      683: 4769-block 35
     1220: 4770:      case STBI__F_up:
  8682692: 4771:         for (k = 0; k < nk; ++k)
     1220: 4771-block 36
  8682692: 4771-block 38
branch  0 taken 8681472
branch  1 taken 1220 (fallthrough)
  8681472: 4772:            cur[k] = STBI__BYTECAST(raw[k] + prior[k]);
  8681472: 4772-block 37
     1220: 4773:         break;
     1220: 4773-block 39
      581: 4774:      case STBI__F_avg:
     4153: 4775:         for (k = 0; k < filter_bytes; ++k)
      581: 4775-block 40
     4153: 4775-block 42
branch  0 taken 3572
branch  1 taken 581 (fallthrough)
     3572: 4776:            cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1));
     3572: 4776-block 41
  3654737: 4777:         for (k = filter_bytes; k < nk; ++k)
      581: 4777-block 43
  3654737: 4777-block 45
branch  0 taken 3654156
branch  1 taken 581 (fallthrough)
  3654156: 4778:            cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1));
  3654156: 4778-block 44
      581: 4779:         break;
      581: 4779-block 46
      588: 4780:      case STBI__F_paeth:
     4448: 4781:         for (k = 0; k < filter_bytes; ++k)
      588: 4781-block 47
     4448: 4781-block 49
branch  0 taken 3860
branch  1 taken 588 (fallthrough)
     3860: 4782:            cur[k] = STBI__BYTECAST(raw[k] + prior[k]); // prior[k] == stbi__paeth(0,prior[k],0)
     3860: 4782-block 48
  3949368: 4783:         for (k = filter_bytes; k < nk; ++k)
      588: 4783-block 50
  3949368: 4783-block 53
branch  0 taken 3948780
branch  1 taken 588 (fallthrough)
  3948780: 4784:            cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes], prior[k], prior[k-filter_bytes]));
  3948780: 4784-block 51
call    0 returned 3948780
      588: 4785:         break;
      588: 4785-block 54
    #####: 4786:      case STBI__F_avg_first:
    #####: 4787:         memcpy(cur, raw, filter_bytes);
    #####: 4788:         for (k = filter_bytes; k < nk; ++k)
    %%%%%: 4788-block 55
    %%%%%: 4788-block 57
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4789:            cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1));
    %%%%%: 4789-block 56
    #####: 4790:         break;
    %%%%%: 4790-block 58
        -: 4791:      }
        -: 4792:
     3072: 4793:      raw += nk;
        -: 4794:
        -: 4795:      // expand decoded bits in cur to dest, also adding an extra alpha channel if desired
     3072: 4796:      if (depth < 8) {
     3072: 4796-block 59
branch  0 taken 0 (fallthrough)
branch  1 taken 3072
    #####: 4797:         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
    %%%%%: 4797-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4797-block 61
    %%%%%: 4797-block 62
    #####: 4798:         stbi_uc *in = cur;
    #####: 4799:         stbi_uc *out = dest;
    #####: 4800:         stbi_uc inb = 0;
    #####: 4801:         stbi__uint32 nsmp = x*img_n;
        -: 4802:
        -: 4803:         // expand bits to bytes first
    #####: 4804:         if (depth == 4) {
    %%%%%: 4804-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4805:            for (i=0; i < nsmp; ++i) {
    %%%%%: 4805-block 64
    %%%%%: 4805-block 68
branch  0 never executed
branch  1 never executed
    #####: 4806:               if ((i & 1) == 0) inb = *in++;
    %%%%%: 4806-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4806-block 66
    #####: 4807:               *out++ = scale * (inb >> 4);
    #####: 4808:               inb <<= 4;
    %%%%%: 4808-block 67
        -: 4809:            }
    #####: 4810:         } else if (depth == 2) {
    %%%%%: 4810-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4811:            for (i=0; i < nsmp; ++i) {
    %%%%%: 4811-block 70
    %%%%%: 4811-block 74
branch  0 never executed
branch  1 never executed
    #####: 4812:               if ((i & 3) == 0) inb = *in++;
    %%%%%: 4812-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4812-block 72
    #####: 4813:               *out++ = scale * (inb >> 6);
    #####: 4814:               inb <<= 2;
    %%%%%: 4814-block 73
        -: 4815:            }
        -: 4816:         } else {
    #####: 4817:            STBI_ASSERT(depth == 1);
    %%%%%: 4817-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4817-block 76
call    2 never executed
    #####: 4818:            for (i=0; i < nsmp; ++i) {
    %%%%%: 4818-block 77
    %%%%%: 4818-block 81
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4819:               if ((i & 7) == 0) inb = *in++;
    %%%%%: 4819-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4819-block 79
    #####: 4820:               *out++ = scale * (inb >> 7);
    #####: 4821:               inb <<= 1;
    %%%%%: 4821-block 80
        -: 4822:            }
        -: 4823:         }
        -: 4824:
        -: 4825:         // insert alpha=255 values if desired
    #####: 4826:         if (img_n != out_n)
    %%%%%: 4826-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4827:            stbi__create_png_alpha_expand8(dest, dest, x, img_n);
    %%%%%: 4827-block 83
call    0 never executed
     3072: 4828:      } else if (depth == 8) {
     3072: 4828-block 84
branch  0 taken 0 (fallthrough)
branch  1 taken 3072
    #####: 4829:         if (img_n == out_n)
    %%%%%: 4829-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4830:            memcpy(dest, cur, x*img_n);
    %%%%%: 4830-block 86
        -: 4831:         else
    #####: 4832:            stbi__create_png_alpha_expand8(dest, cur, x, img_n);
    %%%%%: 4832-block 87
call    0 never executed
     3072: 4833:      } else if (depth == 16) {
     3072: 4833-block 88
branch  0 taken 3072 (fallthrough)
branch  1 taken 0
        -: 4834:         // convert the image data from big-endian to platform-native
     3072: 4835:         stbi__uint16 *dest16 = (stbi__uint16*)dest;
     3072: 4836:         stbi__uint32 nsmp = x*img_n;
        -: 4837:
     3072: 4838:         if (img_n == out_n) {
     3072: 4838-block 89
branch  0 taken 1024 (fallthrough)
branch  1 taken 2048
  4195328: 4839:            for (i = 0; i < nsmp; ++i, ++dest16, cur += 2)
     1024: 4839-block 90
  4195328: 4839-block 92
branch  0 taken 4194304
branch  1 taken 1024
  4194304: 4840:               *dest16 = (cur[0] << 8) | cur[1];
  4194304: 4840-block 91
        -: 4841:         } else {
    2048*: 4842:            STBI_ASSERT(img_n+1 == out_n);
     2048: 4842-block 93
branch  0 taken 0 (fallthrough)
branch  1 taken 2048
    %%%%%: 4842-block 94
call    2 never executed
     2048: 4843:            if (img_n == 1) {
     2048: 4843-block 95
branch  0 taken 0 (fallthrough)
branch  1 taken 2048
    #####: 4844:               for (i = 0; i < x; ++i, dest16 += 2, cur += 2) {
    %%%%%: 4844-block 96
    %%%%%: 4844-block 98
branch  0 never executed
branch  1 never executed
    #####: 4845:                  dest16[0] = (cur[0] << 8) | cur[1];
    #####: 4846:                  dest16[1] = 0xffff;
    %%%%%: 4846-block 97
        -: 4847:               }
        -: 4848:            } else {
    2048*: 4849:               STBI_ASSERT(img_n == 3);
     2048: 4849-block 99
branch  0 taken 0 (fallthrough)
branch  1 taken 2048
    %%%%%: 4849-block 100
call    2 never executed
  2099200: 4850:               for (i = 0; i < x; ++i, dest16 += 4, cur += 6) {
     2048: 4850-block 101
  2099200: 4850-block 103
branch  0 taken 2097152
branch  1 taken 2048 (fallthrough)
  2097152: 4851:                  dest16[0] = (cur[0] << 8) | cur[1];
  2097152: 4852:                  dest16[1] = (cur[2] << 8) | cur[3];
  2097152: 4853:                  dest16[2] = (cur[4] << 8) | cur[5];
  2097152: 4854:                  dest16[3] = 0xffff;
  2097152: 4854-block 102
        -: 4855:               }
        -: 4856:            }
        -: 4857:         }
        -: 4858:      }
        -: 4859:   }
        -: 4860:
        3: 4861:   STBI_FREE(filter_buf);
       3*: 4862:   if (!all_ok) return 0;
        3: 4862-block 106
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 4862-block 107
        -: 4863:
        3: 4864:   return 1;
        3: 4864-block 108
        -: 4865:}
        -: 4866:
function _ZL22stbi__create_png_imageP9stbi__pngPhjiiii called 3 returned 100% blocks executed 20%
        3: 4867:static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
        -: 4868:{
       3*: 4869:   int bytes = (depth == 16 ? 2 : 1);
        3: 4869-block 2
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 4869-block 3
    %%%%%: 4869-block 4
        3: 4870:   int out_bytes = out_n * bytes;
        -: 4871:   stbi_uc *final;
        -: 4872:   int p;
        3: 4873:   if (!interlaced)
        3: 4873-block 5
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 4874:      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
        3: 4874-block 6
call    0 returned 3
        -: 4875:
        -: 4876:   // de-interlacing
    #####: 4877:   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
    %%%%%: 4877-block 7
call    0 never executed
    #####: 4878:   if (!final) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4878-block 9
call    2 never executed
    #####: 4879:   for (p=0; p < 7; ++p) {
    %%%%%: 4879-block 10
    %%%%%: 4879-block 23
    %%%%%: 4879-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4880:      int xorig[] = { 0,4,0,2,0,1,0 };
    #####: 4881:      int yorig[] = { 0,0,4,0,2,0,1 };
    #####: 4882:      int xspc[]  = { 8,8,4,4,2,2,1 };
    #####: 4883:      int yspc[]  = { 8,8,8,4,4,2,2 };
        -: 4884:      int i,j,x,y;
        -: 4885:      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
    #####: 4886:      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
    #####: 4887:      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
    #####: 4888:      if (x && y) {
    %%%%%: 4888-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4888-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4889:         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
    #####: 4890:         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
    %%%%%: 4890-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4891:            STBI_FREE(final);
    #####: 4892:            return 0;
    %%%%%: 4892-block 15
        -: 4893:         }
    #####: 4894:         for (j=0; j < y; ++j) {
    %%%%%: 4894-block 16
    %%%%%: 4894-block 20
    %%%%%: 4894-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4895:            for (i=0; i < x; ++i) {
    %%%%%: 4895-block 17
    %%%%%: 4895-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4896:               int out_y = j*yspc[p]+yorig[p];
    #####: 4897:               int out_x = i*xspc[p]+xorig[p];
    #####: 4898:               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
    #####: 4899:                      a->out + (j*x+i)*out_bytes, out_bytes);
    %%%%%: 4899-block 18
        -: 4900:            }
        -: 4901:         }
    #####: 4902:         STBI_FREE(a->out);
    #####: 4903:         image_data += img_len;
    #####: 4904:         image_data_len -= img_len;
    %%%%%: 4904-block 22
        -: 4905:      }
        -: 4906:   }
    #####: 4907:   a->out = final;
        -: 4908:
    #####: 4909:   return 1;
    %%%%%: 4909-block 25
        -: 4910:}
        -: 4911:
function _ZL26stbi__compute_transparencyP9stbi__pngPhi called 0 returned 0% blocks executed 0%
    #####: 4912:static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
        -: 4913:{
    #####: 4914:   stbi__context *s = z->s;
    #####: 4915:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    #####: 4916:   stbi_uc *p = z->out;
        -: 4917:
        -: 4918:   // compute color-based transparency, assuming we've
        -: 4919:   // already got 255 as the alpha value in the output
    #####: 4920:   STBI_ASSERT(out_n == 2 || out_n == 4);
    %%%%%: 4920-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4920-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4920-block 4
call    4 never executed
        -: 4921:
    #####: 4922:   if (out_n == 2) {
    %%%%%: 4922-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4923:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4923-block 6
    %%%%%: 4923-block 11
branch  0 never executed
branch  1 never executed
    #####: 4924:         p[1] = (p[0] == tc[0] ? 0 : 255);
    %%%%%: 4924-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4924-block 8
    %%%%%: 4924-block 9
    #####: 4925:         p += 2;
    %%%%%: 4925-block 10
        -: 4926:      }
        -: 4927:   } else {
    #####: 4928:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4928-block 12
    %%%%%: 4928-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4929:         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
    %%%%%: 4929-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4929-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4929-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4930:            p[3] = 0;
    %%%%%: 4930-block 16
    #####: 4931:         p += 4;
    %%%%%: 4931-block 17
        -: 4932:      }
        -: 4933:   }
    #####: 4934:   return 1;
    %%%%%: 4934-block 19
        -: 4935:}
        -: 4936:
function _ZL28stbi__compute_transparency16P9stbi__pngPti called 0 returned 0% blocks executed 0%
    #####: 4937:static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
        -: 4938:{
    #####: 4939:   stbi__context *s = z->s;
    #####: 4940:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    #####: 4941:   stbi__uint16 *p = (stbi__uint16*) z->out;
        -: 4942:
        -: 4943:   // compute color-based transparency, assuming we've
        -: 4944:   // already got 65535 as the alpha value in the output
    #####: 4945:   STBI_ASSERT(out_n == 2 || out_n == 4);
    %%%%%: 4945-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4945-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4945-block 4
call    4 never executed
        -: 4946:
    #####: 4947:   if (out_n == 2) {
    %%%%%: 4947-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4948:      for (i = 0; i < pixel_count; ++i) {
    %%%%%: 4948-block 6
    %%%%%: 4948-block 11
branch  0 never executed
branch  1 never executed
    #####: 4949:         p[1] = (p[0] == tc[0] ? 0 : 65535);
    %%%%%: 4949-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4949-block 8
    %%%%%: 4949-block 9
    #####: 4950:         p += 2;
    %%%%%: 4950-block 10
        -: 4951:      }
        -: 4952:   } else {
    #####: 4953:      for (i = 0; i < pixel_count; ++i) {
    %%%%%: 4953-block 12
    %%%%%: 4953-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4954:         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
    %%%%%: 4954-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4954-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4954-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4955:            p[3] = 0;
    %%%%%: 4955-block 16
    #####: 4956:         p += 4;
    %%%%%: 4956-block 17
        -: 4957:      }
        -: 4958:   }
    #####: 4959:   return 1;
    %%%%%: 4959-block 19
        -: 4960:}
        -: 4961:
function _ZL24stbi__expand_png_paletteP9stbi__pngPhii called 0 returned 0% blocks executed 0%
    #####: 4962:static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
        -: 4963:{
    #####: 4964:   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
    #####: 4965:   stbi_uc *p, *temp_out, *orig = a->out;
        -: 4966:
    #####: 4967:   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
    %%%%%: 4967-block 2
call    0 never executed
    #####: 4968:   if (p == NULL) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4968-block 4
call    2 never executed
        -: 4969:
        -: 4970:   // between here and free(out) below, exitting would leak
    #####: 4971:   temp_out = p;
        -: 4972:
    #####: 4973:   if (pal_img_n == 3) {
    %%%%%: 4973-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4974:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4974-block 6
    %%%%%: 4974-block 8
branch  0 never executed
branch  1 never executed
    #####: 4975:         int n = orig[i]*4;
    #####: 4976:         p[0] = palette[n  ];
    #####: 4977:         p[1] = palette[n+1];
    #####: 4978:         p[2] = palette[n+2];
    #####: 4979:         p += 3;
    %%%%%: 4979-block 7
        -: 4980:      }
        -: 4981:   } else {
    #####: 4982:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4982-block 9
    %%%%%: 4982-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4983:         int n = orig[i]*4;
    #####: 4984:         p[0] = palette[n  ];
    #####: 4985:         p[1] = palette[n+1];
    #####: 4986:         p[2] = palette[n+2];
    #####: 4987:         p[3] = palette[n+3];
    #####: 4988:         p += 4;
    %%%%%: 4988-block 10
        -: 4989:      }
        -: 4990:   }
    #####: 4991:   STBI_FREE(a->out);
    #####: 4992:   a->out = temp_out;
        -: 4993:
        -: 4994:   STBI_NOTUSED(len);
        -: 4995:
    #####: 4996:   return 1;
    %%%%%: 4996-block 12
        -: 4997:}
        -: 4998:
        -: 4999:static int stbi__unpremultiply_on_load_global = 0;
        -: 5000:static int stbi__de_iphone_flag_global = 0;
        -: 5001:
function stbi_set_unpremultiply_on_load called 0 returned 0% blocks executed 0%
    #####: 5002:STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
        -: 5003:{
    #####: 5004:   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
    #####: 5005:}
        -: 5006:
function stbi_convert_iphone_png_to_rgb called 0 returned 0% blocks executed 0%
    #####: 5007:STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
        -: 5008:{
    #####: 5009:   stbi__de_iphone_flag_global = flag_true_if_should_convert;
    #####: 5010:}
        -: 5011:
        -: 5012:#ifndef STBI_THREAD_LOCAL
        -: 5013:#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
        -: 5014:#define stbi__de_iphone_flag  stbi__de_iphone_flag_global
        -: 5015:#else
        -: 5016:static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
        -: 5017:static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
        -: 5018:
function stbi_set_unpremultiply_on_load_thread called 0 returned 0% blocks executed 0%
    #####: 5019:STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
        -: 5020:{
    #####: 5021:   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
    #####: 5022:   stbi__unpremultiply_on_load_set = 1;
    #####: 5023:}
        -: 5024:
function stbi_convert_iphone_png_to_rgb_thread called 0 returned 0% blocks executed 0%
    #####: 5025:STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
        -: 5026:{
    #####: 5027:   stbi__de_iphone_flag_local = flag_true_if_should_convert;
    #####: 5028:   stbi__de_iphone_flag_set = 1;
    #####: 5029:}
        -: 5030:
        -: 5031:#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
        -: 5032:                                       ? stbi__unpremultiply_on_load_local      \
        -: 5033:                                       : stbi__unpremultiply_on_load_global)
        -: 5034:#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
        -: 5035:                                ? stbi__de_iphone_flag_local                    \
        -: 5036:                                : stbi__de_iphone_flag_global)
        -: 5037:#endif // STBI_THREAD_LOCAL
        -: 5038:
function _ZL15stbi__de_iphoneP9stbi__png called 0 returned 0% blocks executed 0%
    #####: 5039:static void stbi__de_iphone(stbi__png *z)
        -: 5040:{
    #####: 5041:   stbi__context *s = z->s;
    #####: 5042:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    #####: 5043:   stbi_uc *p = z->out;
        -: 5044:
    #####: 5045:   if (s->img_out_n == 3) {  // convert bgr to rgb
    %%%%%: 5045-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5046:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 5046-block 3
    %%%%%: 5046-block 5
branch  0 never executed
branch  1 never executed
    #####: 5047:         stbi_uc t = p[0];
    #####: 5048:         p[0] = p[2];
    #####: 5049:         p[2] = t;
    #####: 5050:         p += 3;
    %%%%%: 5050-block 4
        -: 5051:      }
        -: 5052:   } else {
    #####: 5053:      STBI_ASSERT(s->img_out_n == 4);
    %%%%%: 5053-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5053-block 7
call    2 never executed
    #####: 5054:      if (stbi__unpremultiply_on_load) {
    %%%%%: 5054-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5054-block 9
    %%%%%: 5054-block 10
    %%%%%: 5054-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5055:         // convert bgr to rgb and unpremultiply
    #####: 5056:         for (i=0; i < pixel_count; ++i) {
    %%%%%: 5056-block 12
    %%%%%: 5056-block 17
branch  0 never executed
branch  1 never executed
    #####: 5057:            stbi_uc a = p[3];
    #####: 5058:            stbi_uc t = p[0];
    #####: 5059:            if (a) {
    %%%%%: 5059-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5060:               stbi_uc half = a / 2;
    #####: 5061:               p[0] = (p[2] * 255 + half) / a;
    #####: 5062:               p[1] = (p[1] * 255 + half) / a;
    #####: 5063:               p[2] = ( t   * 255 + half) / a;
    %%%%%: 5063-block 14
        -: 5064:            } else {
    #####: 5065:               p[0] = p[2];
    #####: 5066:               p[2] = t;
    %%%%%: 5066-block 15
        -: 5067:            }
    #####: 5068:            p += 4;
    %%%%%: 5068-block 16
        -: 5069:         }
        -: 5070:      } else {
        -: 5071:         // convert bgr to rgb
    #####: 5072:         for (i=0; i < pixel_count; ++i) {
    %%%%%: 5072-block 18
    %%%%%: 5072-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5073:            stbi_uc t = p[0];
    #####: 5074:            p[0] = p[2];
    #####: 5075:            p[2] = t;
    #####: 5076:            p += 4;
    %%%%%: 5076-block 19
        -: 5077:         }
        -: 5078:      }
        -: 5079:   }
    #####: 5080:}
        -: 5081:
        -: 5082:#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
        -: 5083:
function _ZL20stbi__parse_png_fileP9stbi__pngii called 3 returned 100% blocks executed 43%
        3: 5084:static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
        -: 5085:{
        3: 5086:   stbi_uc palette[1024], pal_img_n=0;
        3: 5087:   stbi_uc has_trans=0, tc[3]={0};
        -: 5088:   stbi__uint16 tc16[3];
        3: 5089:   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
        3: 5090:   int first=1,k,interlace=0, color=0, is_iphone=0;
        3: 5091:   stbi__context *s = z->s;
        -: 5092:
        3: 5093:   z->expanded = NULL;
        3: 5094:   z->idata = NULL;
        3: 5095:   z->out = NULL;
        -: 5096:
       3*: 5097:   if (!stbi__check_png_header(s)) return 0;
        3: 5097-block 2
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 5097-block 3
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    %%%%%: 5097-block 4
        -: 5098:
       3*: 5099:   if (scan == STBI__SCAN_type) return 1;
        3: 5099-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5099-block 6
        -: 5100:
        -: 5101:   for (;;) {
     1824: 5102:      stbi__pngchunk c = stbi__get_chunk_header(s);
     1824: 5102-block 7
call    0 returned 1824
branch  1 taken 1824 (fallthrough)
branch  2 taken 0 (throw)
     1824: 5103:      switch (c.type) {
     1824: 5103-block 8
branch  0 taken 0
branch  1 taken 3
branch  2 taken 0
branch  3 taken 0
branch  4 taken 1780
branch  5 taken 3
branch  6 taken 38
    #####: 5104:         case STBI__PNG_TYPE('C','g','B','I'):
    #####: 5105:            is_iphone = 1;
    #####: 5106:            stbi__skip(s, c.length);
    %%%%%: 5106-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5107:            break;
    %%%%%: 5107-block 10
        3: 5108:         case STBI__PNG_TYPE('I','H','D','R'): {
        -: 5109:            int comp,filter;
       6*: 5110:            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
        3: 5110-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5110-block 12
call    2 never executed
        3: 5110-block 183
        3: 5111:            first = 0;
       3*: 5112:            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
        3: 5112-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5112-block 14
call    2 never executed
        3: 5113:            s->img_x = stbi__get32be(s);
        3: 5113-block 15
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 5114:            s->img_y = stbi__get32be(s);
        3: 5114-block 16
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
       3*: 5115:            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
        3: 5115-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5115-block 18
call    2 never executed
       3*: 5116:            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
        3: 5116-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5116-block 20
call    2 never executed
       3*: 5117:            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
        3: 5117-block 21
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 5117-block 22
branch  3 taken 3 (fallthrough)
branch  4 taken 0
        3: 5117-block 23
branch  5 taken 3 (fallthrough)
branch  6 taken 0
        3: 5117-block 24
branch  7 taken 3 (fallthrough)
branch  8 taken 0
        3: 5117-block 25
branch  9 taken 3 (fallthrough)
branch 10 taken 0
        3: 5117-block 26
branch 11 taken 0 (fallthrough)
branch 12 taken 3
    %%%%%: 5117-block 27
call   13 never executed
       3*: 5118:            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
        3: 5118-block 28
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 5118-block 29
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    %%%%%: 5118-block 30
call    5 never executed
       3*: 5119:            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
        3: 5119-block 31
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5119-block 32
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5119-block 33
call    4 never executed
       3*: 5120:            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
        3: 5120-block 34
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5120-block 35
        3: 5120-block 36
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    %%%%%: 5120-block 37
call    4 never executed
       3*: 5121:            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
        3: 5121-block 38
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 5121-block 39
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    %%%%%: 5121-block 40
call    5 never executed
       3*: 5122:            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
        3: 5122-block 41
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 5122-block 42
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    %%%%%: 5122-block 43
call    5 never executed
       3*: 5123:            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
        3: 5123-block 44
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 5123-block 45
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    %%%%%: 5123-block 46
call    5 never executed
       3*: 5124:            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
        3: 5124-block 47
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5124-block 48
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    %%%%%: 5124-block 49
call    4 never executed
        3: 5125:            if (!pal_img_n) {
        3: 5125-block 50
branch  0 taken 3 (fallthrough)
branch  1 taken 0
       3*: 5126:               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
        3: 5126-block 51
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5126-block 52
    %%%%%: 5126-block 53
       3*: 5127:               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
        3: 5127-block 54
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5127-block 55
call    2 never executed
        -: 5128:            } else {
        -: 5129:               // if paletted, then pal_n is our final components, and
        -: 5130:               // img_n is # components to decompress/filter.
    #####: 5131:               s->img_n = 1;
    #####: 5132:               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
    %%%%%: 5132-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5132-block 57
call    2 never executed
        -: 5133:            }
        -: 5134:            // even with SCAN_header, have to scan to see if we have a tRNS
        3: 5135:            break;
        3: 5135-block 58
        -: 5136:         }
        -: 5137:
    #####: 5138:         case STBI__PNG_TYPE('P','L','T','E'):  {
    #####: 5139:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
    %%%%%: 5139-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5139-block 60
call    2 never executed
    #####: 5140:            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
    %%%%%: 5140-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5140-block 62
call    2 never executed
    #####: 5141:            pal_len = c.length / 3;
    #####: 5142:            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
    %%%%%: 5142-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5142-block 64
call    2 never executed
    #####: 5143:            for (i=0; i < pal_len; ++i) {
    %%%%%: 5143-block 65
    %%%%%: 5143-block 70
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5144:               palette[i*4+0] = stbi__get8(s);
    %%%%%: 5144-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5145:               palette[i*4+1] = stbi__get8(s);
    %%%%%: 5145-block 67
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5146:               palette[i*4+2] = stbi__get8(s);
    %%%%%: 5146-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5147:               palette[i*4+3] = 255;
    %%%%%: 5147-block 69
        -: 5148:            }
    #####: 5149:            break;
    %%%%%: 5149-block 71
        -: 5150:         }
        -: 5151:
    #####: 5152:         case STBI__PNG_TYPE('t','R','N','S'): {
    #####: 5153:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
    %%%%%: 5153-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5153-block 73
call    2 never executed
    #####: 5154:            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
    %%%%%: 5154-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5154-block 75
call    2 never executed
    #####: 5155:            if (pal_img_n) {
    %%%%%: 5155-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5156:               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
    %%%%%: 5156-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5156-block 78
    #####: 5157:               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
    %%%%%: 5157-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5157-block 80
call    2 never executed
    #####: 5158:               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
    %%%%%: 5158-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5158-block 82
call    2 never executed
    #####: 5159:               pal_img_n = 4;
    #####: 5160:               for (i=0; i < c.length; ++i)
    %%%%%: 5160-block 83
    %%%%%: 5160-block 86
branch  0 never executed
branch  1 never executed
    #####: 5161:                  palette[i*4+3] = stbi__get8(s);
    %%%%%: 5161-block 84
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5161-block 85
        -: 5162:            } else {
    #####: 5163:               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
    %%%%%: 5163-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5163-block 88
call    2 never executed
    #####: 5164:               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
    %%%%%: 5164-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5164-block 90
call    2 never executed
    #####: 5165:               has_trans = 1;
        -: 5166:               // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
    #####: 5167:               if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
    %%%%%: 5167-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5167-block 92
    #####: 5168:               if (z->depth == 16) {
    %%%%%: 5168-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5169:                  for (k = 0; k < s->img_n && k < 3; ++k) // extra loop test to suppress false GCC warning
    %%%%%: 5169-block 94
    %%%%%: 5169-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5169-block 98
branch  2 never executed
branch  3 never executed
    #####: 5170:                     tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
    %%%%%: 5170-block 95
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5170-block 96
        -: 5171:               } else {
    #####: 5172:                  for (k = 0; k < s->img_n && k < 3; ++k)
    %%%%%: 5172-block 99
    %%%%%: 5172-block 102
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5172-block 103
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 5173:                     tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
    %%%%%: 5173-block 100
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5173-block 101
        -: 5174:               }
        -: 5175:            }
    #####: 5176:            break;
    %%%%%: 5176-block 104
        -: 5177:         }
        -: 5178:
     1780: 5179:         case STBI__PNG_TYPE('I','D','A','T'): {
    1780*: 5180:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
     1780: 5180-block 105
branch  0 taken 0 (fallthrough)
branch  1 taken 1780
    %%%%%: 5180-block 106
call    2 never executed
    1780*: 5181:            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
     1780: 5181-block 107
branch  0 taken 0 (fallthrough)
branch  1 taken 1780
    %%%%%: 5181-block 108
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5181-block 109
call    4 never executed
     1780: 5182:            if (scan == STBI__SCAN_header) {
     1780: 5182-block 110
branch  0 taken 0 (fallthrough)
branch  1 taken 1780
        -: 5183:               // header scan definitely stops at first IDAT
    #####: 5184:               if (pal_img_n)
    %%%%%: 5184-block 111
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5185:                  s->img_n = pal_img_n;
    %%%%%: 5185-block 112
    #####: 5186:               return 1;
    %%%%%: 5186-block 113
        -: 5187:            }
    1780*: 5188:            if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
     1780: 5188-block 114
branch  0 taken 0 (fallthrough)
branch  1 taken 1780
    %%%%%: 5188-block 115
call    2 never executed
    1780*: 5189:            if ((int)(ioff + c.length) < (int)ioff) return 0;
     1780: 5189-block 116
branch  0 taken 0 (fallthrough)
branch  1 taken 1780
    %%%%%: 5189-block 117
     1780: 5190:            if (ioff + c.length > idata_limit) {
     1780: 5190-block 118
branch  0 taken 32 (fallthrough)
branch  1 taken 1748
       32: 5191:               stbi__uint32 idata_limit_old = idata_limit;
        -: 5192:               stbi_uc *p;
       32: 5193:               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
       32: 5193-block 119
branch  0 taken 3 (fallthrough)
branch  1 taken 29
        3: 5193-block 120
       61: 5194:               while (ioff + c.length > idata_limit)
       32: 5194-block 121
       61: 5194-block 123
branch  0 taken 29
branch  1 taken 32 (fallthrough)
       29: 5195:                  idata_limit *= 2;
       29: 5195-block 122
        -: 5196:               STBI_NOTUSED(idata_limit_old);
      32*: 5197:               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
       32: 5197-block 124
branch  0 taken 0 (fallthrough)
branch  1 taken 32
    %%%%%: 5197-block 125
call    2 never executed
       32: 5198:               z->idata = p;
       32: 5198-block 126
        -: 5199:            }
    1780*: 5200:            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
     1780: 5200-block 127
call    0 returned 1780
branch  1 taken 1780 (fallthrough)
branch  2 taken 0 (throw)
     1780: 5200-block 128
branch  3 taken 0 (fallthrough)
branch  4 taken 1780
    %%%%%: 5200-block 129
call    5 never executed
     1780: 5201:            ioff += c.length;
     1780: 5202:            break;
     1780: 5202-block 130
        -: 5203:         }
        -: 5204:
        3: 5205:         case STBI__PNG_TYPE('I','E','N','D'): {
        -: 5206:            stbi__uint32 raw_len, bpl;
       3*: 5207:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
        3: 5207-block 131
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5207-block 132
call    2 never executed
       3*: 5208:            if (scan != STBI__SCAN_load) return 1;
        3: 5208-block 133
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5208-block 134
       3*: 5209:            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
        3: 5209-block 135
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5209-block 136
call    2 never executed
        -: 5210:            // initial guess for decoded data size to avoid unnecessary reallocs
        3: 5211:            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
        3: 5212:            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
        3: 5213:            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
        3: 5213-block 137
call    0 returned 3
       3*: 5214:            if (z->expanded == NULL) return 0; // zlib should set error
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5214-block 139
        3: 5215:            STBI_FREE(z->idata); z->idata = NULL;
        3: 5216:            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
        3: 5216-block 140
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2: 5216-block 141
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 5216-block 142
branch  4 taken 0 (fallthrough)
branch  5 taken 2
        1: 5216-block 143
branch  6 taken 0 (fallthrough)
branch  7 taken 1
        2: 5217:               s->img_out_n = s->img_n+1;
        2: 5217-block 144
        -: 5218:            else
        1: 5219:               s->img_out_n = s->img_n;
        1: 5219-block 145
       3*: 5220:            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
        3: 5220-block 146
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    %%%%%: 5220-block 148
        3: 5221:            if (has_trans) {
        3: 5221-block 149
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 5222:               if (z->depth == 16) {
    %%%%%: 5222-block 150
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5223:                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
    %%%%%: 5223-block 151
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5223-block 153
        -: 5224:               } else {
    #####: 5225:                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
    %%%%%: 5225-block 154
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5225-block 156
        -: 5226:               }
        -: 5227:            }
       3*: 5228:            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
        3: 5228-block 157
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 5228-block 158
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5228-block 159
    %%%%%: 5228-block 160
    %%%%%: 5228-block 161
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5228-block 162
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 5229:               stbi__de_iphone(z);
    %%%%%: 5229-block 163
call    0 never executed
        3: 5230:            if (pal_img_n) {
        3: 5230-block 164
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 5231:               // pal_img_n == 3 or 4
    #####: 5232:               s->img_n = pal_img_n; // record the actual colors we had
    #####: 5233:               s->img_out_n = pal_img_n;
    #####: 5234:               if (req_comp >= 3) s->img_out_n = req_comp;
    %%%%%: 5234-block 165
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5234-block 166
    #####: 5235:               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
    %%%%%: 5235-block 167
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5236:                  return 0;
    %%%%%: 5236-block 169
        3: 5237:            } else if (has_trans) {
        3: 5237-block 170
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 5238:               // non-paletted image with tRNS -> source image has (constant) alpha
    #####: 5239:               ++s->img_n;
    %%%%%: 5239-block 171
        -: 5240:            }
        3: 5241:            STBI_FREE(z->expanded); z->expanded = NULL;
        -: 5242:            // end of PNG chunk, read and skip CRC
        3: 5243:            stbi__get32be(s);
        3: 5243-block 172
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 5244:            return 1;
        3: 5244-block 173
        -: 5245:         }
        -: 5246:
       38: 5247:         default:
        -: 5248:            // if critical, fail
      38*: 5249:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
       38: 5249-block 175
branch  0 taken 0 (fallthrough)
branch  1 taken 38
    %%%%%: 5249-block 176
call    2 never executed
       38: 5250:            if ((c.type & (1 << 29)) == 0) {
       38: 5250-block 177
branch  0 taken 0 (fallthrough)
branch  1 taken 38
        -: 5251:               #ifndef STBI_NO_FAILURE_STRINGS
        -: 5252:               // not threadsafe
        -: 5253:               static char invalid_chunk[] = "XXXX PNG chunk not known";
    #####: 5254:               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
    #####: 5255:               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
    #####: 5256:               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
    #####: 5257:               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
        -: 5258:               #endif
    #####: 5259:               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
    %%%%%: 5259-block 178
call    0 never executed
        -: 5260:            }
       38: 5261:            stbi__skip(s, c.length);
       38: 5261-block 179
call    0 returned 38
branch  1 taken 38 (fallthrough)
branch  2 taken 0 (throw)
       38: 5262:            break;
       38: 5262-block 180
        -: 5263:      }
        -: 5264:      // end of PNG chunk, read and skip CRC
     1821: 5265:      stbi__get32be(s);
     1821: 5265-block 181
call    0 returned 1821
branch  1 taken 1821 (fallthrough)
branch  2 taken 0 (throw)
     1821: 5266:   }
     1821: 5266-block 182
        -: 5267:}
        -: 5268:
function _ZL12stbi__do_pngP9stbi__pngPiS1_S1_iP17stbi__result_info called 3 returned 100% blocks executed 57%
        3: 5269:static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
        -: 5270:{
        3: 5271:   void *result=NULL;
       3*: 5272:   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
        3: 5272-block 2
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5272-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    %%%%%: 5272-block 4
call    4 never executed
        3: 5273:   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
        3: 5273-block 6
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0
        3: 5274:      if (p->depth <= 8)
        3: 5274-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 5275:         ri->bits_per_channel = 8;
    %%%%%: 5275-block 9
        3: 5276:      else if (p->depth == 16)
        3: 5276-block 10
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5277:         ri->bits_per_channel = 16;
        3: 5277-block 11
        -: 5278:      else
    #####: 5279:         return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
    %%%%%: 5279-block 12
call    0 never executed
        3: 5280:      result = p->out;
        3: 5281:      p->out = NULL;
        3: 5282:      if (req_comp && req_comp != p->s->img_out_n) {
        3: 5282-block 14
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5282-block 15
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    #####: 5283:         if (ri->bits_per_channel == 8)
    %%%%%: 5283-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5284:            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
    %%%%%: 5284-block 17
call    0 never executed
        -: 5285:         else
    #####: 5286:            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
    %%%%%: 5286-block 18
call    0 never executed
    #####: 5287:         p->s->img_out_n = req_comp;
    #####: 5288:         if (result == NULL) return result;
    %%%%%: 5288-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5288-block 20
        -: 5289:      }
        3: 5290:      *x = p->s->img_x;
        3: 5291:      *y = p->s->img_y;
        3: 5292:      if (n) *n = p->s->img_n;
        3: 5292-block 21
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5292-block 22
        -: 5293:   }
        3: 5294:   STBI_FREE(p->out);      p->out      = NULL;
        3: 5295:   STBI_FREE(p->expanded); p->expanded = NULL;
        3: 5296:   STBI_FREE(p->idata);    p->idata    = NULL;
        -: 5297:
        3: 5298:   return result;
        3: 5298-block 23
        -: 5299:}
        -: 5300:
function _ZL14stbi__png_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 3 returned 100% blocks executed 100%
        3: 5301:static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 5302:{
        -: 5303:   stbi__png p;
        3: 5304:   p.s = s;
        6: 5305:   return stbi__do_png(&p, x,y,comp,req_comp, ri);
        3: 5305-block 2
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3: 5305-block 3
        3: 5305-block 5
        -: 5306:}
        -: 5307:
function _ZL14stbi__png_testP13stbi__context called 3 returned 100% blocks executed 100%
        3: 5308:static int stbi__png_test(stbi__context *s)
        -: 5309:{
        -: 5310:   int r;
        3: 5311:   r = stbi__check_png_header(s);
        3: 5311-block 2
call    0 returned 3
        3: 5312:   stbi__rewind(s);
call    0 returned 3
        3: 5313:   return r;
        -: 5314:}
        -: 5315:
function _ZL18stbi__png_info_rawP9stbi__pngPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 5316:static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
        -: 5317:{
    #####: 5318:   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
    %%%%%: 5318-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5319:      stbi__rewind( p->s );
    %%%%%: 5319-block 4
call    0 never executed
    #####: 5320:      return 0;
        -: 5321:   }
    #####: 5322:   if (x) *x = p->s->img_x;
    %%%%%: 5322-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5322-block 7
    #####: 5323:   if (y) *y = p->s->img_y;
    %%%%%: 5323-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5323-block 9
    #####: 5324:   if (comp) *comp = p->s->img_n;
    %%%%%: 5324-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5324-block 11
    #####: 5325:   return 1;
    %%%%%: 5325-block 12
        -: 5326:}
        -: 5327:
function _ZL14stbi__png_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 5328:static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
        -: 5329:{
        -: 5330:   stbi__png p;
    #####: 5331:   p.s = s;
    #####: 5332:   return stbi__png_info_raw(&p, x, y, comp);
    %%%%%: 5332-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5332-block 3
    %%%%%: 5332-block 5
        -: 5333:}
        -: 5334:
function _ZL14stbi__png_is16P13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5335:static int stbi__png_is16(stbi__context *s)
        -: 5336:{
        -: 5337:   stbi__png p;
    #####: 5338:   p.s = s;
    #####: 5339:   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
    %%%%%: 5339-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5339-block 3
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 5340:	   return 0;
    %%%%%: 5340-block 4
    #####: 5341:   if (p.depth != 16) {
    %%%%%: 5341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5342:      stbi__rewind(p.s);
    %%%%%: 5342-block 6
call    0 never executed
    #####: 5343:      return 0;
        -: 5344:   }
    #####: 5345:   return 1;
    %%%%%: 5345-block 8
        -: 5346:}
        -: 5347:#endif
        -: 5348:
        -: 5349:// Microsoft/Windows BMP image
        -: 5350:
        -: 5351:#ifndef STBI_NO_BMP
function _ZL18stbi__bmp_test_rawP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5352:static int stbi__bmp_test_raw(stbi__context *s)
        -: 5353:{
        -: 5354:   int r;
        -: 5355:   int sz;
    #####: 5356:   if (stbi__get8(s) != 'B') return 0;
    %%%%%: 5356-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5356-block 4
    #####: 5357:   if (stbi__get8(s) != 'M') return 0;
    %%%%%: 5357-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5357-block 7
    #####: 5358:   stbi__get32le(s); // discard filesize
    %%%%%: 5358-block 8
call    0 never executed
    #####: 5359:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5360:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5361:   stbi__get32le(s); // discard data offset
call    0 never executed
    #####: 5362:   sz = stbi__get32le(s);
call    0 never executed
    #####: 5363:   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5363-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5363-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5363-block 16
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5363-block 17
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 5363-block 18
    %%%%%: 5363-block 19
    #####: 5364:   return r;
    %%%%%: 5364-block 20
        -: 5365:}
        -: 5366:
function _ZL14stbi__bmp_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5367:static int stbi__bmp_test(stbi__context *s)
        -: 5368:{
    #####: 5369:   int r = stbi__bmp_test_raw(s);
    %%%%%: 5369-block 2
call    0 never executed
    #####: 5370:   stbi__rewind(s);
call    0 never executed
    #####: 5371:   return r;
        -: 5372:}
        -: 5373:
        -: 5374:
        -: 5375:// returns 0..31 for the highest set bit
function _ZL14stbi__high_bitj called 0 returned 0% blocks executed 0%
    #####: 5376:static int stbi__high_bit(unsigned int z)
        -: 5377:{
    #####: 5378:   int n=0;
    #####: 5379:   if (z == 0) return -1;
    %%%%%: 5379-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5379-block 3
    #####: 5380:   if (z >= 0x10000) { n += 16; z >>= 16; }
    %%%%%: 5380-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5380-block 5
    #####: 5381:   if (z >= 0x00100) { n +=  8; z >>=  8; }
    %%%%%: 5381-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5381-block 7
    #####: 5382:   if (z >= 0x00010) { n +=  4; z >>=  4; }
    %%%%%: 5382-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5382-block 9
    #####: 5383:   if (z >= 0x00004) { n +=  2; z >>=  2; }
    %%%%%: 5383-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5383-block 11
    #####: 5384:   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
    %%%%%: 5384-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5384-block 13
    #####: 5385:   return n;
    %%%%%: 5385-block 14
        -: 5386:}
        -: 5387:
function _ZL14stbi__bitcountj called 0 returned 0% blocks executed 0%
    #####: 5388:static int stbi__bitcount(unsigned int a)
        -: 5389:{
    #####: 5390:   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
    #####: 5391:   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
    #####: 5392:   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
    #####: 5393:   a = (a + (a >> 8)); // max 16 per 8 bits
    #####: 5394:   a = (a + (a >> 16)); // max 32 per 8 bits
    #####: 5395:   return a & 0xff;
    %%%%%: 5395-block 2
        -: 5396:}
        -: 5397:
        -: 5398:// extract an arbitrarily-aligned N-bit value (N=bits)
        -: 5399:// from v, and then make it 8-bits long and fractionally
        -: 5400:// extend it to full full range.
function _ZL17stbi__shiftsignedjii called 0 returned 0% blocks executed 0%
    #####: 5401:static int stbi__shiftsigned(unsigned int v, int shift, int bits)
        -: 5402:{
        -: 5403:   static unsigned int mul_table[9] = {
        -: 5404:      0,
        -: 5405:      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
        -: 5406:      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
        -: 5407:   };
        -: 5408:   static unsigned int shift_table[9] = {
        -: 5409:      0, 0,0,1,0,2,4,6,0,
        -: 5410:   };
    #####: 5411:   if (shift < 0)
    %%%%%: 5411-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5412:      v <<= -shift;
    %%%%%: 5412-block 3
        -: 5413:   else
    #####: 5414:      v >>= shift;
    %%%%%: 5414-block 4
    #####: 5415:   STBI_ASSERT(v < 256);
    %%%%%: 5415-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5415-block 6
call    2 never executed
    #####: 5416:   v >>= (8-bits);
    #####: 5417:   STBI_ASSERT(bits >= 0 && bits <= 8);
    %%%%%: 5417-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5417-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5417-block 9
    %%%%%: 5417-block 10
call    4 never executed
    #####: 5418:   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
    %%%%%: 5418-block 11
        -: 5419:}
        -: 5420:
        -: 5421:typedef struct
        -: 5422:{
        -: 5423:   int bpp, offset, hsz;
        -: 5424:   unsigned int mr,mg,mb,ma, all_a;
        -: 5425:   int extra_read;
        -: 5426:} stbi__bmp_data;
        -: 5427:
function _ZL27stbi__bmp_set_mask_defaultsP14stbi__bmp_datai called 0 returned 0% blocks executed 0%
    #####: 5428:static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
        -: 5429:{
        -: 5430:   // BI_BITFIELDS specifies masks explicitly, don't override
    #####: 5431:   if (compress == 3)
    %%%%%: 5431-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5432:      return 1;
    %%%%%: 5432-block 3
        -: 5433:
    #####: 5434:   if (compress == 0) {
    %%%%%: 5434-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5435:      if (info->bpp == 16) {
    %%%%%: 5435-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5436:         info->mr = 31u << 10;
    #####: 5437:         info->mg = 31u <<  5;
    #####: 5438:         info->mb = 31u <<  0;
    %%%%%: 5438-block 6
    #####: 5439:      } else if (info->bpp == 32) {
    %%%%%: 5439-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5440:         info->mr = 0xffu << 16;
    #####: 5441:         info->mg = 0xffu <<  8;
    #####: 5442:         info->mb = 0xffu <<  0;
    #####: 5443:         info->ma = 0xffu << 24;
    #####: 5444:         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
    %%%%%: 5444-block 8
        -: 5445:      } else {
        -: 5446:         // otherwise, use defaults, which is all-0
    #####: 5447:         info->mr = info->mg = info->mb = info->ma = 0;
    %%%%%: 5447-block 9
        -: 5448:      }
    #####: 5449:      return 1;
    %%%%%: 5449-block 10
        -: 5450:   }
    #####: 5451:   return 0; // error
    %%%%%: 5451-block 11
        -: 5452:}
        -: 5453:
function _ZL22stbi__bmp_parse_headerP13stbi__contextP14stbi__bmp_data called 0 returned 0% blocks executed 0%
    #####: 5454:static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
        -: 5455:{
        -: 5456:   int hsz;
    #####: 5457:   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
    %%%%%: 5457-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5457-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5457-block 6
    %%%%%: 5457-block 7
    %%%%%: 5457-block 8
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5457-block 9
call    8 never executed
    #####: 5458:   stbi__get32le(s); // discard filesize
    %%%%%: 5458-block 11
call    0 never executed
    #####: 5459:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5460:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5461:   info->offset = stbi__get32le(s);
call    0 never executed
    #####: 5462:   info->hsz = hsz = stbi__get32le(s);
call    0 never executed
    #####: 5463:   info->mr = info->mg = info->mb = info->ma = 0;
    #####: 5464:   info->extra_read = 14;
        -: 5465:
    #####: 5466:   if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5466-block 17
call    2 never executed
        -: 5467:
    #####: 5468:   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
    %%%%%: 5468-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5468-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5468-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5468-block 22
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5468-block 23
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 5468-block 24
call   10 never executed
    #####: 5469:   if (hsz == 12) {
    %%%%%: 5469-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5470:      s->img_x = stbi__get16le(s);
    %%%%%: 5470-block 27
call    0 never executed
    #####: 5471:      s->img_y = stbi__get16le(s);
call    0 never executed
        -: 5472:   } else {
    #####: 5473:      s->img_x = stbi__get32le(s);
    %%%%%: 5473-block 30
call    0 never executed
    #####: 5474:      s->img_y = stbi__get32le(s);
call    0 never executed
        -: 5475:   }
    #####: 5476:   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5476-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5476-block 35
call    3 never executed
    #####: 5477:   info->bpp = stbi__get16le(s);
    %%%%%: 5477-block 37
call    0 never executed
    #####: 5478:   if (hsz != 12) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5479:      int compress = stbi__get32le(s);
    %%%%%: 5479-block 39
call    0 never executed
    #####: 5480:      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5480-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5480-block 42
call    4 never executed
    #####: 5481:      if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
    %%%%%: 5481-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5481-block 45
call    2 never executed
    #####: 5482:      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
    %%%%%: 5482-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5482-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5482-block 49
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5482-block 50
call    6 never executed
    #####: 5483:      stbi__get32le(s); // discard sizeof
    %%%%%: 5483-block 52
call    0 never executed
    #####: 5484:      stbi__get32le(s); // discard hres
call    0 never executed
    #####: 5485:      stbi__get32le(s); // discard vres
call    0 never executed
    #####: 5486:      stbi__get32le(s); // discard colorsused
call    0 never executed
    #####: 5487:      stbi__get32le(s); // discard max important
call    0 never executed
    #####: 5488:      if (hsz == 40 || hsz == 56) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5488-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5489:         if (hsz == 56) {
    %%%%%: 5489-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5490:            stbi__get32le(s);
    %%%%%: 5490-block 60
call    0 never executed
    #####: 5491:            stbi__get32le(s);
call    0 never executed
    #####: 5492:            stbi__get32le(s);
call    0 never executed
    #####: 5493:            stbi__get32le(s);
call    0 never executed
        -: 5494:         }
    #####: 5495:         if (info->bpp == 16 || info->bpp == 32) {
    %%%%%: 5495-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5495-block 65
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5496:            if (compress == 0) {
    %%%%%: 5496-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5497:               stbi__bmp_set_mask_defaults(info, compress);
    %%%%%: 5497-block 67
call    0 never executed
    #####: 5498:            } else if (compress == 3) {
    %%%%%: 5498-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5499:               info->mr = stbi__get32le(s);
    %%%%%: 5499-block 69
call    0 never executed
    #####: 5500:               info->mg = stbi__get32le(s);
call    0 never executed
    #####: 5501:               info->mb = stbi__get32le(s);
call    0 never executed
    #####: 5502:               info->extra_read += 12;
        -: 5503:               // not documented, but generated by photoshop and handled by mspaint
    #####: 5504:               if (info->mr == info->mg && info->mg == info->mb) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5504-block 73
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5505:                  // ?!?!?
    #####: 5506:                  return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5506-block 74
call    0 never executed
        -: 5507:               }
        -: 5508:            } else
    #####: 5509:               return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5509-block 76
call    0 never executed
        -: 5510:         }
        -: 5511:      } else {
        -: 5512:         // V4/V5 header
        -: 5513:         int i;
    #####: 5514:         if (hsz != 108 && hsz != 124)
    %%%%%: 5514-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5514-block 80
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5515:            return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5515-block 81
call    0 never executed
    #####: 5516:         info->mr = stbi__get32le(s);
    %%%%%: 5516-block 83
call    0 never executed
    #####: 5517:         info->mg = stbi__get32le(s);
call    0 never executed
    #####: 5518:         info->mb = stbi__get32le(s);
call    0 never executed
    #####: 5519:         info->ma = stbi__get32le(s);
call    0 never executed
    #####: 5520:         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5521:            stbi__bmp_set_mask_defaults(info, compress);
    %%%%%: 5521-block 88
call    0 never executed
    #####: 5522:         stbi__get32le(s); // discard color space
    %%%%%: 5522-block 89
call    0 never executed
    #####: 5523:         for (i=0; i < 12; ++i)
    %%%%%: 5523-block 93
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5524:            stbi__get32le(s); // discard color space parameters
    %%%%%: 5524-block 91
call    0 never executed
    #####: 5525:         if (hsz == 124) {
    %%%%%: 5525-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5526:            stbi__get32le(s); // discard rendering intent
    %%%%%: 5526-block 95
call    0 never executed
    #####: 5527:            stbi__get32le(s); // discard offset of profile data
call    0 never executed
    #####: 5528:            stbi__get32le(s); // discard size of profile data
call    0 never executed
    #####: 5529:            stbi__get32le(s); // discard reserved
call    0 never executed
        -: 5530:         }
        -: 5531:      }
        -: 5532:   }
    #####: 5533:   return (void *) 1;
    %%%%%: 5533-block 100
        -: 5534:}
        -: 5535:
        -: 5536:
function _ZL14stbi__bmp_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 5537:static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 5538:{
        -: 5539:   stbi_uc *out;
    #####: 5540:   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
        -: 5541:   stbi_uc pal[256][4];
    #####: 5542:   int psize=0,i,j,width;
        -: 5543:   int flip_vertically, pad, target;
        -: 5544:   stbi__bmp_data info;
        -: 5545:   STBI_NOTUSED(ri);
        -: 5546:
    #####: 5547:   info.all_a = 255;
    #####: 5548:   if (stbi__bmp_parse_header(s, &info) == NULL)
    %%%%%: 5548-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5548-block 3
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 5549:      return NULL; // error code already set
    %%%%%: 5549-block 4
        -: 5550:
    #####: 5551:   flip_vertically = ((int) s->img_y) > 0;
    #####: 5552:   s->img_y = abs((int) s->img_y);
        -: 5553:
    #####: 5554:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5554-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5554-block 6
call    2 never executed
    #####: 5555:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5555-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5555-block 9
call    2 never executed
        -: 5556:
    #####: 5557:   mr = info.mr;
    #####: 5558:   mg = info.mg;
    #####: 5559:   mb = info.mb;
    #####: 5560:   ma = info.ma;
    #####: 5561:   all_a = info.all_a;
        -: 5562:
    #####: 5563:   if (info.hsz == 12) {
    %%%%%: 5563-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5564:      if (info.bpp < 24)
    %%%%%: 5564-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5565:         psize = (info.offset - info.extra_read - 24) / 3;
    %%%%%: 5565-block 13
        -: 5566:   } else {
    #####: 5567:      if (info.bpp < 16)
    %%%%%: 5567-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5568:         psize = (info.offset - info.extra_read - info.hsz) >> 2;
    %%%%%: 5568-block 15
        -: 5569:   }
    #####: 5570:   if (psize == 0) {
    %%%%%: 5570-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5571:      // accept some number of extra bytes after the header, but if the offset points either to before
        -: 5572:      // the header ends or implies a large amount of extra data, reject the file as malformed
    #####: 5573:      int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
    #####: 5574:      int header_limit = 1024; // max we actually read is below 256 bytes currently.
    #####: 5575:      int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
    #####: 5576:      if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
    %%%%%: 5576-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5576-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5577:         return stbi__errpuc("bad header", "Corrupt BMP");
    %%%%%: 5577-block 19
call    0 never executed
        -: 5578:      }
        -: 5579:      // we established that bytes_read_so_far is positive and sensible.
        -: 5580:      // the first half of this test rejects offsets that are either too small positives, or
        -: 5581:      // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
        -: 5582:      // ensures the number computed in the second half of the test can't overflow.
    #####: 5583:      if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
    %%%%%: 5583-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5583-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5584:         return stbi__errpuc("bad offset", "Corrupt BMP");
    %%%%%: 5584-block 23
call    0 never executed
        -: 5585:      } else {
    #####: 5586:         stbi__skip(s, info.offset - bytes_read_so_far);
    %%%%%: 5586-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5587:      }
        -: 5588:   }
        -: 5589:
    #####: 5590:   if (info.bpp == 24 && ma == 0xff000000)
    %%%%%: 5590-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5590-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5591:      s->img_n = 3;
    %%%%%: 5591-block 28
        -: 5592:   else
    #####: 5593:      s->img_n = ma ? 4 : 3;
    %%%%%: 5593-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5593-block 30
    %%%%%: 5593-block 31
    %%%%%: 5593-block 32
    #####: 5594:   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
    %%%%%: 5594-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5594-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5595:      target = req_comp;
    %%%%%: 5595-block 35
        -: 5596:   else
    #####: 5597:      target = s->img_n; // if they want monochrome, we'll post-convert
    %%%%%: 5597-block 36
        -: 5598:
        -: 5599:   // sanity-check size
    #####: 5600:   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
    %%%%%: 5600-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5601:      return stbi__errpuc("too large", "Corrupt BMP");
    %%%%%: 5601-block 39
call    0 never executed
        -: 5602:
    #####: 5603:   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
    %%%%%: 5603-block 41
call    0 never executed
    #####: 5604:   if (!out) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5604-block 43
call    2 never executed
    #####: 5605:   if (info.bpp < 16) {
    %%%%%: 5605-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5606:      int z=0;
    #####: 5607:      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
    %%%%%: 5607-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5607-block 47
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5607-block 48
call    4 never executed
    #####: 5608:      for (i=0; i < psize; ++i) {
    %%%%%: 5608-block 50
    %%%%%: 5608-block 57
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5609:         pal[i][2] = stbi__get8(s);
    %%%%%: 5609-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5610:         pal[i][1] = stbi__get8(s);
    %%%%%: 5610-block 52
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5611:         pal[i][0] = stbi__get8(s);
    %%%%%: 5611-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5612:         if (info.hsz != 12) stbi__get8(s);
    %%%%%: 5612-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5612-block 55
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 5613:         pal[i][3] = 255;
    %%%%%: 5613-block 56
        -: 5614:      }
    #####: 5615:      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
    %%%%%: 5615-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5615-block 59
    %%%%%: 5615-block 60
    %%%%%: 5615-block 61
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 5616:      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
    %%%%%: 5616-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5616-block 63
    #####: 5617:      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
    %%%%%: 5617-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5617-block 65
    #####: 5618:      else if (info.bpp == 8) width = s->img_x;
    %%%%%: 5618-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5618-block 67
    #####: 5619:      else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
    %%%%%: 5619-block 68
call    0 never executed
    #####: 5620:      pad = (-width)&3;
    #####: 5621:      if (info.bpp == 1) {
    %%%%%: 5621-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5622:         for (j=0; j < (int) s->img_y; ++j) {
    %%%%%: 5622-block 71
    %%%%%: 5622-block 84
    %%%%%: 5622-block 85
branch  0 never executed
branch  1 never executed
    #####: 5623:            int bit_offset = 7, v = stbi__get8(s);
    %%%%%: 5623-block 72
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5624:            for (i=0; i < (int) s->img_x; ++i) {
    %%%%%: 5624-block 73
    %%%%%: 5624-block 81
    %%%%%: 5624-block 82
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5625:               int color = (v>>bit_offset)&0x1;
    #####: 5626:               out[z++] = pal[color][0];
    #####: 5627:               out[z++] = pal[color][1];
    #####: 5628:               out[z++] = pal[color][2];
    #####: 5629:               if (target == 4) out[z++] = 255;
    %%%%%: 5629-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5629-block 75
    #####: 5630:               if (i+1 == (int) s->img_x) break;
    %%%%%: 5630-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5630-block 77
    #####: 5631:               if((--bit_offset) < 0) {
    %%%%%: 5631-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5632:                  bit_offset = 7;
    #####: 5633:                  v = stbi__get8(s);
    %%%%%: 5633-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5633-block 80
        -: 5634:               }
        -: 5635:            }
    #####: 5636:            stbi__skip(s, pad);
    %%%%%: 5636-block 83
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5637:         }
        -: 5638:      } else {
    #####: 5639:         for (j=0; j < (int) s->img_y; ++j) {
    %%%%%: 5639-block 86
    %%%%%: 5639-block 104
    %%%%%: 5639-block 105
branch  0 never executed
branch  1 never executed
    #####: 5640:            for (i=0; i < (int) s->img_x; i += 2) {
    %%%%%: 5640-block 87
    %%%%%: 5640-block 101
    %%%%%: 5640-block 102
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5641:               int v=stbi__get8(s),v2=0;
    %%%%%: 5641-block 88
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5642:               if (info.bpp == 4) {
    %%%%%: 5642-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5643:                  v2 = v & 15;
    #####: 5644:                  v >>= 4;
    %%%%%: 5644-block 90
        -: 5645:               }
    #####: 5646:               out[z++] = pal[v][0];
    #####: 5647:               out[z++] = pal[v][1];
    #####: 5648:               out[z++] = pal[v][2];
    #####: 5649:               if (target == 4) out[z++] = 255;
    %%%%%: 5649-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5649-block 92
    #####: 5650:               if (i+1 == (int) s->img_x) break;
    %%%%%: 5650-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5650-block 94
    #####: 5651:               v = (info.bpp == 8) ? stbi__get8(s) : v2;
    %%%%%: 5651-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5651-block 96
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5651-block 97
    %%%%%: 5651-block 98
    #####: 5652:               out[z++] = pal[v][0];
    #####: 5653:               out[z++] = pal[v][1];
    #####: 5654:               out[z++] = pal[v][2];
    #####: 5655:               if (target == 4) out[z++] = 255;
    %%%%%: 5655-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5655-block 100
        -: 5656:            }
    #####: 5657:            stbi__skip(s, pad);
    %%%%%: 5657-block 103
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5658:         }
        -: 5659:      }
        -: 5660:   } else {
    #####: 5661:      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
    #####: 5662:      int z = 0;
    #####: 5663:      int easy=0;
    #####: 5664:      stbi__skip(s, info.offset - info.extra_read - info.hsz);
    %%%%%: 5664-block 106
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5665:      if (info.bpp == 24) width = 3 * s->img_x;
    %%%%%: 5665-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5665-block 108
    #####: 5666:      else if (info.bpp == 16) width = 2*s->img_x;
    %%%%%: 5666-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5666-block 110
    #####: 5667:      else /* bpp = 32 and pad = 0 */ width=0;
    %%%%%: 5667-block 111
    #####: 5668:      pad = (-width) & 3;
    #####: 5669:      if (info.bpp == 24) {
    %%%%%: 5669-block 112
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5670:         easy = 1;
    %%%%%: 5670-block 113
    #####: 5671:      } else if (info.bpp == 32) {
    %%%%%: 5671-block 114
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5672:         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
    %%%%%: 5672-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5672-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5672-block 117
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5672-block 118
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 5673:            easy = 2;
    %%%%%: 5673-block 119
        -: 5674:      }
    #####: 5675:      if (!easy) {
    %%%%%: 5675-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5676:         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
    %%%%%: 5676-block 121
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5676-block 122
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5676-block 123
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5676-block 124
call    6 never executed
        -: 5677:         // right shift amt to put high bit in position #7
    #####: 5678:         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
    %%%%%: 5678-block 126
call    0 never executed
call    1 never executed
    #####: 5679:         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
call    0 never executed
call    1 never executed
    #####: 5680:         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
call    0 never executed
call    1 never executed
    #####: 5681:         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
call    0 never executed
call    1 never executed
    #####: 5682:         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5682-block 135
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5682-block 136
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5682-block 137
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5682-block 138
call    8 never executed
        -: 5683:      }
    #####: 5684:      for (j=0; j < (int) s->img_y; ++j) {
    %%%%%: 5684-block 140
    %%%%%: 5684-block 172
    %%%%%: 5684-block 173
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5685:         if (easy) {
    %%%%%: 5685-block 141
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5686:            for (i=0; i < (int) s->img_x; ++i) {
    %%%%%: 5686-block 142
    %%%%%: 5686-block 152
    %%%%%: 5686-block 153
branch  0 never executed
branch  1 never executed
        -: 5687:               unsigned char a;
    #####: 5688:               out[z+2] = stbi__get8(s);
    %%%%%: 5688-block 143
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5689:               out[z+1] = stbi__get8(s);
    %%%%%: 5689-block 144
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5690:               out[z+0] = stbi__get8(s);
    %%%%%: 5690-block 145
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5691:               z += 3;
    #####: 5692:               a = (easy == 2 ? stbi__get8(s) : 255);
    %%%%%: 5692-block 146
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5692-block 147
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5692-block 148
    %%%%%: 5692-block 149
    #####: 5693:               all_a |= a;
    #####: 5694:               if (target == 4) out[z++] = a;
    %%%%%: 5694-block 150
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5694-block 151
        -: 5695:            }
        -: 5696:         } else {
    #####: 5697:            int bpp = info.bpp;
    #####: 5698:            for (i=0; i < (int) s->img_x; ++i) {
    %%%%%: 5698-block 154
    %%%%%: 5698-block 169
    %%%%%: 5698-block 170
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5699:               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
    %%%%%: 5699-block 155
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5699-block 156
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5699-block 157
    %%%%%: 5699-block 158
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 5699-block 159
        -: 5700:               unsigned int a;
    #####: 5701:               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
    %%%%%: 5701-block 160
call    0 never executed
    #####: 5702:               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
call    0 never executed
    #####: 5703:               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
call    0 never executed
    #####: 5704:               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5704-block 164
call    2 never executed
    %%%%%: 5704-block 166
    #####: 5705:               all_a |= a;
    #####: 5706:               if (target == 4) out[z++] = STBI__BYTECAST(a);
    %%%%%: 5706-block 167
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5706-block 168
        -: 5707:            }
        -: 5708:         }
    #####: 5709:         stbi__skip(s, pad);
    %%%%%: 5709-block 171
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5710:      }
        -: 5711:   }
        -: 5712:
        -: 5713:   // if alpha channel is all 0s, replace with all 255s
    #####: 5714:   if (target == 4 && all_a == 0)
    %%%%%: 5714-block 174
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5714-block 175
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5715:      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
    %%%%%: 5715-block 176
    %%%%%: 5715-block 178
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5716:         out[i] = 255;
    %%%%%: 5716-block 177
        -: 5717:
    #####: 5718:   if (flip_vertically) {
    %%%%%: 5718-block 179
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5719:      stbi_uc t;
    #####: 5720:      for (j=0; j < (int) s->img_y>>1; ++j) {
    %%%%%: 5720-block 180
    %%%%%: 5720-block 184
    %%%%%: 5720-block 185
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5721:         stbi_uc *p1 = out +      j     *s->img_x*target;
    #####: 5722:         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
    #####: 5723:         for (i=0; i < (int) s->img_x*target; ++i) {
    %%%%%: 5723-block 181
    %%%%%: 5723-block 183
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5724:            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
    %%%%%: 5724-block 182
        -: 5725:         }
        -: 5726:      }
        -: 5727:   }
        -: 5728:
    #####: 5729:   if (req_comp && req_comp != target) {
    %%%%%: 5729-block 186
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5729-block 187
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5730:      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
    %%%%%: 5730-block 188
call    0 never executed
    #####: 5731:      if (out == NULL) return out; // stbi__convert_format frees input on failure
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5731-block 190
        -: 5732:   }
        -: 5733:
    #####: 5734:   *x = s->img_x;
    #####: 5735:   *y = s->img_y;
    #####: 5736:   if (comp) *comp = s->img_n;
    %%%%%: 5736-block 191
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5736-block 192
    #####: 5737:   return out;
    %%%%%: 5737-block 193
        -: 5738:}
        -: 5739:#endif
        -: 5740:
        -: 5741:// Targa Truevision - TGA
        -: 5742:// by Jonathan Dummer
        -: 5743:#ifndef STBI_NO_TGA
        -: 5744:// returns STBI_rgb or whatever, 0 on error
function _ZL18stbi__tga_get_compiiPi called 0 returned 0% blocks executed 0%
    #####: 5745:static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
        -: 5746:{
        -: 5747:   // only RGB or RGBA (incl. 16bit) or grey allowed
    #####: 5748:   if (is_rgb16) *is_rgb16 = 0;
    %%%%%: 5748-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5748-block 3
    #####: 5749:   switch(bits_per_pixel) {
    %%%%%: 5749-block 4
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5750:      case 8:  return STBI_grey;
    %%%%%: 5750-block 5
    #####: 5751:      case 16: if(is_grey) return STBI_grey_alpha;
    %%%%%: 5751-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5751-block 7
        -: 5752:               // fallthrough
    #####: 5753:      case 15: if(is_rgb16) *is_rgb16 = 1;
    %%%%%: 5753-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5753-block 9
    #####: 5754:               return STBI_rgb;
    %%%%%: 5754-block 10
    #####: 5755:      case 24: // fallthrough
    #####: 5756:      case 32: return bits_per_pixel/8;
    %%%%%: 5756-block 11
    #####: 5757:      default: return 0;
    %%%%%: 5757-block 12
        -: 5758:   }
        -: 5759:}
        -: 5760:
function _ZL14stbi__tga_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 5761:static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
        -: 5762:{
        -: 5763:    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
        -: 5764:    int sz, tga_colormap_type;
    #####: 5765:    stbi__get8(s);                   // discard Offset
    %%%%%: 5765-block 2
call    0 never executed
    #####: 5766:    tga_colormap_type = stbi__get8(s); // colormap type
call    0 never executed
    #####: 5767:    if( tga_colormap_type > 1 ) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5768:        stbi__rewind(s);
    %%%%%: 5768-block 5
call    0 never executed
    #####: 5769:        return 0;      // only RGB or indexed allowed
        -: 5770:    }
    #####: 5771:    tga_image_type = stbi__get8(s); // image type
    %%%%%: 5771-block 7
call    0 never executed
    #####: 5772:    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5773:        if (tga_image_type != 1 && tga_image_type != 9) {
    %%%%%: 5773-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5773-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5774:            stbi__rewind(s);
    %%%%%: 5774-block 11
call    0 never executed
    #####: 5775:            return 0;
        -: 5776:        }
    #####: 5777:        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
    %%%%%: 5777-block 13
call    0 never executed
    #####: 5778:        sz = stbi__get8(s);    //   check bits per palette color entry
call    0 never executed
    #####: 5779:        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5779-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5779-block 17
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5779-block 18
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5779-block 19
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 5780:            stbi__rewind(s);
    %%%%%: 5780-block 20
call    0 never executed
    #####: 5781:            return 0;
        -: 5782:        }
    #####: 5783:        stbi__skip(s,4);       // skip image x and y origin
    %%%%%: 5783-block 22
call    0 never executed
    #####: 5784:        tga_colormap_bpp = sz;
        -: 5785:    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
    #####: 5786:        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
    %%%%%: 5786-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5786-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5786-block 26
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5786-block 27
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 5787:            stbi__rewind(s);
    %%%%%: 5787-block 28
call    0 never executed
    #####: 5788:            return 0; // only RGB or grey allowed, +/- RLE
        -: 5789:        }
    #####: 5790:        stbi__skip(s,9); // skip colormap specification and image x/y origin
    %%%%%: 5790-block 30
call    0 never executed
    #####: 5791:        tga_colormap_bpp = 0;
        -: 5792:    }
    #####: 5793:    tga_w = stbi__get16le(s);
    %%%%%: 5793-block 32
call    0 never executed
    #####: 5794:    if( tga_w < 1 ) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5795:        stbi__rewind(s);
    %%%%%: 5795-block 34
call    0 never executed
    #####: 5796:        return 0;   // test width
        -: 5797:    }
    #####: 5798:    tga_h = stbi__get16le(s);
    %%%%%: 5798-block 36
call    0 never executed
    #####: 5799:    if( tga_h < 1 ) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5800:        stbi__rewind(s);
    %%%%%: 5800-block 38
call    0 never executed
    #####: 5801:        return 0;   // test height
        -: 5802:    }
    #####: 5803:    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    %%%%%: 5803-block 40
call    0 never executed
    #####: 5804:    stbi__get8(s); // ignore alpha bits
call    0 never executed
    #####: 5805:    if (tga_colormap_bpp != 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5806:        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
    %%%%%: 5806-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5806-block 44
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5807:            // when using a colormap, tga_bits_per_pixel is the size of the indexes
        -: 5808:            // I don't think anything but 8 or 16bit indexes makes sense
    #####: 5809:            stbi__rewind(s);
    %%%%%: 5809-block 45
call    0 never executed
    #####: 5810:            return 0;
        -: 5811:        }
    #####: 5812:        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    %%%%%: 5812-block 47
call    0 never executed
        -: 5813:    } else {
    #####: 5814:        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    %%%%%: 5814-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5814-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5814-block 50
    %%%%%: 5814-block 51
    %%%%%: 5814-block 52
call    4 never executed
        -: 5815:    }
    #####: 5816:    if(!tga_comp) {
    %%%%%: 5816-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5817:      stbi__rewind(s);
    %%%%%: 5817-block 54
call    0 never executed
    #####: 5818:      return 0;
        -: 5819:    }
    #####: 5820:    if (x) *x = tga_w;
    %%%%%: 5820-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5820-block 57
    #####: 5821:    if (y) *y = tga_h;
    %%%%%: 5821-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5821-block 59
    #####: 5822:    if (comp) *comp = tga_comp;
    %%%%%: 5822-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5822-block 61
    #####: 5823:    return 1;                   // seems to have passed everything
    %%%%%: 5823-block 62
        -: 5824:}
        -: 5825:
function _ZL14stbi__tga_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5826:static int stbi__tga_test(stbi__context *s)
        -: 5827:{
    #####: 5828:   int res = 0;
        -: 5829:   int sz, tga_color_type;
    #####: 5830:   stbi__get8(s);      //   discard Offset
    %%%%%: 5830-block 2
call    0 never executed
    #####: 5831:   tga_color_type = stbi__get8(s);   //   color type
call    0 never executed
    #####: 5832:   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5832-block 5
    #####: 5833:   sz = stbi__get8(s);   //   image type
    %%%%%: 5833-block 6
call    0 never executed
    #####: 5834:   if ( tga_color_type == 1 ) { // colormapped (paletted) image
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5835:      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
    %%%%%: 5835-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5835-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5835-block 10
    #####: 5836:      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
    %%%%%: 5836-block 11
call    0 never executed
    #####: 5837:      sz = stbi__get8(s);    //   check bits per palette color entry
call    0 never executed
    #####: 5838:      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5838-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5838-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5838-block 16
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5838-block 17
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 5838-block 18
    #####: 5839:      stbi__skip(s,4);       // skip image x and y origin
    %%%%%: 5839-block 19
call    0 never executed
        -: 5840:   } else { // "normal" image w/o colormap
    #####: 5841:      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
    %%%%%: 5841-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5841-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5841-block 22
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5841-block 23
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5841-block 24
    #####: 5842:      stbi__skip(s,9); // skip colormap specification and image x/y origin
    %%%%%: 5842-block 25
call    0 never executed
        -: 5843:   }
    #####: 5844:   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
    %%%%%: 5844-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5844-block 28
    #####: 5845:   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
    %%%%%: 5845-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5845-block 31
    #####: 5846:   sz = stbi__get8(s);   //   bits per pixel
    %%%%%: 5846-block 32
call    0 never executed
    #####: 5847:   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5847-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5847-block 35
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5847-block 36
    #####: 5848:   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
    %%%%%: 5848-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5848-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5848-block 39
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5848-block 40
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5848-block 41
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 5848-block 42
        -: 5849:
    #####: 5850:   res = 1; // if we got this far, everything's good and we can return 1 instead of 0
    %%%%%: 5850-block 43
        -: 5851:
    #####: 5852:errorEnd:
    #####: 5853:   stbi__rewind(s);
    %%%%%: 5853-block 44
call    0 never executed
    #####: 5854:   return res;
        -: 5855:}
        -: 5856:
        -: 5857:// read 16bit value and convert to 24bit RGB
function _ZL20stbi__tga_read_rgb16P13stbi__contextPh called 0 returned 0% blocks executed 0%
    #####: 5858:static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
        -: 5859:{
    #####: 5860:   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
    %%%%%: 5860-block 2
call    0 never executed
    #####: 5861:   stbi__uint16 fiveBitMask = 31;
        -: 5862:   // we have 3 channels with 5bits each
    #####: 5863:   int r = (px >> 10) & fiveBitMask;
    #####: 5864:   int g = (px >> 5) & fiveBitMask;
    #####: 5865:   int b = px & fiveBitMask;
        -: 5866:   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
    #####: 5867:   out[0] = (stbi_uc)((r * 255)/31);
    #####: 5868:   out[1] = (stbi_uc)((g * 255)/31);
    #####: 5869:   out[2] = (stbi_uc)((b * 255)/31);
        -: 5870:
        -: 5871:   // some people claim that the most significant bit might be used for alpha
        -: 5872:   // (possibly if an alpha-bit is set in the "image descriptor byte")
        -: 5873:   // but that only made 16bit test images completely translucent..
        -: 5874:   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
    #####: 5875:}
        -: 5876:
function _ZL14stbi__tga_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 5877:static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 5878:{
        -: 5879:   //   read in the TGA header stuff
    #####: 5880:   int tga_offset = stbi__get8(s);
    %%%%%: 5880-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5881:   int tga_indexed = stbi__get8(s);
    %%%%%: 5881-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5882:   int tga_image_type = stbi__get8(s);
    %%%%%: 5882-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5883:   int tga_is_RLE = 0;
    #####: 5884:   int tga_palette_start = stbi__get16le(s);
    %%%%%: 5884-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5885:   int tga_palette_len = stbi__get16le(s);
    %%%%%: 5885-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5886:   int tga_palette_bits = stbi__get8(s);
    %%%%%: 5886-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5887:   int tga_x_origin = stbi__get16le(s);
    %%%%%: 5887-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5888:   int tga_y_origin = stbi__get16le(s);
    %%%%%: 5888-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5889:   int tga_width = stbi__get16le(s);
    %%%%%: 5889-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5890:   int tga_height = stbi__get16le(s);
    %%%%%: 5890-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5891:   int tga_bits_per_pixel = stbi__get8(s);
    %%%%%: 5891-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5892:   int tga_comp, tga_rgb16=0;
    #####: 5893:   int tga_inverted = stbi__get8(s);
    %%%%%: 5893-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5894:   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
        -: 5895:   //   image data
        -: 5896:   unsigned char *tga_data;
    #####: 5897:   unsigned char *tga_palette = NULL;
        -: 5898:   int i, j;
    #####: 5899:   unsigned char raw_data[4] = {0};
    #####: 5900:   int RLE_count = 0;
    #####: 5901:   int RLE_repeating = 0;
    #####: 5902:   int read_next_pixel = 1;
        -: 5903:   STBI_NOTUSED(ri);
        -: 5904:   STBI_NOTUSED(tga_x_origin); // @TODO
        -: 5905:   STBI_NOTUSED(tga_y_origin); // @TODO
        -: 5906:
    #####: 5907:   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5907-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5907-block 15
call    2 never executed
    #####: 5908:   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5908-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5908-block 18
call    2 never executed
        -: 5909:
        -: 5910:   //   do a tiny bit of precessing
    #####: 5911:   if ( tga_image_type >= 8 )
    %%%%%: 5911-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5912:   {
    #####: 5913:      tga_image_type -= 8;
    #####: 5914:      tga_is_RLE = 1;
    %%%%%: 5914-block 21
        -: 5915:   }
    #####: 5916:   tga_inverted = 1 - ((tga_inverted >> 5) & 1);
        -: 5917:
        -: 5918:   //   If I'm paletted, then I'll use the number of bits from the palette
    #####: 5919:   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
    %%%%%: 5919-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5919-block 23
call    2 never executed
    #####: 5920:   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
    %%%%%: 5920-block 24
call    0 never executed
        -: 5921:
    #####: 5922:   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
    %%%%%: 5922-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5923:      return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
    %%%%%: 5923-block 26
call    0 never executed
        -: 5924:
        -: 5925:   //   tga info
    #####: 5926:   *x = tga_width;
    #####: 5927:   *y = tga_height;
    #####: 5928:   if (comp) *comp = tga_comp;
    %%%%%: 5928-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5928-block 29
        -: 5929:
    #####: 5930:   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
    %%%%%: 5930-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5931:      return stbi__errpuc("too large", "Corrupt TGA");
    %%%%%: 5931-block 32
call    0 never executed
        -: 5932:
    #####: 5933:   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
    %%%%%: 5933-block 34
call    0 never executed
    #####: 5934:   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5934-block 36
call    2 never executed
        -: 5935:
        -: 5936:   // skip to the data's starting position (offset usually = 0)
    #####: 5937:   stbi__skip(s, tga_offset );
    %%%%%: 5937-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5938:
    #####: 5939:   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
    %%%%%: 5939-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5939-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5939-block 41
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 5940:      for (i=0; i < tga_height; ++i) {
    %%%%%: 5940-block 42
    %%%%%: 5940-block 47
    %%%%%: 5940-block 48
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5941:         int row = tga_inverted ? tga_height -i - 1 : i;
    %%%%%: 5941-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5941-block 44
    %%%%%: 5941-block 45
    #####: 5942:         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
    #####: 5943:         stbi__getn(s, tga_row, tga_width * tga_comp);
    %%%%%: 5943-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5944:      }
    #####: 5945:   } else  {
    %%%%%: 5945-block 49
        -: 5946:      //   do I need to load a palette?
    #####: 5947:      if ( tga_indexed)
    %%%%%: 5947-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5948:      {
    #####: 5949:         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
    %%%%%: 5949-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5950:            STBI_FREE(tga_data);
    #####: 5951:            return stbi__errpuc("bad palette", "Corrupt TGA");
    %%%%%: 5951-block 52
call    0 never executed
        -: 5952:         }
        -: 5953:
        -: 5954:         //   any data to skip? (offset usually = 0)
    #####: 5955:         stbi__skip(s, tga_palette_start );
    %%%%%: 5955-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5956:         //   load the palette
    #####: 5957:         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
    %%%%%: 5957-block 55
call    0 never executed
    #####: 5958:         if (!tga_palette) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5959:            STBI_FREE(tga_data);
    #####: 5960:            return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 5960-block 57
call    0 never executed
        -: 5961:         }
    #####: 5962:         if (tga_rgb16) {
    %%%%%: 5962-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5963:            stbi_uc *pal_entry = tga_palette;
    #####: 5964:            STBI_ASSERT(tga_comp == STBI_rgb);
    %%%%%: 5964-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5964-block 61
call    2 never executed
    #####: 5965:            for (i=0; i < tga_palette_len; ++i) {
    %%%%%: 5965-block 62
    %%%%%: 5965-block 65
branch  0 never executed
branch  1 never executed
    #####: 5966:               stbi__tga_read_rgb16(s, pal_entry);
    %%%%%: 5966-block 63
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5967:               pal_entry += tga_comp;
    %%%%%: 5967-block 64
        -: 5968:            }
    #####: 5969:         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
    %%%%%: 5969-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5969-block 67
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 5970:               STBI_FREE(tga_data);
    #####: 5971:               STBI_FREE(tga_palette);
    #####: 5972:               return stbi__errpuc("bad palette", "Corrupt TGA");
    %%%%%: 5972-block 68
call    0 never executed
        -: 5973:         }
        -: 5974:      }
        -: 5975:      //   load the data
    #####: 5976:      for (i=0; i < tga_width * tga_height; ++i)
    %%%%%: 5976-block 70
    %%%%%: 5976-block 103
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 5977:      {
        -: 5978:         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
    #####: 5979:         if ( tga_is_RLE )
    %%%%%: 5979-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5980:         {
    #####: 5981:            if ( RLE_count == 0 )
    %%%%%: 5981-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5982:            {
        -: 5983:               //   yep, get the next byte as a RLE command
    #####: 5984:               int RLE_cmd = stbi__get8(s);
    %%%%%: 5984-block 73
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5985:               RLE_count = 1 + (RLE_cmd & 127);
    #####: 5986:               RLE_repeating = RLE_cmd >> 7;
    #####: 5987:               read_next_pixel = 1;
    %%%%%: 5987-block 74
    #####: 5988:            } else if ( !RLE_repeating )
    %%%%%: 5988-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5989:            {
    #####: 5990:               read_next_pixel = 1;
    %%%%%: 5990-block 76
        -: 5991:            }
        -: 5992:         } else
        -: 5993:         {
    #####: 5994:            read_next_pixel = 1;
    %%%%%: 5994-block 77
        -: 5995:         }
        -: 5996:         //   OK, if I need to read a pixel, do it now
    #####: 5997:         if ( read_next_pixel )
    %%%%%: 5997-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5998:         {
        -: 5999:            //   load however much data we did have
    #####: 6000:            if ( tga_indexed )
    %%%%%: 6000-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6001:            {
        -: 6002:               // read in index, then perform the lookup
    #####: 6003:               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
    %%%%%: 6003-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6003-block 81
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 6003-block 82
    %%%%%: 6003-block 83
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 6003-block 84
    #####: 6004:               if ( pal_idx >= tga_palette_len ) {
    %%%%%: 6004-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6005:                  // invalid index
    #####: 6006:                  pal_idx = 0;
    %%%%%: 6006-block 86
        -: 6007:               }
    #####: 6008:               pal_idx *= tga_comp;
    #####: 6009:               for (j = 0; j < tga_comp; ++j) {
    %%%%%: 6009-block 87
    %%%%%: 6009-block 89
branch  0 never executed
branch  1 never executed
    #####: 6010:                  raw_data[j] = tga_palette[pal_idx+j];
    %%%%%: 6010-block 88
        -: 6011:               }
    #####: 6012:            } else if(tga_rgb16) {
    %%%%%: 6012-block 90
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6013:               STBI_ASSERT(tga_comp == STBI_rgb);
    %%%%%: 6013-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6013-block 92
call    2 never executed
    #####: 6014:               stbi__tga_read_rgb16(s, raw_data);
    %%%%%: 6014-block 93
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6015:            } else {
        -: 6016:               //   read in the data raw
    #####: 6017:               for (j = 0; j < tga_comp; ++j) {
    %%%%%: 6017-block 94
    %%%%%: 6017-block 97
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6018:                  raw_data[j] = stbi__get8(s);
    %%%%%: 6018-block 95
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6018-block 96
        -: 6019:               }
        -: 6020:            }
        -: 6021:            //   clear the reading flag for the next pixel
    #####: 6022:            read_next_pixel = 0;
    %%%%%: 6022-block 98
        -: 6023:         } // end of reading a pixel
        -: 6024:
        -: 6025:         // copy data
    #####: 6026:         for (j = 0; j < tga_comp; ++j)
    %%%%%: 6026-block 99
    %%%%%: 6026-block 101
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6027:           tga_data[i*tga_comp+j] = raw_data[j];
    %%%%%: 6027-block 100
        -: 6028:
        -: 6029:         //   in case we're in RLE mode, keep counting down
    #####: 6030:         --RLE_count;
    %%%%%: 6030-block 102
        -: 6031:      }
        -: 6032:      //   do I need to invert the image?
    #####: 6033:      if ( tga_inverted )
    %%%%%: 6033-block 104
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6034:      {
    #####: 6035:         for (j = 0; j*2 < tga_height; ++j)
    %%%%%: 6035-block 105
    %%%%%: 6035-block 109
    %%%%%: 6035-block 110
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6036:         {
    #####: 6037:            int index1 = j * tga_width * tga_comp;
    #####: 6038:            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
    #####: 6039:            for (i = tga_width * tga_comp; i > 0; --i)
    %%%%%: 6039-block 106
    %%%%%: 6039-block 108
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6040:            {
    #####: 6041:               unsigned char temp = tga_data[index1];
    #####: 6042:               tga_data[index1] = tga_data[index2];
    #####: 6043:               tga_data[index2] = temp;
    #####: 6044:               ++index1;
    #####: 6045:               ++index2;
    %%%%%: 6045-block 107
        -: 6046:            }
        -: 6047:         }
        -: 6048:      }
        -: 6049:      //   clear my palette, if I had one
    #####: 6050:      if ( tga_palette != NULL )
    %%%%%: 6050-block 111
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6051:      {
    #####: 6052:         STBI_FREE( tga_palette );
    %%%%%: 6052-block 112
        -: 6053:      }
        -: 6054:   }
        -: 6055:
        -: 6056:   // swap RGB - if the source data was RGB16, it already is in the right order
    #####: 6057:   if (tga_comp >= 3 && !tga_rgb16)
    %%%%%: 6057-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6057-block 114
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6058:   {
    #####: 6059:      unsigned char* tga_pixel = tga_data;
    #####: 6060:      for (i=0; i < tga_width * tga_height; ++i)
    %%%%%: 6060-block 115
    %%%%%: 6060-block 117
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6061:      {
    #####: 6062:         unsigned char temp = tga_pixel[0];
    #####: 6063:         tga_pixel[0] = tga_pixel[2];
    #####: 6064:         tga_pixel[2] = temp;
    #####: 6065:         tga_pixel += tga_comp;
    %%%%%: 6065-block 116
        -: 6066:      }
        -: 6067:   }
        -: 6068:
        -: 6069:   // convert to target component count
    #####: 6070:   if (req_comp && req_comp != tga_comp)
    %%%%%: 6070-block 118
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6070-block 119
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6071:      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
    %%%%%: 6071-block 120
call    0 never executed
        -: 6072:
        -: 6073:   //   the things I do to get rid of an error message, and yet keep
        -: 6074:   //   Microsoft's C compilers happy... [8^(
    #####: 6075:   tga_palette_start = tga_palette_len = tga_palette_bits =
    #####: 6076:         tga_x_origin = tga_y_origin = 0;
        -: 6077:   STBI_NOTUSED(tga_palette_start);
        -: 6078:   //   OK, done
    #####: 6079:   return tga_data;
    %%%%%: 6079-block 121
        -: 6080:}
        -: 6081:#endif
        -: 6082:
        -: 6083:// *************************************************************************************************
        -: 6084:// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
        -: 6085:
        -: 6086:#ifndef STBI_NO_PSD
function _ZL14stbi__psd_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6087:static int stbi__psd_test(stbi__context *s)
        -: 6088:{
    #####: 6089:   int r = (stbi__get32be(s) == 0x38425053);
    %%%%%: 6089-block 2
call    0 never executed
    #####: 6090:   stbi__rewind(s);
call    0 never executed
    #####: 6091:   return r;
        -: 6092:}
        -: 6093:
function _ZL20stbi__psd_decode_rleP13stbi__contextPhi called 0 returned 0% blocks executed 0%
    #####: 6094:static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
        -: 6095:{
        -: 6096:   int count, nleft, len;
        -: 6097:
    #####: 6098:   count = 0;
    #####: 6099:   while ((nleft = pixelCount - count) > 0) {
    %%%%%: 6099-block 2
    %%%%%: 6099-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6100:      len = stbi__get8(s);
    %%%%%: 6100-block 3
call    0 never executed
    #####: 6101:      if (len == 128) {
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6102:         // No-op.
    #####: 6103:      } else if (len < 128) {
    %%%%%: 6103-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6104:         // Copy next len+1 bytes literally.
    #####: 6105:         len++;
    #####: 6106:         if (len > nleft) return 0; // corrupt data
    %%%%%: 6106-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6106-block 7
    #####: 6107:         count += len;
    #####: 6108:         while (len) {
    %%%%%: 6108-block 8
    %%%%%: 6108-block 11
branch  0 never executed
branch  1 never executed
    #####: 6109:            *p = stbi__get8(s);
    %%%%%: 6109-block 9
call    0 never executed
    #####: 6110:            p += 4;
    #####: 6111:            len--;
        -: 6112:         }
    #####: 6113:      } else if (len > 128) {
    %%%%%: 6113-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6114:         stbi_uc   val;
        -: 6115:         // Next -len+1 bytes in the dest are replicated from next source byte.
        -: 6116:         // (Interpret len as a negative 8-bit int.)
    #####: 6117:         len = 257 - len;
    #####: 6118:         if (len > nleft) return 0; // corrupt data
    %%%%%: 6118-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6118-block 14
    #####: 6119:         val = stbi__get8(s);
    %%%%%: 6119-block 15
call    0 never executed
    #####: 6120:         count += len;
    #####: 6121:         while (len) {
    %%%%%: 6121-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6122:            *p = val;
    #####: 6123:            p += 4;
    #####: 6124:            len--;
    %%%%%: 6124-block 17
        -: 6125:         }
        -: 6126:      }
        -: 6127:   }
        -: 6128:
    #####: 6129:   return 1;
    %%%%%: 6129-block 20
        -: 6130:}
        -: 6131:
function _ZL14stbi__psd_loadP13stbi__contextPiS1_S1_iP17stbi__result_infoi called 0 returned 0% blocks executed 0%
    #####: 6132:static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
        -: 6133:{
        -: 6134:   int pixelCount;
        -: 6135:   int channelCount, compression;
        -: 6136:   int channel, i;
        -: 6137:   int bitdepth;
        -: 6138:   int w,h;
        -: 6139:   stbi_uc *out;
        -: 6140:   STBI_NOTUSED(ri);
        -: 6141:
        -: 6142:   // Check identifier
    #####: 6143:   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
    %%%%%: 6143-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6144:      return stbi__errpuc("not PSD", "Corrupt PSD image");
    %%%%%: 6144-block 4
call    0 never executed
        -: 6145:
        -: 6146:   // Check file type version.
    #####: 6147:   if (stbi__get16be(s) != 1)
    %%%%%: 6147-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6148:      return stbi__errpuc("wrong version", "Unsupported version of PSD image");
    %%%%%: 6148-block 8
call    0 never executed
        -: 6149:
        -: 6150:   // Skip 6 reserved bytes.
    #####: 6151:   stbi__skip(s, 6 );
    %%%%%: 6151-block 10
call    0 never executed
        -: 6152:
        -: 6153:   // Read the number of channels (R, G, B, A, etc).
    #####: 6154:   channelCount = stbi__get16be(s);
call    0 never executed
    #####: 6155:   if (channelCount < 0 || channelCount > 16)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6155-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6156:      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
    %%%%%: 6156-block 14
call    0 never executed
        -: 6157:
        -: 6158:   // Read the rows and columns of the image.
    #####: 6159:   h = stbi__get32be(s);
    %%%%%: 6159-block 16
call    0 never executed
    #####: 6160:   w = stbi__get32be(s);
call    0 never executed
        -: 6161:
    #####: 6162:   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6162-block 19
call    2 never executed
    #####: 6163:   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 6163-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6163-block 22
call    2 never executed
        -: 6164:
        -: 6165:   // Make sure the depth is 8 bits.
    #####: 6166:   bitdepth = stbi__get16be(s);
    %%%%%: 6166-block 24
call    0 never executed
    #####: 6167:   if (bitdepth != 8 && bitdepth != 16)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6167-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6168:      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
    %%%%%: 6168-block 27
call    0 never executed
        -: 6169:
        -: 6170:   // Make sure the color mode is RGB.
        -: 6171:   // Valid options are:
        -: 6172:   //   0: Bitmap
        -: 6173:   //   1: Grayscale
        -: 6174:   //   2: Indexed color
        -: 6175:   //   3: RGB color
        -: 6176:   //   4: CMYK color
        -: 6177:   //   7: Multichannel
        -: 6178:   //   8: Duotone
        -: 6179:   //   9: Lab color
    #####: 6180:   if (stbi__get16be(s) != 3)
    %%%%%: 6180-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6181:      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
    %%%%%: 6181-block 31
call    0 never executed
        -: 6182:
        -: 6183:   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
    #####: 6184:   stbi__skip(s,stbi__get32be(s) );
    %%%%%: 6184-block 33
call    0 never executed
call    1 never executed
        -: 6185:
        -: 6186:   // Skip the image resources.  (resolution, pen tool paths, etc)
    #####: 6187:   stbi__skip(s, stbi__get32be(s) );
call    0 never executed
call    1 never executed
        -: 6188:
        -: 6189:   // Skip the reserved data.
    #####: 6190:   stbi__skip(s, stbi__get32be(s) );
call    0 never executed
call    1 never executed
        -: 6191:
        -: 6192:   // Find out if the data is compressed.
        -: 6193:   // Known values:
        -: 6194:   //   0: no compression
        -: 6195:   //   1: RLE compressed
    #####: 6196:   compression = stbi__get16be(s);
call    0 never executed
    #####: 6197:   if (compression > 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6198:      return stbi__errpuc("bad compression", "PSD has an unknown compression format");
    %%%%%: 6198-block 41
call    0 never executed
        -: 6199:
        -: 6200:   // Check size
    #####: 6201:   if (!stbi__mad3sizes_valid(4, w, h, 0))
    %%%%%: 6201-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6202:      return stbi__errpuc("too large", "Corrupt PSD");
    %%%%%: 6202-block 45
call    0 never executed
        -: 6203:
        -: 6204:   // Create the destination image.
        -: 6205:
    #####: 6206:   if (!compression && bitdepth == 16 && bpc == 16) {
    %%%%%: 6206-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6206-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6206-block 49
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6207:      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
    %%%%%: 6207-block 50
call    0 never executed
    #####: 6208:      ri->bits_per_channel = 16;
        -: 6209:   } else
    #####: 6210:      out = (stbi_uc *) stbi__malloc(4 * w*h);
    %%%%%: 6210-block 52
call    0 never executed
        -: 6211:
    #####: 6212:   if (!out) return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 6212-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6212-block 54
call    2 never executed
    #####: 6213:   pixelCount = w*h;
        -: 6214:
        -: 6215:   // Initialize the data to zero.
        -: 6216:   //memset( out, 0, pixelCount * 4 );
        -: 6217:
        -: 6218:   // Finally, the image data.
    #####: 6219:   if (compression) {
    %%%%%: 6219-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6220:      // RLE as used by .PSD and .TIFF
        -: 6221:      // Loop until you get the number of unpacked bytes you are expecting:
        -: 6222:      //     Read the next source byte into n.
        -: 6223:      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
        -: 6224:      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
        -: 6225:      //     Else if n is 128, noop.
        -: 6226:      // Endloop
        -: 6227:
        -: 6228:      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
        -: 6229:      // which we're going to just skip.
    #####: 6230:      stbi__skip(s, h * channelCount * 2 );
    %%%%%: 6230-block 57
call    0 never executed
        -: 6231:
        -: 6232:      // Read the RLE data by channel.
    #####: 6233:      for (channel = 0; channel < 4; channel++) {
    %%%%%: 6233-block 70
    %%%%%: 6233-block 71
branch  0 never executed
branch  1 never executed
        -: 6234:         stbi_uc *p;
        -: 6235:
    #####: 6236:         p = out+channel;
    #####: 6237:         if (channel >= channelCount) {
    %%%%%: 6237-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6238:            // Fill this channel with default data.
    #####: 6239:            for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6239-block 60
    %%%%%: 6239-block 65
branch  0 never executed
branch  1 never executed
    #####: 6240:               *p = (channel == 3 ? 255 : 0);
    %%%%%: 6240-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6240-block 62
    %%%%%: 6240-block 63
    %%%%%: 6240-block 64
        -: 6241:         } else {
        -: 6242:            // Read the RLE data.
    #####: 6243:            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
    %%%%%: 6243-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6244:               STBI_FREE(out);
    #####: 6245:               return stbi__errpuc("corrupt", "bad RLE data");
    %%%%%: 6245-block 68
call    0 never executed
        -: 6246:            }
        -: 6247:         }
        -: 6248:      }
        -: 6249:
        -: 6250:   } else {
        -: 6251:      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
        -: 6252:      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
        -: 6253:
        -: 6254:      // Read the data by channel.
    #####: 6255:      for (channel = 0; channel < 4; channel++) {
    %%%%%: 6255-block 72
    %%%%%: 6255-block 104
    %%%%%: 6255-block 105
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6256:         if (channel >= channelCount) {
    %%%%%: 6256-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6257:            // Fill this channel with default data.
    #####: 6258:            if (bitdepth == 16 && bpc == 16) {
    %%%%%: 6258-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6258-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6259:               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
    #####: 6260:               stbi__uint16 val = channel == 3 ? 65535 : 0;
    %%%%%: 6260-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6260-block 77
    %%%%%: 6260-block 78
    #####: 6261:               for (i = 0; i < pixelCount; i++, q += 4)
    %%%%%: 6261-block 79
    %%%%%: 6261-block 81
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6262:                  *q = val;
    %%%%%: 6262-block 80
    #####: 6263:            } else {
    %%%%%: 6263-block 82
    #####: 6264:               stbi_uc *p = out+channel;
    #####: 6265:               stbi_uc val = channel == 3 ? 255 : 0;
    %%%%%: 6265-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6265-block 84
    %%%%%: 6265-block 85
    #####: 6266:               for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6266-block 86
    %%%%%: 6266-block 88
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6267:                  *p = val;
    %%%%%: 6267-block 87
        -: 6268:            }
        -: 6269:         } else {
    #####: 6270:            if (ri->bits_per_channel == 16) {    // output bpc
    %%%%%: 6270-block 90
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6271:               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
    #####: 6272:               for (i = 0; i < pixelCount; i++, q += 4)
    %%%%%: 6272-block 91
    %%%%%: 6272-block 94
branch  0 never executed
branch  1 never executed
    #####: 6273:                  *q = (stbi__uint16) stbi__get16be(s);
    %%%%%: 6273-block 92
call    0 never executed
        -: 6274:            } else {
    #####: 6275:               stbi_uc *p = out+channel;
    #####: 6276:               if (bitdepth == 16) {  // input bpc
    %%%%%: 6276-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6277:                  for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6277-block 96
    %%%%%: 6277-block 99
branch  0 never executed
branch  1 never executed
    #####: 6278:                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
    %%%%%: 6278-block 97
call    0 never executed
        -: 6279:               } else {
    #####: 6280:                  for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6280-block 100
    %%%%%: 6280-block 103
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6281:                     *p = stbi__get8(s);
    %%%%%: 6281-block 101
call    0 never executed
        -: 6282:               }
        -: 6283:            }
        -: 6284:         }
        -: 6285:      }
        -: 6286:   }
        -: 6287:
        -: 6288:   // remove weird white matte from PSD
    #####: 6289:   if (channelCount >= 4) {
    %%%%%: 6289-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6290:      if (ri->bits_per_channel == 16) {
    %%%%%: 6290-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6291:         for (i=0; i < w*h; ++i) {
    %%%%%: 6291-block 108
    %%%%%: 6291-block 112
    %%%%%: 6291-block 113
branch  0 never executed
branch  1 never executed
    #####: 6292:            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
    #####: 6293:            if (pixel[3] != 0 && pixel[3] != 65535) {
    %%%%%: 6293-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6293-block 110
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6294:               float a = pixel[3] / 65535.0f;
    #####: 6295:               float ra = 1.0f / a;
    #####: 6296:               float inv_a = 65535.0f * (1 - ra);
    #####: 6297:               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
    #####: 6298:               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
    #####: 6299:               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
    %%%%%: 6299-block 111
        -: 6300:            }
        -: 6301:         }
        -: 6302:      } else {
    #####: 6303:         for (i=0; i < w*h; ++i) {
    %%%%%: 6303-block 114
    %%%%%: 6303-block 118
    %%%%%: 6303-block 119
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6304:            unsigned char *pixel = out + 4*i;
    #####: 6305:            if (pixel[3] != 0 && pixel[3] != 255) {
    %%%%%: 6305-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6305-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6306:               float a = pixel[3] / 255.0f;
    #####: 6307:               float ra = 1.0f / a;
    #####: 6308:               float inv_a = 255.0f * (1 - ra);
    #####: 6309:               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
    #####: 6310:               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
    #####: 6311:               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
    %%%%%: 6311-block 117
        -: 6312:            }
        -: 6313:         }
        -: 6314:      }
        -: 6315:   }
        -: 6316:
        -: 6317:   // convert to desired output format
    #####: 6318:   if (req_comp && req_comp != 4) {
    %%%%%: 6318-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6318-block 121
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6319:      if (ri->bits_per_channel == 16)
    %%%%%: 6319-block 122
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6320:         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
    %%%%%: 6320-block 123
call    0 never executed
        -: 6321:      else
    #####: 6322:         out = stbi__convert_format(out, 4, req_comp, w, h);
    %%%%%: 6322-block 124
call    0 never executed
    #####: 6323:      if (out == NULL) return out; // stbi__convert_format frees input on failure
    %%%%%: 6323-block 125
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6323-block 126
        -: 6324:   }
        -: 6325:
    #####: 6326:   if (comp) *comp = 4;
    %%%%%: 6326-block 127
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6326-block 128
    #####: 6327:   *y = h;
    #####: 6328:   *x = w;
        -: 6329:
    #####: 6330:   return out;
    %%%%%: 6330-block 129
        -: 6331:}
        -: 6332:#endif
        -: 6333:
        -: 6334:// *************************************************************************************************
        -: 6335:// Softimage PIC loader
        -: 6336:// by Tom Seddon
        -: 6337://
        -: 6338:// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
        -: 6339:// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
        -: 6340:
        -: 6341:#ifndef STBI_NO_PIC
function _ZL13stbi__pic_is4P13stbi__contextPKc called 0 returned 0% blocks executed 0%
    #####: 6342:static int stbi__pic_is4(stbi__context *s,const char *str)
        -: 6343:{
        -: 6344:   int i;
    #####: 6345:   for (i=0; i<4; ++i)
    %%%%%: 6345-block 2
    %%%%%: 6345-block 6
    %%%%%: 6345-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6346:      if (stbi__get8(s) != (stbi_uc)str[i])
    %%%%%: 6346-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6347:         return 0;
    %%%%%: 6347-block 5
        -: 6348:
    #####: 6349:   return 1;
    %%%%%: 6349-block 8
        -: 6350:}
        -: 6351:
function _ZL19stbi__pic_test_coreP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6352:static int stbi__pic_test_core(stbi__context *s)
        -: 6353:{
        -: 6354:   int i;
        -: 6355:
    #####: 6356:   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
    %%%%%: 6356-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6357:      return 0;
    %%%%%: 6357-block 4
        -: 6358:
    #####: 6359:   for(i=0;i<84;++i)
    %%%%%: 6359-block 5
    %%%%%: 6359-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6360:      stbi__get8(s);
    %%%%%: 6360-block 6
call    0 never executed
        -: 6361:
    #####: 6362:   if (!stbi__pic_is4(s,"PICT"))
    %%%%%: 6362-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6363:      return 0;
    %%%%%: 6363-block 11
        -: 6364:
    #####: 6365:   return 1;
    %%%%%: 6365-block 12
        -: 6366:}
        -: 6367:
        -: 6368:typedef struct
        -: 6369:{
        -: 6370:   stbi_uc size,type,channel;
        -: 6371:} stbi__pic_packet;
        -: 6372:
function _ZL13stbi__readvalP13stbi__contextiPh called 0 returned 0% blocks executed 0%
    #####: 6373:static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
        -: 6374:{
    #####: 6375:   int mask=0x80, i;
        -: 6376:
    #####: 6377:   for (i=0; i<4; ++i, mask>>=1) {
    %%%%%: 6377-block 2
    %%%%%: 6377-block 10
    %%%%%: 6377-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6378:      if (channel & mask) {
    %%%%%: 6378-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6379:         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
    %%%%%: 6379-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6379-block 6
call    3 never executed
    #####: 6380:         dest[i]=stbi__get8(s);
    %%%%%: 6380-block 8
call    0 never executed
        -: 6381:      }
        -: 6382:   }
        -: 6383:
    #####: 6384:   return dest;
    %%%%%: 6384-block 12
        -: 6385:}
        -: 6386:
function _ZL13stbi__copyvaliPhPKh called 0 returned 0% blocks executed 0%
    #####: 6387:static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
        -: 6388:{
    #####: 6389:   int mask=0x80,i;
        -: 6390:
    #####: 6391:   for (i=0;i<4; ++i, mask>>=1)
    %%%%%: 6391-block 2
    %%%%%: 6391-block 5
    %%%%%: 6391-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6392:      if (channel&mask)
    %%%%%: 6392-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6393:         dest[i]=src[i];
    %%%%%: 6393-block 4
    #####: 6394:}
        -: 6395:
function _ZL19stbi__pic_load_coreP13stbi__contextiiPiPh called 0 returned 0% blocks executed 0%
    #####: 6396:static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
        -: 6397:{
    #####: 6398:   int act_comp=0,num_packets=0,y,chained;
    %%%%%: 6398-block 2
        -: 6399:   stbi__pic_packet packets[10];
        -: 6400:
        -: 6401:   // this will (should...) cater for even some bizarre stuff like having data
        -: 6402:    // for the same channel in multiple packets.
        -: 6403:   do {
        -: 6404:      stbi__pic_packet *packet;
        -: 6405:
    #####: 6406:      if (num_packets==sizeof(packets)/sizeof(packets[0]))
    %%%%%: 6406-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6407:         return stbi__errpuc("bad format","too many packets");
    %%%%%: 6407-block 4
call    0 never executed
        -: 6408:
    #####: 6409:      packet = &packets[num_packets++];
        -: 6410:
    #####: 6411:      chained = stbi__get8(s);
    %%%%%: 6411-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6412:      packet->size    = stbi__get8(s);
    %%%%%: 6412-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6413:      packet->type    = stbi__get8(s);
    %%%%%: 6413-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6414:      packet->channel = stbi__get8(s);
    %%%%%: 6414-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6415:
    #####: 6416:      act_comp |= packet->channel;
        -: 6417:
    #####: 6418:      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
    %%%%%: 6418-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6418-block 11
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6418-block 12
call    5 never executed
    #####: 6419:      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
    %%%%%: 6419-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6419-block 15
call    2 never executed
    #####: 6420:   } while (chained);
    %%%%%: 6420-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6421:
    #####: 6422:   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?
    %%%%%: 6422-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6422-block 19
    %%%%%: 6422-block 20
        -: 6423:
    #####: 6424:   for(y=0; y<height; ++y) {
    %%%%%: 6424-block 21
    %%%%%: 6424-block 89
    %%%%%: 6424-block 90
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6425:      int packet_idx;
        -: 6426:
    #####: 6427:      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
    %%%%%: 6427-block 22
    %%%%%: 6427-block 87
    %%%%%: 6427-block 88
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6428:         stbi__pic_packet *packet = &packets[packet_idx];
    #####: 6429:         stbi_uc *dest = result+y*width*4;
        -: 6430:
    #####: 6431:         switch (packet->type) {
    %%%%%: 6431-block 23
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6432:            default:
    #####: 6433:               return stbi__errpuc("bad format","packet has bad compression type");
    %%%%%: 6433-block 24
call    0 never executed
        -: 6434:
    #####: 6435:            case 0: {//uncompressed
        -: 6436:               int x;
        -: 6437:
    #####: 6438:               for(x=0;x<width;++x, dest+=4)
    %%%%%: 6438-block 26
    %%%%%: 6438-block 30
    %%%%%: 6438-block 31
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6439:                  if (!stbi__readval(s,packet->channel,dest))
    %%%%%: 6439-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6439-block 28
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6440:                     return 0;
    %%%%%: 6440-block 29
    #####: 6441:               break;
    %%%%%: 6441-block 32
        -: 6442:            }
        -: 6443:
    #####: 6444:            case 1://Pure RLE
        -: 6445:               {
    #####: 6446:                  int left=width, i;
        -: 6447:
    #####: 6448:                  while (left>0) {
    %%%%%: 6448-block 33
    %%%%%: 6448-block 50
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6449:                     stbi_uc count,value[4];
        -: 6450:
    #####: 6451:                     count=stbi__get8(s);
    %%%%%: 6451-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6452:                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");
    %%%%%: 6452-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6452-block 36
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6452-block 37
call    5 never executed
    %%%%%: 6452-block 49
        -: 6453:
    #####: 6454:                     if (count > left)
    %%%%%: 6454-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6455:                        count = (stbi_uc) left;
    %%%%%: 6455-block 40
        -: 6456:
    #####: 6457:                     if (!stbi__readval(s,packet->channel,value))  return 0;
    %%%%%: 6457-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6457-block 42
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6457-block 43
        -: 6458:
    #####: 6459:                     for(i=0; i<count; ++i,dest+=4)
    %%%%%: 6459-block 44
    %%%%%: 6459-block 47
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6460:                        stbi__copyval(packet->channel,dest,value);
    %%%%%: 6460-block 45
call    0 never executed
    #####: 6461:                     left -= count;
    %%%%%: 6461-block 48
        -: 6462:                  }
        -: 6463:               }
    #####: 6464:               break;
    %%%%%: 6464-block 51
        -: 6465:
    #####: 6466:            case 2: {//Mixed RLE
    #####: 6467:               int left=width;
    #####: 6468:               while (left>0) {
    %%%%%: 6468-block 52
    %%%%%: 6468-block 85
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6469:                  int count = stbi__get8(s), i;
    %%%%%: 6469-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6470:                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");
    %%%%%: 6470-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6470-block 55
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6470-block 56
call    5 never executed
        -: 6471:
    #####: 6472:                  if (count >= 128) { // Repeated
    %%%%%: 6472-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6473:                     stbi_uc value[4];
        -: 6474:
    #####: 6475:                     if (count==128)
    %%%%%: 6475-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6476:                        count = stbi__get16be(s);
    %%%%%: 6476-block 60
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6476-block 61
        -: 6477:                     else
    #####: 6478:                        count -= 127;
    %%%%%: 6478-block 62
    #####: 6479:                     if (count > left)
    %%%%%: 6479-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6480:                        return stbi__errpuc("bad file","scanline overrun");
    %%%%%: 6480-block 64
call    0 never executed
    %%%%%: 6480-block 74
        -: 6481:
    #####: 6482:                     if (!stbi__readval(s,packet->channel,value))
    %%%%%: 6482-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6482-block 67
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6483:                        return 0;
    %%%%%: 6483-block 68
        -: 6484:
    #####: 6485:                     for(i=0;i<count;++i, dest += 4)
    %%%%%: 6485-block 69
    %%%%%: 6485-block 72
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6486:                        stbi__copyval(packet->channel,dest,value);
    %%%%%: 6486-block 70
call    0 never executed
        -: 6487:                  } else { // Raw
    #####: 6488:                     ++count;
    #####: 6489:                     if (count>left) return stbi__errpuc("bad file","scanline overrun");
    %%%%%: 6489-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6489-block 76
call    2 never executed
        -: 6490:
    #####: 6491:                     for(i=0;i<count;++i, dest+=4)
    %%%%%: 6491-block 78
    %%%%%: 6491-block 82
    %%%%%: 6491-block 83
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6492:                        if (!stbi__readval(s,packet->channel,dest))
    %%%%%: 6492-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6492-block 80
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6493:                           return 0;
    %%%%%: 6493-block 81
        -: 6494:                  }
    #####: 6495:                  left-=count;
    %%%%%: 6495-block 84
        -: 6496:               }
    #####: 6497:               break;
    %%%%%: 6497-block 86
        -: 6498:            }
        -: 6499:         }
        -: 6500:      }
        -: 6501:   }
        -: 6502:
    #####: 6503:   return result;
    %%%%%: 6503-block 91
        -: 6504:}
        -: 6505:
function _ZL14stbi__pic_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 6506:static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
        -: 6507:{
        -: 6508:   stbi_uc *result;
        -: 6509:   int i, x,y, internal_comp;
        -: 6510:   STBI_NOTUSED(ri);
        -: 6511:
    #####: 6512:   if (!comp) comp = &internal_comp;
    %%%%%: 6512-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6512-block 3
        -: 6513:
    #####: 6514:   for (i=0; i<92; ++i)
    %%%%%: 6514-block 4
    %%%%%: 6514-block 6
    %%%%%: 6514-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6515:      stbi__get8(s);
    %%%%%: 6515-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6516:
    #####: 6517:   x = stbi__get16be(s);
    %%%%%: 6517-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6518:   y = stbi__get16be(s);
    %%%%%: 6518-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6519:
    #####: 6520:   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 6520-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6520-block 11
call    2 never executed
    #####: 6521:   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 6521-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6521-block 14
call    2 never executed
        -: 6522:
    #####: 6523:   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
    %%%%%: 6523-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6523-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6523-block 18
call    5 never executed
    #####: 6524:   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");
    %%%%%: 6524-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6524-block 22
call    3 never executed
        -: 6525:
    #####: 6526:   stbi__get32be(s); //skip `ratio'
    %%%%%: 6526-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6527:   stbi__get16be(s); //skip `fields'
    %%%%%: 6527-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6528:   stbi__get16be(s); //skip `pad'
    %%%%%: 6528-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6529:
        -: 6530:   // intermediate buffer is RGBA
    #####: 6531:   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
    %%%%%: 6531-block 27
call    0 never executed
    #####: 6532:   if (!result) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6532-block 29
call    2 never executed
    #####: 6533:   memset(result, 0xff, x*y*4);
        -: 6534:
    #####: 6535:   if (!stbi__pic_load_core(s,x,y,comp, result)) {
    %%%%%: 6535-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6535-block 32
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6536:      STBI_FREE(result);
    #####: 6537:      result=0;
    %%%%%: 6537-block 33
        -: 6538:   }
    #####: 6539:   *px = x;
    #####: 6540:   *py = y;
    #####: 6541:   if (req_comp == 0) req_comp = *comp;
    %%%%%: 6541-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6541-block 35
    #####: 6542:   result=stbi__convert_format(result,4,req_comp,x,y);
    %%%%%: 6542-block 36
call    0 never executed
        -: 6543:
    #####: 6544:   return result;
        -: 6545:}
        -: 6546:
function _ZL14stbi__pic_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6547:static int stbi__pic_test(stbi__context *s)
        -: 6548:{
    #####: 6549:   int r = stbi__pic_test_core(s);
    %%%%%: 6549-block 2
call    0 never executed
    #####: 6550:   stbi__rewind(s);
call    0 never executed
    #####: 6551:   return r;
        -: 6552:}
        -: 6553:#endif
        -: 6554:
        -: 6555:// *************************************************************************************************
        -: 6556:// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
        -: 6557:
        -: 6558:#ifndef STBI_NO_GIF
        -: 6559:typedef struct
        -: 6560:{
        -: 6561:   stbi__int16 prefix;
        -: 6562:   stbi_uc first;
        -: 6563:   stbi_uc suffix;
        -: 6564:} stbi__gif_lzw;
        -: 6565:
        -: 6566:typedef struct
        -: 6567:{
        -: 6568:   int w,h;
        -: 6569:   stbi_uc *out;                 // output buffer (always 4 components)
        -: 6570:   stbi_uc *background;          // The current "background" as far as a gif is concerned
        -: 6571:   stbi_uc *history;
        -: 6572:   int flags, bgindex, ratio, transparent, eflags;
        -: 6573:   stbi_uc  pal[256][4];
        -: 6574:   stbi_uc lpal[256][4];
        -: 6575:   stbi__gif_lzw codes[8192];
        -: 6576:   stbi_uc *color_table;
        -: 6577:   int parse, step;
        -: 6578:   int lflags;
        -: 6579:   int start_x, start_y;
        -: 6580:   int max_x, max_y;
        -: 6581:   int cur_x, cur_y;
        -: 6582:   int line_size;
        -: 6583:   int delay;
        -: 6584:} stbi__gif;
        -: 6585:
function _ZL18stbi__gif_test_rawP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6586:static int stbi__gif_test_raw(stbi__context *s)
        -: 6587:{
        -: 6588:   int sz;
    #####: 6589:   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
    %%%%%: 6589-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6589-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6589-block 6
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 6589-block 8
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 6589-block 10
    %%%%%: 6589-block 11
    %%%%%: 6589-block 12
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%: 6589-block 13
    #####: 6590:   sz = stbi__get8(s);
    %%%%%: 6590-block 14
call    0 never executed
    #####: 6591:   if (sz != '9' && sz != '7') return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6591-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6591-block 17
    #####: 6592:   if (stbi__get8(s) != 'a') return 0;
    %%%%%: 6592-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6592-block 20
    #####: 6593:   return 1;
    %%%%%: 6593-block 21
        -: 6594:}
        -: 6595:
function _ZL14stbi__gif_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6596:static int stbi__gif_test(stbi__context *s)
        -: 6597:{
    #####: 6598:   int r = stbi__gif_test_raw(s);
    %%%%%: 6598-block 2
call    0 never executed
    #####: 6599:   stbi__rewind(s);
call    0 never executed
    #####: 6600:   return r;
        -: 6601:}
        -: 6602:
function _ZL26stbi__gif_parse_colortableP13stbi__contextPA4_hii called 0 returned 0% blocks executed 0%
    #####: 6603:static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
        -: 6604:{
        -: 6605:   int i;
    #####: 6606:   for (i=0; i < num_entries; ++i) {
    %%%%%: 6606-block 2
    %%%%%: 6606-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6607:      pal[i][2] = stbi__get8(s);
    %%%%%: 6607-block 3
call    0 never executed
    #####: 6608:      pal[i][1] = stbi__get8(s);
call    0 never executed
    #####: 6609:      pal[i][0] = stbi__get8(s);
call    0 never executed
    #####: 6610:      pal[i][3] = transp == i ? 0 : 255;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6610-block 7
    %%%%%: 6610-block 8
    %%%%%: 6610-block 9
        -: 6611:   }
    #####: 6612:}
        -: 6613:
function _ZL16stbi__gif_headerP13stbi__contextP9stbi__gifPii called 0 returned 0% blocks executed 0%
    #####: 6614:static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
        -: 6615:{
        -: 6616:   stbi_uc version;
    #####: 6617:   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
    %%%%%: 6617-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6617-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6617-block 6
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 6617-block 8
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 6617-block 10
    %%%%%: 6617-block 11
    %%%%%: 6617-block 12
branch 12 never executed (fallthrough)
branch 13 never executed
    #####: 6618:      return stbi__err("not GIF", "Corrupt GIF");
    %%%%%: 6618-block 13
call    0 never executed
        -: 6619:
    #####: 6620:   version = stbi__get8(s);
    %%%%%: 6620-block 14
call    0 never executed
    #####: 6621:   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6621-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6621-block 17
call    4 never executed
    #####: 6622:   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");
    %%%%%: 6622-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6622-block 20
call    3 never executed
        -: 6623:
    #####: 6624:   stbi__g_failure_reason = "";
    #####: 6625:   g->w = stbi__get16le(s);
    %%%%%: 6625-block 21
call    0 never executed
    #####: 6626:   g->h = stbi__get16le(s);
call    0 never executed
    #####: 6627:   g->flags = stbi__get8(s);
call    0 never executed
    #####: 6628:   g->bgindex = stbi__get8(s);
call    0 never executed
    #####: 6629:   g->ratio = stbi__get8(s);
call    0 never executed
    #####: 6630:   g->transparent = -1;
        -: 6631:
    #####: 6632:   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6632-block 27
call    2 never executed
    #####: 6633:   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    %%%%%: 6633-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6633-block 29
call    2 never executed
        -: 6634:
    #####: 6635:   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments
    %%%%%: 6635-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6635-block 31
        -: 6636:
    #####: 6637:   if (is_info) return 1;
    %%%%%: 6637-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6637-block 33
        -: 6638:
    #####: 6639:   if (g->flags & 0x80)
    %%%%%: 6639-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6640:      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);
    %%%%%: 6640-block 35
call    0 never executed
        -: 6641:
    #####: 6642:   return 1;
    %%%%%: 6642-block 36
        -: 6643:}
        -: 6644:
function _ZL18stbi__gif_info_rawP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 6645:static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
        -: 6646:{
    #####: 6647:   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
    %%%%%: 6647-block 2
call    0 never executed
    #####: 6648:   if (!g) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6648-block 4
call    2 never executed
    #####: 6649:   if (!stbi__gif_header(s, g, comp, 1)) {
    %%%%%: 6649-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6650:      STBI_FREE(g);
    #####: 6651:      stbi__rewind( s );
    %%%%%: 6651-block 7
call    0 never executed
    #####: 6652:      return 0;
        -: 6653:   }
    #####: 6654:   if (x) *x = g->w;
    %%%%%: 6654-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6654-block 10
    #####: 6655:   if (y) *y = g->h;
    %%%%%: 6655-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6655-block 12
    #####: 6656:   STBI_FREE(g);
    #####: 6657:   return 1;
    %%%%%: 6657-block 13
        -: 6658:}
        -: 6659:
function _ZL18stbi__out_gif_codeP9stbi__gift called 0 returned 0% blocks executed 0%
    #####: 6660:static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
        -: 6661:{
        -: 6662:   stbi_uc *p, *c;
        -: 6663:   int idx;
        -: 6664:
        -: 6665:   // recurse to decode the prefixes, since the linked-list is backwards,
        -: 6666:   // and working backwards through an interleaved image would be nasty
    #####: 6667:   if (g->codes[code].prefix >= 0)
    %%%%%: 6667-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6668:      stbi__out_gif_code(g, g->codes[code].prefix);
    %%%%%: 6668-block 3
call    0 never executed
        -: 6669:
    #####: 6670:   if (g->cur_y >= g->max_y) return;
    %%%%%: 6670-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6670-block 5
        -: 6671:
    #####: 6672:   idx = g->cur_x + g->cur_y;
    #####: 6673:   p = &g->out[idx];
    #####: 6674:   g->history[idx / 4] = 1;
        -: 6675:
    #####: 6676:   c = &g->color_table[g->codes[code].suffix * 4];
    #####: 6677:   if (c[3] > 128) { // don't render transparent pixels;
    %%%%%: 6677-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6678:      p[0] = c[2];
    #####: 6679:      p[1] = c[1];
    #####: 6680:      p[2] = c[0];
    #####: 6681:      p[3] = c[3];
    %%%%%: 6681-block 7
        -: 6682:   }
    #####: 6683:   g->cur_x += 4;
        -: 6684:
    #####: 6685:   if (g->cur_x >= g->max_x) {
    %%%%%: 6685-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6686:      g->cur_x = g->start_x;
    #####: 6687:      g->cur_y += g->step;
        -: 6688:
    #####: 6689:      while (g->cur_y >= g->max_y && g->parse > 0) {
    %%%%%: 6689-block 9
    %%%%%: 6689-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6689-block 12
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 6690:         g->step = (1 << g->parse) * g->line_size;
    #####: 6691:         g->cur_y = g->start_y + (g->step >> 1);
    #####: 6692:         --g->parse;
    %%%%%: 6692-block 10
        -: 6693:      }
        -: 6694:   }
        -: 6695:}
        -: 6696:
function _ZL24stbi__process_gif_rasterP13stbi__contextP9stbi__gif called 0 returned 0% blocks executed 0%
    #####: 6697:static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
        -: 6698:{
        -: 6699:   stbi_uc lzw_cs;
        -: 6700:   stbi__int32 len, init_code;
        -: 6701:   stbi__uint32 first;
        -: 6702:   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
        -: 6703:   stbi__gif_lzw *p;
        -: 6704:
    #####: 6705:   lzw_cs = stbi__get8(s);
    %%%%%: 6705-block 2
call    0 never executed
    #####: 6706:   if (lzw_cs > 12) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6706-block 4
    #####: 6707:   clear = 1 << lzw_cs;
    #####: 6708:   first = 1;
    #####: 6709:   codesize = lzw_cs + 1;
    #####: 6710:   codemask = (1 << codesize) - 1;
    #####: 6711:   bits = 0;
    #####: 6712:   valid_bits = 0;
    #####: 6713:   for (init_code = 0; init_code < clear; init_code++) {
    %%%%%: 6713-block 5
    %%%%%: 6713-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6714:      g->codes[init_code].prefix = -1;
    #####: 6715:      g->codes[init_code].first = (stbi_uc) init_code;
    #####: 6716:      g->codes[init_code].suffix = (stbi_uc) init_code;
    %%%%%: 6716-block 6
        -: 6717:   }
        -: 6718:
        -: 6719:   // support no starting clear code
    #####: 6720:   avail = clear+2;
    #####: 6721:   oldcode = -1;
        -: 6722:
    #####: 6723:   len = 0;
    %%%%%: 6723-block 8
        -: 6724:   for(;;) {
    #####: 6725:      if (valid_bits < codesize) {
    %%%%%: 6725-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6726:         if (len == 0) {
    %%%%%: 6726-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6727:            len = stbi__get8(s); // start new block
    %%%%%: 6727-block 11
call    0 never executed
    #####: 6728:            if (len == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6729:               return g->out;
    %%%%%: 6729-block 13
        -: 6730:         }
    #####: 6731:         --len;
    #####: 6732:         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
    %%%%%: 6732-block 14
call    0 never executed
    #####: 6733:         valid_bits += 8;
        -: 6734:      } else {
    #####: 6735:         stbi__int32 code = bits & codemask;
    #####: 6736:         bits >>= codesize;
    #####: 6737:         valid_bits -= codesize;
        -: 6738:         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
    #####: 6739:         if (code == clear) {  // clear code
    %%%%%: 6739-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6740:            codesize = lzw_cs + 1;
    #####: 6741:            codemask = (1 << codesize) - 1;
    #####: 6742:            avail = clear + 2;
    #####: 6743:            oldcode = -1;
    #####: 6744:            first = 0;
    %%%%%: 6744-block 17
    #####: 6745:         } else if (code == clear + 1) { // end of stream code
    %%%%%: 6745-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6746:            stbi__skip(s, len);
    %%%%%: 6746-block 19
call    0 never executed
    #####: 6747:            while ((len = stbi__get8(s)) > 0)
    %%%%%: 6747-block 22
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 6748:               stbi__skip(s,len);
    %%%%%: 6748-block 21
call    0 never executed
    #####: 6749:            return g->out;
    %%%%%: 6749-block 24
    #####: 6750:         } else if (code <= avail) {
    %%%%%: 6750-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6751:            if (first) {
    %%%%%: 6751-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6752:               return stbi__errpuc("no clear code", "Corrupt GIF");
    %%%%%: 6752-block 27
call    0 never executed
        -: 6753:            }
        -: 6754:
    #####: 6755:            if (oldcode >= 0) {
    %%%%%: 6755-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6756:               p = &g->codes[avail++];
    #####: 6757:               if (avail > 8192) {
    %%%%%: 6757-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6758:                  return stbi__errpuc("too many codes", "Corrupt GIF");
    %%%%%: 6758-block 31
call    0 never executed
        -: 6759:               }
        -: 6760:
    #####: 6761:               p->prefix = (stbi__int16) oldcode;
    #####: 6762:               p->first = g->codes[oldcode].first;
    #####: 6763:               p->suffix = (code == avail) ? p->first : g->codes[code].first;
    %%%%%: 6763-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6763-block 34
    %%%%%: 6763-block 35
    %%%%%: 6763-block 36
    #####: 6764:            } else if (code == avail)
    %%%%%: 6764-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6765:               return stbi__errpuc("illegal code in raster", "Corrupt GIF");
    %%%%%: 6765-block 38
call    0 never executed
        -: 6766:
    #####: 6767:            stbi__out_gif_code(g, (stbi__uint16) code);
    %%%%%: 6767-block 40
call    0 never executed
        -: 6768:
    #####: 6769:            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6769-block 42
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6770:               codesize++;
    #####: 6771:               codemask = (1 << codesize) - 1;
    %%%%%: 6771-block 43
        -: 6772:            }
        -: 6773:
    #####: 6774:            oldcode = code;
    %%%%%: 6774-block 44
        -: 6775:         } else {
    #####: 6776:            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
    %%%%%: 6776-block 45
call    0 never executed
        -: 6777:         }
        -: 6778:      }
    #####: 6779:   }
    %%%%%: 6779-block 47
        -: 6780:}
        -: 6781:
        -: 6782:// this function is designed to support animated gifs, although stb_image doesn't support it
        -: 6783:// two back is the image from two frames ago, used for a very specific disposal format
function _ZL19stbi__gif_load_nextP13stbi__contextP9stbi__gifPiiPh called 0 returned 0% blocks executed 0%
    #####: 6784:static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
        -: 6785:{
        -: 6786:   int dispose;
        -: 6787:   int first_frame;
        -: 6788:   int pi;
        -: 6789:   int pcount;
        -: 6790:   STBI_NOTUSED(req_comp);
        -: 6791:
        -: 6792:   // on first frame, any non-written pixels get the background colour (non-transparent)
    #####: 6793:   first_frame = 0;
    #####: 6794:   if (g->out == 0) {
    %%%%%: 6794-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6795:      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
    %%%%%: 6795-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6795-block 5
    #####: 6796:      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
    %%%%%: 6796-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6797:         return stbi__errpuc("too large", "GIF image is too large");
    %%%%%: 6797-block 8
call    0 never executed
    #####: 6798:      pcount = g->w * g->h;
    #####: 6799:      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
    %%%%%: 6799-block 10
call    0 never executed
    #####: 6800:      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
call    0 never executed
    #####: 6801:      g->history = (stbi_uc *) stbi__malloc(pcount);
call    0 never executed
    #####: 6802:      if (!g->out || !g->background || !g->history)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6802-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6802-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6803:         return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 6803-block 16
call    0 never executed
        -: 6804:
        -: 6805:      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
        -: 6806:      // background colour is only used for pixels that are not rendered first frame, after that "background"
        -: 6807:      // color refers to the color that was there the previous frame.
    #####: 6808:      memset(g->out, 0x00, 4 * pcount);
    #####: 6809:      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
    #####: 6810:      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
    #####: 6811:      first_frame = 1;
    %%%%%: 6811-block 18
        -: 6812:   } else {
        -: 6813:      // second frame - how do we dispose of the previous one?
    #####: 6814:      dispose = (g->eflags & 0x1C) >> 2;
    #####: 6815:      pcount = g->w * g->h;
        -: 6816:
    #####: 6817:      if ((dispose == 3) && (two_back == 0)) {
    %%%%%: 6817-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6817-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6818:         dispose = 2; // if I don't have an image to revert back to, default to the old background
    %%%%%: 6818-block 21
        -: 6819:      }
        -: 6820:
    #####: 6821:      if (dispose == 3) { // use previous graphic
    %%%%%: 6821-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6822:         for (pi = 0; pi < pcount; ++pi) {
    %%%%%: 6822-block 23
    %%%%%: 6822-block 26
    %%%%%: 6822-block 27
branch  0 never executed
branch  1 never executed
    #####: 6823:            if (g->history[pi]) {
    %%%%%: 6823-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6824:               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
    %%%%%: 6824-block 25
        -: 6825:            }
        -: 6826:         }
    #####: 6827:      } else if (dispose == 2) {
    %%%%%: 6827-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6828:         // restore what was changed last frame to background before that frame;
    #####: 6829:         for (pi = 0; pi < pcount; ++pi) {
    %%%%%: 6829-block 29
    %%%%%: 6829-block 32
    %%%%%: 6829-block 33
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6830:            if (g->history[pi]) {
    %%%%%: 6830-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6831:               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
    %%%%%: 6831-block 31
        -: 6832:            }
        -: 6833:         }
        -: 6834:      } else {
        -: 6835:         // This is a non-disposal case eithe way, so just
        -: 6836:         // leave the pixels as is, and they will become the new background
        -: 6837:         // 1: do not dispose
        -: 6838:         // 0:  not specified.
        -: 6839:      }
        -: 6840:
        -: 6841:      // background is what out is after the undoing of the previou frame;
    #####: 6842:      memcpy( g->background, g->out, 4 * g->w * g->h );
    %%%%%: 6842-block 34
        -: 6843:   }
        -: 6844:
        -: 6845:   // clear my history;
    #####: 6846:   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame
    %%%%%: 6846-block 35
        -: 6847:
        -: 6848:   for (;;) {
    #####: 6849:      int tag = stbi__get8(s);
    %%%%%: 6849-block 36
call    0 never executed
    #####: 6850:      switch (tag) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6851:         case 0x2C: /* Image Descriptor */
        -: 6852:         {
        -: 6853:            stbi__int32 x, y, w, h;
        -: 6854:            stbi_uc *o;
        -: 6855:
    #####: 6856:            x = stbi__get16le(s);
    %%%%%: 6856-block 38
call    0 never executed
    #####: 6857:            y = stbi__get16le(s);
call    0 never executed
    #####: 6858:            w = stbi__get16le(s);
call    0 never executed
    #####: 6859:            h = stbi__get16le(s);
call    0 never executed
    #####: 6860:            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6860-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6861:               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");
    %%%%%: 6861-block 44
call    0 never executed
        -: 6862:
    #####: 6863:            g->line_size = g->w * 4;
    #####: 6864:            g->start_x = x * 4;
    #####: 6865:            g->start_y = y * g->line_size;
    #####: 6866:            g->max_x   = g->start_x + w * 4;
    #####: 6867:            g->max_y   = g->start_y + h * g->line_size;
    #####: 6868:            g->cur_x   = g->start_x;
    #####: 6869:            g->cur_y   = g->start_y;
        -: 6870:
        -: 6871:            // if the width of the specified rectangle is 0, that means
        -: 6872:            // we may not see *any* pixels or the image is malformed;
        -: 6873:            // to make sure this is caught, move the current y down to
        -: 6874:            // max_y (which is what out_gif_code checks).
    #####: 6875:            if (w == 0)
    %%%%%: 6875-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6876:               g->cur_y = g->max_y;
    %%%%%: 6876-block 47
        -: 6877:
    #####: 6878:            g->lflags = stbi__get8(s);
    %%%%%: 6878-block 48
call    0 never executed
        -: 6879:
    #####: 6880:            if (g->lflags & 0x40) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6881:               g->step = 8 * g->line_size; // first interlaced spacing
    #####: 6882:               g->parse = 3;
    %%%%%: 6882-block 50
        -: 6883:            } else {
    #####: 6884:               g->step = g->line_size;
    #####: 6885:               g->parse = 0;
    %%%%%: 6885-block 51
        -: 6886:            }
        -: 6887:
    #####: 6888:            if (g->lflags & 0x80) {
    %%%%%: 6888-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6889:               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
    %%%%%: 6889-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6889-block 54
    %%%%%: 6889-block 55
    %%%%%: 6889-block 56
call    2 never executed
    #####: 6890:               g->color_table = (stbi_uc *) g->lpal;
    #####: 6891:            } else if (g->flags & 0x80) {
    %%%%%: 6891-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6892:               g->color_table = (stbi_uc *) g->pal;
    %%%%%: 6892-block 59
        -: 6893:            } else
    #####: 6894:               return stbi__errpuc("missing color table", "Corrupt GIF");
    %%%%%: 6894-block 60
call    0 never executed
        -: 6895:
    #####: 6896:            o = stbi__process_gif_raster(s, g);
    %%%%%: 6896-block 62
call    0 never executed
    #####: 6897:            if (!o) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6897-block 64
        -: 6898:
        -: 6899:            // if this was the first frame,
    #####: 6900:            pcount = g->w * g->h;
    #####: 6901:            if (first_frame && (g->bgindex > 0)) {
    %%%%%: 6901-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6901-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6902:               // if first frame, any pixel not drawn to gets the background color
    #####: 6903:               for (pi = 0; pi < pcount; ++pi) {
    %%%%%: 6903-block 67
    %%%%%: 6903-block 70
    %%%%%: 6903-block 71
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6904:                  if (g->history[pi] == 0) {
    %%%%%: 6904-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6905:                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
    #####: 6906:                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
    %%%%%: 6906-block 69
        -: 6907:                  }
        -: 6908:               }
        -: 6909:            }
        -: 6910:
    #####: 6911:            return o;
    %%%%%: 6911-block 72
        -: 6912:         }
        -: 6913:
    #####: 6914:         case 0x21: // Comment Extension.
        -: 6915:         {
        -: 6916:            int len;
    #####: 6917:            int ext = stbi__get8(s);
    %%%%%: 6917-block 73
call    0 never executed
    #####: 6918:            if (ext == 0xF9) { // Graphic Control Extension.
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6919:               len = stbi__get8(s);
    %%%%%: 6919-block 75
call    0 never executed
    #####: 6920:               if (len == 4) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6921:                  g->eflags = stbi__get8(s);
    %%%%%: 6921-block 77
call    0 never executed
    #####: 6922:                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.
call    0 never executed
        -: 6923:
        -: 6924:                  // unset old transparent
    #####: 6925:                  if (g->transparent >= 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6926:                     g->pal[g->transparent][3] = 255;
    %%%%%: 6926-block 80
        -: 6927:                  }
    #####: 6928:                  if (g->eflags & 0x01) {
    %%%%%: 6928-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6929:                     g->transparent = stbi__get8(s);
    %%%%%: 6929-block 82
call    0 never executed
    #####: 6930:                     if (g->transparent >= 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6931:                        g->pal[g->transparent][3] = 0;
    %%%%%: 6931-block 84
        -: 6932:                     }
        -: 6933:                  } else {
        -: 6934:                     // don't need transparent
    #####: 6935:                     stbi__skip(s, 1);
    %%%%%: 6935-block 85
call    0 never executed
    #####: 6936:                     g->transparent = -1;
        -: 6937:                  }
        -: 6938:               } else {
    #####: 6939:                  stbi__skip(s, len);
    %%%%%: 6939-block 87
call    0 never executed
    #####: 6940:                  break;
        -: 6941:               }
        -: 6942:            }
    #####: 6943:            while ((len = stbi__get8(s)) != 0) {
    %%%%%: 6943-block 88
    %%%%%: 6943-block 90
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 6944:               stbi__skip(s, len);
    %%%%%: 6944-block 89
call    0 never executed
        -: 6945:            }
    #####: 6946:            break;
    %%%%%: 6946-block 92
        -: 6947:         }
        -: 6948:
    #####: 6949:         case 0x3B: // gif stream termination code
    #####: 6950:            return (stbi_uc *) s; // using '1' causes warning on some compilers
    %%%%%: 6950-block 93
        -: 6951:
    #####: 6952:         default:
    #####: 6953:            return stbi__errpuc("unknown code", "Corrupt GIF");
    %%%%%: 6953-block 94
call    0 never executed
        -: 6954:      }
    #####: 6955:   }
    %%%%%: 6955-block 97
        -: 6956:}
        -: 6957:
function _ZL28stbi__load_gif_main_outofmemP9stbi__gifPhPPi called 0 returned 0% blocks executed 0%
    #####: 6958:static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
        -: 6959:{
    #####: 6960:   STBI_FREE(g->out);
    #####: 6961:   STBI_FREE(g->history);
    #####: 6962:   STBI_FREE(g->background);
        -: 6963:
    #####: 6964:   if (out) STBI_FREE(out);
    %%%%%: 6964-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6964-block 3
    #####: 6965:   if (delays && *delays) STBI_FREE(*delays);
    %%%%%: 6965-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6965-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6965-block 6
    #####: 6966:   return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 6966-block 7
call    0 never executed
        -: 6967:}
        -: 6968:
function _ZL19stbi__load_gif_mainP13stbi__contextPPiS1_S1_S1_S1_i called 0 returned 0% blocks executed 0%
    #####: 6969:static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
        -: 6970:{
    #####: 6971:   if (stbi__gif_test(s)) {
    %%%%%: 6971-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6972:      int layers = 0;
    #####: 6973:      stbi_uc *u = 0;
    #####: 6974:      stbi_uc *out = 0;
    #####: 6975:      stbi_uc *two_back = 0;
        -: 6976:      stbi__gif g;
        -: 6977:      int stride;
    #####: 6978:      int out_size = 0;
    #####: 6979:      int delays_size = 0;
        -: 6980:
        -: 6981:      STBI_NOTUSED(out_size);
        -: 6982:      STBI_NOTUSED(delays_size);
        -: 6983:
    #####: 6984:      memset(&g, 0, sizeof(g));
    #####: 6985:      if (delays) {
    %%%%%: 6985-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6986:         *delays = 0;
    %%%%%: 6986-block 5
        -: 6987:      }
        -: 6988:
        -: 6989:      do {
    #####: 6990:         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
    %%%%%: 6990-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6991:         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
    %%%%%: 6991-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6991-block 8
        -: 6992:
    #####: 6993:         if (u) {
    %%%%%: 6993-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6994:            *x = g.w;
    #####: 6995:            *y = g.h;
    #####: 6996:            ++layers;
    #####: 6997:            stride = g.w * g.h * 4;
        -: 6998:
    #####: 6999:            if (out) {
    %%%%%: 6999-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7000:               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
    #####: 7001:               if (!tmp)
    %%%%%: 7001-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7002:                  return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 7002-block 12
call    0 never executed
        -: 7003:               else {
    #####: 7004:                   out = (stbi_uc*) tmp;
    #####: 7005:                   out_size = layers * stride;
        -: 7006:               }
        -: 7007:
    #####: 7008:               if (delays) {
    %%%%%: 7008-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7009:                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
    #####: 7010:                  if (!new_delays)
    %%%%%: 7010-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7011:                     return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 7011-block 15
call    0 never executed
    #####: 7012:                  *delays = new_delays;
    #####: 7013:                  delays_size = layers * sizeof(int);
    %%%%%: 7013-block 16
        -: 7014:               }
        -: 7015:            } else {
    #####: 7016:               out = (stbi_uc*)stbi__malloc( layers * stride );
    %%%%%: 7016-block 17
call    0 never executed
    #####: 7017:               if (!out)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7018:                  return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 7018-block 19
call    0 never executed
    #####: 7019:               out_size = layers * stride;
    #####: 7020:               if (delays) {
    %%%%%: 7020-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7021:                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
    %%%%%: 7021-block 21
call    0 never executed
    #####: 7022:                  if (!*delays)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7023:                     return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 7023-block 23
call    0 never executed
    #####: 7024:                  delays_size = layers * sizeof(int);
    %%%%%: 7024-block 24
        -: 7025:               }
        -: 7026:            }
    #####: 7027:            memcpy( out + ((layers - 1) * stride), u, stride );
    #####: 7028:            if (layers >= 2) {
    %%%%%: 7028-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7029:               two_back = out - 2 * stride;
    %%%%%: 7029-block 26
        -: 7030:            }
        -: 7031:
    #####: 7032:            if (delays) {
    %%%%%: 7032-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7033:               (*delays)[layers - 1U] = g.delay;
    %%%%%: 7033-block 28
        -: 7034:            }
        -: 7035:         }
    #####: 7036:      } while (u != 0);
    %%%%%: 7036-block 29
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7037:
        -: 7038:      // free temp buffer;
    #####: 7039:      STBI_FREE(g.out);
    #####: 7040:      STBI_FREE(g.history);
    #####: 7041:      STBI_FREE(g.background);
        -: 7042:
        -: 7043:      // do the final conversion after loading everything;
    #####: 7044:      if (req_comp && req_comp != 4)
    %%%%%: 7044-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7044-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7045:         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);
    %%%%%: 7045-block 32
call    0 never executed
        -: 7046:
    #####: 7047:      *z = layers;
    #####: 7048:      return out;
    %%%%%: 7048-block 33
        -: 7049:   } else {
    #####: 7050:      return stbi__errpuc("not GIF", "Image was not as a gif type.");
    %%%%%: 7050-block 35
call    0 never executed
        -: 7051:   }
        -: 7052:}
        -: 7053:
function _ZL14stbi__gif_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 7054:static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 7055:{
    #####: 7056:   stbi_uc *u = 0;
        -: 7057:   stbi__gif g;
    #####: 7058:   memset(&g, 0, sizeof(g));
        -: 7059:   STBI_NOTUSED(ri);
        -: 7060:
    #####: 7061:   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
    %%%%%: 7061-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7062:   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
    %%%%%: 7062-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7062-block 4
    #####: 7063:   if (u) {
    %%%%%: 7063-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7064:      *x = g.w;
    #####: 7065:      *y = g.h;
        -: 7066:
        -: 7067:      // moved conversion to after successful load so that the same
        -: 7068:      // can be done for multiple frames.
    #####: 7069:      if (req_comp && req_comp != 4)
    %%%%%: 7069-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7069-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7070:         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
    %%%%%: 7070-block 8
call    0 never executed
    #####: 7071:   } else if (g.out) {
    %%%%%: 7071-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7072:      // if there was an error and we allocated an image buffer, free it!
    #####: 7073:      STBI_FREE(g.out);
    %%%%%: 7073-block 10
        -: 7074:   }
        -: 7075:
        -: 7076:   // free buffers needed for multiple frame loading;
    #####: 7077:   STBI_FREE(g.history);
    #####: 7078:   STBI_FREE(g.background);
        -: 7079:
    #####: 7080:   return u;
    %%%%%: 7080-block 11
    %%%%%: 7080-block 12
        -: 7081:}
        -: 7082:
function _ZL14stbi__gif_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7083:static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7084:{
    #####: 7085:   return stbi__gif_info_raw(s,x,y,comp);
    %%%%%: 7085-block 2
call    0 never executed
        -: 7086:}
        -: 7087:#endif
        -: 7088:
        -: 7089:// *************************************************************************************************
        -: 7090:// Radiance RGBE HDR loader
        -: 7091:// originally by Nicolas Schulz
        -: 7092:#ifndef STBI_NO_HDR
function _ZL19stbi__hdr_test_coreP13stbi__contextPKc called 0 returned 0% blocks executed 0%
    #####: 7093:static int stbi__hdr_test_core(stbi__context *s, const char *signature)
        -: 7094:{
        -: 7095:   int i;
    #####: 7096:   for (i=0; signature[i]; ++i)
    %%%%%: 7096-block 2
    %%%%%: 7096-block 6
    %%%%%: 7096-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7097:      if (stbi__get8(s) != signature[i])
    %%%%%: 7097-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7098:          return 0;
    %%%%%: 7098-block 5
    #####: 7099:   stbi__rewind(s);
    %%%%%: 7099-block 8
call    0 never executed
    #####: 7100:   return 1;
        -: 7101:}
        -: 7102:
function _ZL14stbi__hdr_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7103:static int stbi__hdr_test(stbi__context* s)
        -: 7104:{
    #####: 7105:   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
    %%%%%: 7105-block 2
call    0 never executed
    #####: 7106:   stbi__rewind(s);
call    0 never executed
    #####: 7107:   if(!r) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7108:       r = stbi__hdr_test_core(s, "#?RGBE\n");
    %%%%%: 7108-block 5
call    0 never executed
    #####: 7109:       stbi__rewind(s);
call    0 never executed
        -: 7110:   }
    #####: 7111:   return r;
    %%%%%: 7111-block 7
        -: 7112:}
        -: 7113:
        -: 7114:#define STBI__HDR_BUFLEN  1024
function _ZL18stbi__hdr_gettokenP13stbi__contextPc called 0 returned 0% blocks executed 0%
    #####: 7115:static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
        -: 7116:{
    #####: 7117:   int len=0;
    #####: 7118:   char c = '\0';
        -: 7119:
    #####: 7120:   c = (char) stbi__get8(z);
    %%%%%: 7120-block 2
call    0 never executed
        -: 7121:
    #####: 7122:   while (!stbi__at_eof(z) && c != '\n') {
    %%%%%: 7122-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7122-block 18
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7122-block 19
    %%%%%: 7122-block 20
    %%%%%: 7122-block 21
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 7123:      buffer[len++] = c;
    #####: 7124:      if (len == STBI__HDR_BUFLEN-1) {
    %%%%%: 7124-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7125:         // flush to end of line
    #####: 7126:         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
    %%%%%: 7126-block 5
    %%%%%: 7126-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7126-block 8
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7126-block 10
    %%%%%: 7126-block 11
    %%%%%: 7126-block 12
branch  6 never executed
branch  7 never executed (fallthrough)
        -: 7127:            ;
    #####: 7128:         break;
    %%%%%: 7128-block 13
        -: 7129:      }
    #####: 7130:      c = (char) stbi__get8(z);
    %%%%%: 7130-block 14
call    0 never executed
        -: 7131:   }
        -: 7132:
    #####: 7133:   buffer[len] = 0;
    #####: 7134:   return buffer;
    %%%%%: 7134-block 22
        -: 7135:}
        -: 7136:
function _ZL17stbi__hdr_convertPfPhi called 0 returned 0% blocks executed 0%
    #####: 7137:static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
        -: 7138:{
    #####: 7139:   if ( input[3] != 0 ) {
    %%%%%: 7139-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7140:      float f1;
        -: 7141:      // Exponent
    #####: 7142:      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
    %%%%%: 7142-block 3
call    0 never executed
    #####: 7143:      if (req_comp <= 2)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7144:         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
    %%%%%: 7144-block 5
        -: 7145:      else {
    #####: 7146:         output[0] = input[0] * f1;
    #####: 7147:         output[1] = input[1] * f1;
    #####: 7148:         output[2] = input[2] * f1;
    %%%%%: 7148-block 6
        -: 7149:      }
    #####: 7150:      if (req_comp == 2) output[1] = 1;
    %%%%%: 7150-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7150-block 8
    #####: 7151:      if (req_comp == 4) output[3] = 1;
    %%%%%: 7151-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7151-block 10
        -: 7152:   } else {
    #####: 7153:      switch (req_comp) {
    %%%%%: 7153-block 11
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 7154:         case 4: output[3] = 1; /* fallthrough */
    %%%%%: 7154-block 12
    #####: 7155:         case 3: output[0] = output[1] = output[2] = 0;
    #####: 7156:                 break;
    %%%%%: 7156-block 13
    #####: 7157:         case 2: output[1] = 1; /* fallthrough */
    %%%%%: 7157-block 14
    #####: 7158:         case 1: output[0] = 0;
    #####: 7159:                 break;
    %%%%%: 7159-block 15
        -: 7160:      }
        -: 7161:   }
    #####: 7162:}
        -: 7163:
function _ZL14stbi__hdr_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 7164:static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 7165:{
        -: 7166:   char buffer[STBI__HDR_BUFLEN];
        -: 7167:   char *token;
    #####: 7168:   int valid = 0;
        -: 7169:   int width, height;
        -: 7170:   stbi_uc *scanline;
        -: 7171:   float *hdr_data;
        -: 7172:   int len;
        -: 7173:   unsigned char count, value;
        -: 7174:   int i, j, k, c1,c2, z;
        -: 7175:   const char *headerToken;
        -: 7176:   STBI_NOTUSED(ri);
        -: 7177:
        -: 7178:   // Check identifier
    #####: 7179:   headerToken = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7179-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7180:   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
    %%%%%: 7180-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7180-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7181:      return stbi__errpf("not HDR", "Corrupt HDR image");
    %%%%%: 7181-block 5
call    0 never executed
        -: 7182:
        -: 7183:   // Parse header
        -: 7184:   for(;;) {
    #####: 7185:      token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7185-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7185-block 13
    #####: 7186:      if (token[0] == 0) break;
    %%%%%: 7186-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7186-block 10
    #####: 7187:      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
    %%%%%: 7187-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7187-block 12
        -: 7188:   }
        -: 7189:
    #####: 7190:   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");
    %%%%%: 7190-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7190-block 15
call    2 never executed
        -: 7191:
        -: 7192:   // Parse width and height
        -: 7193:   // can't use sscanf() if we're not using stdio!
    #####: 7194:   token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7194-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7195:   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
    %%%%%: 7195-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7195-block 19
call    2 never executed
    #####: 7196:   token += 3;
    #####: 7197:   height = (int) strtol(token, &token, 10);
    %%%%%: 7197-block 21
call    0 never executed
    #####: 7198:   while (*token == ' ') ++token;
    %%%%%: 7198-block 23
    %%%%%: 7198-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7199:   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
    %%%%%: 7199-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7199-block 26
call    2 never executed
    #####: 7200:   token += 3;
    #####: 7201:   width = (int) strtol(token, NULL, 10);
    %%%%%: 7201-block 28
call    0 never executed
        -: 7202:
    #####: 7203:   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7203-block 30
call    2 never executed
    #####: 7204:   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
    %%%%%: 7204-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7204-block 33
call    2 never executed
        -: 7205:
    #####: 7206:   *x = width;
    #####: 7207:   *y = height;
        -: 7208:
    #####: 7209:   if (comp) *comp = 3;
    %%%%%: 7209-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7209-block 36
    #####: 7210:   if (req_comp == 0) req_comp = 3;
    %%%%%: 7210-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7210-block 38
        -: 7211:
    #####: 7212:   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
    %%%%%: 7212-block 39
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7213:      return stbi__errpf("too large", "HDR image is too large");
    %%%%%: 7213-block 41
call    0 never executed
        -: 7214:
        -: 7215:   // Read data
    #####: 7216:   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
    %%%%%: 7216-block 43
call    0 never executed
    #####: 7217:   if (!hdr_data)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7218:      return stbi__errpf("outofmem", "Out of memory");
    %%%%%: 7218-block 45
call    0 never executed
        -: 7219:
        -: 7220:   // Load image data
        -: 7221:   // image data is stored as some number of sca
    #####: 7222:   if ( width < 8 || width >= 32768) {
    %%%%%: 7222-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7222-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7223:      // Read flat data
    #####: 7224:      for (j=0; j < height; ++j) {
    %%%%%: 7224-block 49
    %%%%%: 7224-block 56
    %%%%%: 7224-block 57
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7225:         for (i=0; i < width; ++i) {
    %%%%%: 7225-block 50
    %%%%%: 7225-block 55
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7226:            stbi_uc rgbe[4];
    #####: 7227:           main_decode_loop:
    %%%%%: 7227-block 51
    #####: 7228:            stbi__getn(s, rgbe, 4);
    %%%%%: 7228-block 52
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7229:            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
    %%%%%: 7229-block 53
call    0 never executed
        -: 7230:         }
        -: 7231:      }
    #####: 7232:   } else {
    %%%%%: 7232-block 58
        -: 7233:      // Read RLE-encoded data
    #####: 7234:      scanline = NULL;
        -: 7235:
    #####: 7236:      for (j = 0; j < height; ++j) {
    %%%%%: 7236-block 59
    %%%%%: 7236-block 105
    %%%%%: 7236-block 106
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7237:         c1 = stbi__get8(s);
    %%%%%: 7237-block 60
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7238:         c2 = stbi__get8(s);
    %%%%%: 7238-block 61
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7239:         len = stbi__get8(s);
    %%%%%: 7239-block 62
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7240:         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
    %%%%%: 7240-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7240-block 64
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7240-block 65
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7241:            // not run-length encoded, so we have to actually use THIS data as a decoded
        -: 7242:            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
        -: 7243:            stbi_uc rgbe[4];
    #####: 7244:            rgbe[0] = (stbi_uc) c1;
    #####: 7245:            rgbe[1] = (stbi_uc) c2;
    #####: 7246:            rgbe[2] = (stbi_uc) len;
    #####: 7247:            rgbe[3] = (stbi_uc) stbi__get8(s);
    %%%%%: 7247-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7248:            stbi__hdr_convert(hdr_data, rgbe, req_comp);
    %%%%%: 7248-block 67
call    0 never executed
    #####: 7249:            i = 1;
    #####: 7250:            j = 0;
    #####: 7251:            STBI_FREE(scanline);
    #####: 7252:            goto main_decode_loop; // yes, this makes no sense
        -: 7253:         }
    #####: 7254:         len <<= 8;
    #####: 7255:         len |= stbi__get8(s);
    %%%%%: 7255-block 69
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7256:         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
    %%%%%: 7256-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7256-block 71
call    2 never executed
    #####: 7257:         if (scanline == NULL) {
    %%%%%: 7257-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7258:            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
    %%%%%: 7258-block 74
call    0 never executed
    #####: 7259:            if (!scanline) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7260:               STBI_FREE(hdr_data);
    #####: 7261:               return stbi__errpf("outofmem", "Out of memory");
    %%%%%: 7261-block 76
call    0 never executed
        -: 7262:            }
        -: 7263:         }
        -: 7264:
    #####: 7265:         for (k = 0; k < 4; ++k) {
    %%%%%: 7265-block 78
    %%%%%: 7265-block 99
    %%%%%: 7265-block 100
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7266:            int nleft;
    #####: 7267:            i = 0;
    #####: 7268:            while ((nleft = width - i) > 0) {
    %%%%%: 7268-block 79
    %%%%%: 7268-block 98
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7269:               count = stbi__get8(s);
    %%%%%: 7269-block 80
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7270:               if (count > 128) {
    %%%%%: 7270-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7271:                  // Run
    #####: 7272:                  value = stbi__get8(s);
    %%%%%: 7272-block 82
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7273:                  count -= 128;
    #####: 7274:                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
    %%%%%: 7274-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7274-block 84
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7274-block 85
call    4 never executed
    #####: 7275:                  for (z = 0; z < count; ++z)
    %%%%%: 7275-block 87
    %%%%%: 7275-block 89
branch  0 never executed
branch  1 never executed
    #####: 7276:                     scanline[i++ * 4 + k] = value;
    %%%%%: 7276-block 88
        -: 7277:               } else {
        -: 7278:                  // Dump
    #####: 7279:                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
    %%%%%: 7279-block 90
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7279-block 91
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7279-block 92
call    4 never executed
    #####: 7280:                  for (z = 0; z < count; ++z)
    %%%%%: 7280-block 94
    %%%%%: 7280-block 97
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7281:                     scanline[i++ * 4 + k] = stbi__get8(s);
    %%%%%: 7281-block 95
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7281-block 96
        -: 7282:               }
        -: 7283:            }
        -: 7284:         }
    #####: 7285:         for (i=0; i < width; ++i)
    %%%%%: 7285-block 101
    %%%%%: 7285-block 104
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7286:            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
    %%%%%: 7286-block 102
call    0 never executed
        -: 7287:      }
    #####: 7288:      if (scanline)
    %%%%%: 7288-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7289:         STBI_FREE(scanline);
    %%%%%: 7289-block 108
        -: 7290:   }
        -: 7291:
    #####: 7292:   return hdr_data;
    %%%%%: 7292-block 109
        -: 7293:}
        -: 7294:
function _ZL14stbi__hdr_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7295:static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7296:{
        -: 7297:   char buffer[STBI__HDR_BUFLEN];
        -: 7298:   char *token;
    #####: 7299:   int valid = 0;
        -: 7300:   int dummy;
        -: 7301:
    #####: 7302:   if (!x) x = &dummy;
    %%%%%: 7302-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7302-block 3
    #####: 7303:   if (!y) y = &dummy;
    %%%%%: 7303-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7303-block 5
    #####: 7304:   if (!comp) comp = &dummy;
    %%%%%: 7304-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7304-block 7
        -: 7305:
    #####: 7306:   if (stbi__hdr_test(s) == 0) {
    %%%%%: 7306-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7306-block 9
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7307:       stbi__rewind( s );
    %%%%%: 7307-block 10
call    0 never executed
    #####: 7308:       return 0;
        -: 7309:   }
        -: 7310:
        -: 7311:   for(;;) {
    #####: 7312:      token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7312-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7312-block 17
    #####: 7313:      if (token[0] == 0) break;
    %%%%%: 7313-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7313-block 14
    #####: 7314:      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
    %%%%%: 7314-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7314-block 16
        -: 7315:   }
        -: 7316:
    #####: 7317:   if (!valid) {
    %%%%%: 7317-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7318:       stbi__rewind( s );
    %%%%%: 7318-block 19
call    0 never executed
    #####: 7319:       return 0;
        -: 7320:   }
    #####: 7321:   token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7321-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7322:   if (strncmp(token, "-Y ", 3)) {
    %%%%%: 7322-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7323:       stbi__rewind( s );
    %%%%%: 7323-block 23
call    0 never executed
    #####: 7324:       return 0;
        -: 7325:   }
    #####: 7326:   token += 3;
    #####: 7327:   *y = (int) strtol(token, &token, 10);
    %%%%%: 7327-block 25
call    0 never executed
    #####: 7328:   while (*token == ' ') ++token;
    %%%%%: 7328-block 27
    %%%%%: 7328-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7329:   if (strncmp(token, "+X ", 3)) {
    %%%%%: 7329-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7330:       stbi__rewind( s );
    %%%%%: 7330-block 30
call    0 never executed
    #####: 7331:       return 0;
        -: 7332:   }
    #####: 7333:   token += 3;
    #####: 7334:   *x = (int) strtol(token, NULL, 10);
    %%%%%: 7334-block 32
call    0 never executed
    #####: 7335:   *comp = 3;
    #####: 7336:   return 1;
        -: 7337:}
        -: 7338:#endif // STBI_NO_HDR
        -: 7339:
        -: 7340:#ifndef STBI_NO_BMP
function _ZL14stbi__bmp_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7341:static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7342:{
        -: 7343:   void *p;
        -: 7344:   stbi__bmp_data info;
        -: 7345:
    #####: 7346:   info.all_a = 255;
    #####: 7347:   p = stbi__bmp_parse_header(s, &info);
    %%%%%: 7347-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7348:   if (p == NULL) {
    %%%%%: 7348-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7349:      stbi__rewind( s );
    %%%%%: 7349-block 4
call    0 never executed
    #####: 7350:      return 0;
        -: 7351:   }
    #####: 7352:   if (x) *x = s->img_x;
    %%%%%: 7352-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7352-block 7
    #####: 7353:   if (y) *y = s->img_y;
    %%%%%: 7353-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7353-block 9
    #####: 7354:   if (comp) {
    %%%%%: 7354-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7355:      if (info.bpp == 24 && info.ma == 0xff000000)
    %%%%%: 7355-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7355-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7356:         *comp = 3;
    %%%%%: 7356-block 13
        -: 7357:      else
    #####: 7358:         *comp = info.ma ? 4 : 3;
    %%%%%: 7358-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7358-block 15
    %%%%%: 7358-block 16
    %%%%%: 7358-block 17
        -: 7359:   }
    #####: 7360:   return 1;
    %%%%%: 7360-block 19
        -: 7361:}
        -: 7362:#endif
        -: 7363:
        -: 7364:#ifndef STBI_NO_PSD
function _ZL14stbi__psd_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7365:static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7366:{
        -: 7367:   int channelCount, dummy, depth;
    #####: 7368:   if (!x) x = &dummy;
    %%%%%: 7368-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7368-block 3
    #####: 7369:   if (!y) y = &dummy;
    %%%%%: 7369-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7369-block 5
    #####: 7370:   if (!comp) comp = &dummy;
    %%%%%: 7370-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7370-block 7
    #####: 7371:   if (stbi__get32be(s) != 0x38425053) {
    %%%%%: 7371-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7371-block 9
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7372:       stbi__rewind( s );
    %%%%%: 7372-block 10
call    0 never executed
    #####: 7373:       return 0;
        -: 7374:   }
    #####: 7375:   if (stbi__get16be(s) != 1) {
    %%%%%: 7375-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7375-block 13
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7376:       stbi__rewind( s );
    %%%%%: 7376-block 14
call    0 never executed
    #####: 7377:       return 0;
        -: 7378:   }
    #####: 7379:   stbi__skip(s, 6);
    %%%%%: 7379-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7380:   channelCount = stbi__get16be(s);
    %%%%%: 7380-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7381:   if (channelCount < 0 || channelCount > 16) {
    %%%%%: 7381-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7381-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7382:       stbi__rewind( s );
    %%%%%: 7382-block 20
call    0 never executed
    #####: 7383:       return 0;
        -: 7384:   }
    #####: 7385:   *y = stbi__get32be(s);
    %%%%%: 7385-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7386:   *x = stbi__get32be(s);
    %%%%%: 7386-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7387:   depth = stbi__get16be(s);
    %%%%%: 7387-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7388:   if (depth != 8 && depth != 16) {
    %%%%%: 7388-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7388-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7389:       stbi__rewind( s );
    %%%%%: 7389-block 27
call    0 never executed
    #####: 7390:       return 0;
        -: 7391:   }
    #####: 7392:   if (stbi__get16be(s) != 3) {
    %%%%%: 7392-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7392-block 30
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7393:       stbi__rewind( s );
    %%%%%: 7393-block 31
call    0 never executed
    #####: 7394:       return 0;
        -: 7395:   }
    #####: 7396:   *comp = 4;
    #####: 7397:   return 1;
    %%%%%: 7397-block 33
        -: 7398:}
        -: 7399:
function _ZL14stbi__psd_is16P13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7400:static int stbi__psd_is16(stbi__context *s)
        -: 7401:{
        -: 7402:   int channelCount, depth;
    #####: 7403:   if (stbi__get32be(s) != 0x38425053) {
    %%%%%: 7403-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7404:       stbi__rewind( s );
    %%%%%: 7404-block 4
call    0 never executed
    #####: 7405:       return 0;
        -: 7406:   }
    #####: 7407:   if (stbi__get16be(s) != 1) {
    %%%%%: 7407-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7408:       stbi__rewind( s );
    %%%%%: 7408-block 8
call    0 never executed
    #####: 7409:       return 0;
        -: 7410:   }
    #####: 7411:   stbi__skip(s, 6);
    %%%%%: 7411-block 10
call    0 never executed
    #####: 7412:   channelCount = stbi__get16be(s);
call    0 never executed
    #####: 7413:   if (channelCount < 0 || channelCount > 16) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7413-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7414:       stbi__rewind( s );
    %%%%%: 7414-block 14
call    0 never executed
    #####: 7415:       return 0;
        -: 7416:   }
        -: 7417:   STBI_NOTUSED(stbi__get32be(s));
        -: 7418:   STBI_NOTUSED(stbi__get32be(s));
    #####: 7419:   depth = stbi__get16be(s);
    %%%%%: 7419-block 16
call    0 never executed
    #####: 7420:   if (depth != 16) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7421:       stbi__rewind( s );
    %%%%%: 7421-block 18
call    0 never executed
    #####: 7422:       return 0;
        -: 7423:   }
    #####: 7424:   return 1;
    %%%%%: 7424-block 20
        -: 7425:}
        -: 7426:#endif
        -: 7427:
        -: 7428:#ifndef STBI_NO_PIC
function _ZL14stbi__pic_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7429:static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7430:{
    #####: 7431:   int act_comp=0,num_packets=0,chained,dummy;
        -: 7432:   stbi__pic_packet packets[10];
        -: 7433:
    #####: 7434:   if (!x) x = &dummy;
    %%%%%: 7434-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7434-block 3
    #####: 7435:   if (!y) y = &dummy;
    %%%%%: 7435-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7435-block 5
    #####: 7436:   if (!comp) comp = &dummy;
    %%%%%: 7436-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7436-block 7
        -: 7437:
    #####: 7438:   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
    %%%%%: 7438-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7438-block 9
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7439:      stbi__rewind(s);
    %%%%%: 7439-block 10
call    0 never executed
    #####: 7440:      return 0;
        -: 7441:   }
        -: 7442:
    #####: 7443:   stbi__skip(s, 88);
    %%%%%: 7443-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7444:
    #####: 7445:   *x = stbi__get16be(s);
    %%%%%: 7445-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7446:   *y = stbi__get16be(s);
    %%%%%: 7446-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7447:   if (stbi__at_eof(s)) {
    %%%%%: 7447-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7447-block 16
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7448:      stbi__rewind( s);
    %%%%%: 7448-block 17
call    0 never executed
    #####: 7449:      return 0;
        -: 7450:   }
    #####: 7451:   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
    %%%%%: 7451-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7451-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7452:      stbi__rewind( s );
    %%%%%: 7452-block 21
call    0 never executed
    #####: 7453:      return 0;
        -: 7454:   }
        -: 7455:
    #####: 7456:   stbi__skip(s, 8);
    %%%%%: 7456-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7457:
        -: 7458:   do {
        -: 7459:      stbi__pic_packet *packet;
        -: 7460:
    #####: 7461:      if (num_packets==sizeof(packets)/sizeof(packets[0]))
    %%%%%: 7461-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7462:         return 0;
    %%%%%: 7462-block 25
        -: 7463:
    #####: 7464:      packet = &packets[num_packets++];
    #####: 7465:      chained = stbi__get8(s);
    %%%%%: 7465-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7466:      packet->size    = stbi__get8(s);
    %%%%%: 7466-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7467:      packet->type    = stbi__get8(s);
    %%%%%: 7467-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7468:      packet->channel = stbi__get8(s);
    %%%%%: 7468-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7469:      act_comp |= packet->channel;
        -: 7470:
    #####: 7471:      if (stbi__at_eof(s)) {
    %%%%%: 7471-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7471-block 31
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7472:          stbi__rewind( s );
    %%%%%: 7472-block 32
call    0 never executed
    #####: 7473:          return 0;
        -: 7474:      }
    #####: 7475:      if (packet->size != 8) {
    %%%%%: 7475-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7476:          stbi__rewind( s );
    %%%%%: 7476-block 35
call    0 never executed
    #####: 7477:          return 0;
        -: 7478:      }
    #####: 7479:   } while (chained);
    %%%%%: 7479-block 37
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7480:
    #####: 7481:   *comp = (act_comp & 0x10 ? 4 : 3);
    %%%%%: 7481-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7481-block 39
    %%%%%: 7481-block 40
        -: 7482:
    #####: 7483:   return 1;
    %%%%%: 7483-block 41
        -: 7484:}
        -: 7485:#endif
        -: 7486:
        -: 7487:// *************************************************************************************************
        -: 7488:// Portable Gray Map and Portable Pixel Map loader
        -: 7489:// by Ken Miller
        -: 7490://
        -: 7491:// PGM: http://netpbm.sourceforge.net/doc/pgm.html
        -: 7492:// PPM: http://netpbm.sourceforge.net/doc/ppm.html
        -: 7493://
        -: 7494:// Known limitations:
        -: 7495://    Does not support comments in the header section
        -: 7496://    Does not support ASCII image data (formats P2 and P3)
        -: 7497:
        -: 7498:#ifndef STBI_NO_PNM
        -: 7499:
function _ZL14stbi__pnm_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7500:static int      stbi__pnm_test(stbi__context *s)
        -: 7501:{
        -: 7502:   char p, t;
    #####: 7503:   p = (char) stbi__get8(s);
    %%%%%: 7503-block 2
call    0 never executed
    #####: 7504:   t = (char) stbi__get8(s);
call    0 never executed
    #####: 7505:   if (p != 'P' || (t != '5' && t != '6')) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7505-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7505-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7506:       stbi__rewind( s );
    %%%%%: 7506-block 7
call    0 never executed
    #####: 7507:       return 0;
        -: 7508:   }
    #####: 7509:   return 1;
    %%%%%: 7509-block 9
        -: 7510:}
        -: 7511:
function _ZL14stbi__pnm_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 7512:static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 7513:{
        -: 7514:   stbi_uc *out;
        -: 7515:   STBI_NOTUSED(ri);
        -: 7516:
    #####: 7517:   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
    %%%%%: 7517-block 2
call    0 never executed
    #####: 7518:   if (ri->bits_per_channel == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7519:      return 0;
    %%%%%: 7519-block 4
        -: 7520:
    #####: 7521:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 7521-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7521-block 6
call    2 never executed
    #####: 7522:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 7522-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7522-block 9
call    2 never executed
        -: 7523:
    #####: 7524:   *x = s->img_x;
    #####: 7525:   *y = s->img_y;
    #####: 7526:   if (comp) *comp = s->img_n;
    %%%%%: 7526-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7526-block 12
        -: 7527:
    #####: 7528:   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
    %%%%%: 7528-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7529:      return stbi__errpuc("too large", "PNM too large");
    %%%%%: 7529-block 15
call    0 never executed
        -: 7530:
    #####: 7531:   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
    %%%%%: 7531-block 17
call    0 never executed
    #####: 7532:   if (!out) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7532-block 19
call    2 never executed
    #####: 7533:   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {
    %%%%%: 7533-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7534:      STBI_FREE(out);
    #####: 7535:      return stbi__errpuc("bad PNM", "PNM file truncated");
    %%%%%: 7535-block 23
call    0 never executed
        -: 7536:   }
        -: 7537:
    #####: 7538:   if (req_comp && req_comp != s->img_n) {
    %%%%%: 7538-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7538-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7539:      if (ri->bits_per_channel == 16) {
    %%%%%: 7539-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7540:         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);
    %%%%%: 7540-block 28
call    0 never executed
        -: 7541:      } else {
    #####: 7542:         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
    %%%%%: 7542-block 29
call    0 never executed
        -: 7543:      }
    #####: 7544:      if (out == NULL) return out; // stbi__convert_format frees input on failure
    %%%%%: 7544-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7544-block 31
        -: 7545:   }
    #####: 7546:   return out;
    %%%%%: 7546-block 32
        -: 7547:}
        -: 7548:
function _ZL17stbi__pnm_isspacec called 0 returned 0% blocks executed 0%
    #####: 7549:static int      stbi__pnm_isspace(char c)
        -: 7550:{
    #####: 7551:   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
    %%%%%: 7551-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7551-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7551-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7551-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 7551-block 6
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 7551-block 7
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 7551-block 8
    %%%%%: 7551-block 9
    %%%%%: 7551-block 10
        -: 7552:}
        -: 7553:
function _ZL25stbi__pnm_skip_whitespaceP13stbi__contextPc called 0 returned 0% blocks executed 0%
    #####: 7554:static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
        -: 7555:{
        -: 7556:   for (;;) {
    #####: 7557:      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
    %%%%%: 7557-block 2
    %%%%%: 7557-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7557-block 7
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7557-block 9
    %%%%%: 7557-block 10
    %%%%%: 7557-block 11
branch  6 never executed
branch  7 never executed (fallthrough)
    %%%%%: 7557-block 29
    #####: 7558:         *c = (char) stbi__get8(s);
    %%%%%: 7558-block 3
call    0 never executed
        -: 7559:
    #####: 7560:      if (stbi__at_eof(s) || *c != '#')
    %%%%%: 7560-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7560-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7560-block 15
    %%%%%: 7560-block 16
    %%%%%: 7560-block 17
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 7561:         break;
    %%%%%: 7561-block 18
        -: 7562:
    #####: 7563:      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
    %%%%%: 7563-block 19
    %%%%%: 7563-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7563-block 24
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7563-block 25
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 7563-block 26
    %%%%%: 7563-block 27
    %%%%%: 7563-block 28
branch  7 never executed
branch  8 never executed (fallthrough)
    #####: 7564:         *c = (char) stbi__get8(s);
    %%%%%: 7564-block 20
call    0 never executed
        -: 7565:   }
    #####: 7566:}
        -: 7567:
function _ZL17stbi__pnm_isdigitc called 0 returned 0% blocks executed 0%
    #####: 7568:static int      stbi__pnm_isdigit(char c)
        -: 7569:{
    #####: 7570:   return c >= '0' && c <= '9';
    %%%%%: 7570-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7570-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7570-block 4
    %%%%%: 7570-block 5
    %%%%%: 7570-block 6
        -: 7571:}
        -: 7572:
function _ZL20stbi__pnm_getintegerP13stbi__contextPc called 0 returned 0% blocks executed 0%
    #####: 7573:static int      stbi__pnm_getinteger(stbi__context *s, char *c)
        -: 7574:{
    #####: 7575:   int value = 0;
        -: 7576:
    #####: 7577:   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
    %%%%%: 7577-block 2
    %%%%%: 7577-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7577-block 10
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7577-block 12
    %%%%%: 7577-block 13
    %%%%%: 7577-block 14
branch  6 never executed
branch  7 never executed (fallthrough)
    #####: 7578:      value = value*10 + (*c - '0');
    #####: 7579:      *c = (char) stbi__get8(s);
    %%%%%: 7579-block 3
call    0 never executed
    #####: 7580:      if((value > 214748364) || (value == 214748364 && *c > '7'))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7580-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7580-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7581:          return stbi__err("integer parse overflow", "Parsing an integer in the PPM header overflowed a 32-bit int");
    %%%%%: 7581-block 7
call    0 never executed
        -: 7582:   }
        -: 7583:
    #####: 7584:   return value;
    %%%%%: 7584-block 15
        -: 7585:}
        -: 7586:
function _ZL14stbi__pnm_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7587:static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7588:{
        -: 7589:   int maxv, dummy;
        -: 7590:   char c, p, t;
        -: 7591:
    #####: 7592:   if (!x) x = &dummy;
    %%%%%: 7592-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7592-block 3
    #####: 7593:   if (!y) y = &dummy;
    %%%%%: 7593-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7593-block 5
    #####: 7594:   if (!comp) comp = &dummy;
    %%%%%: 7594-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7594-block 7
        -: 7595:
    #####: 7596:   stbi__rewind(s);
    %%%%%: 7596-block 8
call    0 never executed
        -: 7597:
        -: 7598:   // Get identifier
    #####: 7599:   p = (char) stbi__get8(s);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7600:   t = (char) stbi__get8(s);
    %%%%%: 7600-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7601:   if (p != 'P' || (t != '5' && t != '6')) {
    %%%%%: 7601-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7601-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7601-block 13
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7602:       stbi__rewind(s);
    %%%%%: 7602-block 14
call    0 never executed
    #####: 7603:       return 0;
        -: 7604:   }
        -: 7605:
    #####: 7606:   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm
    %%%%%: 7606-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7606-block 17
    %%%%%: 7606-block 18
        -: 7607:
    #####: 7608:   c = (char) stbi__get8(s);
    %%%%%: 7608-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7609:   stbi__pnm_skip_whitespace(s, &c);
    %%%%%: 7609-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7610:
    #####: 7611:   *x = stbi__pnm_getinteger(s, &c); // read width
    %%%%%: 7611-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7612:   if(*x == 0)
    %%%%%: 7612-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7613:       return stbi__err("invalid width", "PPM image header had zero or overflowing width");
    %%%%%: 7613-block 23
call    0 never executed
    #####: 7614:   stbi__pnm_skip_whitespace(s, &c);
    %%%%%: 7614-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7615:
    #####: 7616:   *y = stbi__pnm_getinteger(s, &c); // read height
    %%%%%: 7616-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7617:   if (*y == 0)
    %%%%%: 7617-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7618:       return stbi__err("invalid width", "PPM image header had zero or overflowing width");
    %%%%%: 7618-block 27
call    0 never executed
    #####: 7619:   stbi__pnm_skip_whitespace(s, &c);
    %%%%%: 7619-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7620:
    #####: 7621:   maxv = stbi__pnm_getinteger(s, &c);  // read max value
    %%%%%: 7621-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7622:   if (maxv > 65535)
    %%%%%: 7622-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7623:      return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
    %%%%%: 7623-block 31
call    0 never executed
    #####: 7624:   else if (maxv > 255)
    %%%%%: 7624-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7625:      return 16;
    %%%%%: 7625-block 33
        -: 7626:   else
    #####: 7627:      return 8;
    %%%%%: 7627-block 34
        -: 7628:}
        -: 7629:
function _ZL14stbi__pnm_is16P13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7630:static int stbi__pnm_is16(stbi__context *s)
        -: 7631:{
    #####: 7632:   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
    %%%%%: 7632-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7633:	   return 1;
    %%%%%: 7633-block 4
    #####: 7634:   return 0;
    %%%%%: 7634-block 5
        -: 7635:}
        -: 7636:#endif
        -: 7637:
function _ZL15stbi__info_mainP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7638:static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
        -: 7639:{
        -: 7640:   #ifndef STBI_NO_JPEG
    #####: 7641:   if (stbi__jpeg_info(s, x, y, comp)) return 1;
    %%%%%: 7641-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7641-block 4
        -: 7642:   #endif
        -: 7643:
        -: 7644:   #ifndef STBI_NO_PNG
    #####: 7645:   if (stbi__png_info(s, x, y, comp))  return 1;
    %%%%%: 7645-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7645-block 7
        -: 7646:   #endif
        -: 7647:
        -: 7648:   #ifndef STBI_NO_GIF
    #####: 7649:   if (stbi__gif_info(s, x, y, comp))  return 1;
    %%%%%: 7649-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7649-block 10
        -: 7650:   #endif
        -: 7651:
        -: 7652:   #ifndef STBI_NO_BMP
    #####: 7653:   if (stbi__bmp_info(s, x, y, comp))  return 1;
    %%%%%: 7653-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7653-block 13
        -: 7654:   #endif
        -: 7655:
        -: 7656:   #ifndef STBI_NO_PSD
    #####: 7657:   if (stbi__psd_info(s, x, y, comp))  return 1;
    %%%%%: 7657-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7657-block 16
        -: 7658:   #endif
        -: 7659:
        -: 7660:   #ifndef STBI_NO_PIC
    #####: 7661:   if (stbi__pic_info(s, x, y, comp))  return 1;
    %%%%%: 7661-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7661-block 19
        -: 7662:   #endif
        -: 7663:
        -: 7664:   #ifndef STBI_NO_PNM
    #####: 7665:   if (stbi__pnm_info(s, x, y, comp))  return 1;
    %%%%%: 7665-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7665-block 22
        -: 7666:   #endif
        -: 7667:
        -: 7668:   #ifndef STBI_NO_HDR
    #####: 7669:   if (stbi__hdr_info(s, x, y, comp))  return 1;
    %%%%%: 7669-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7669-block 25
        -: 7670:   #endif
        -: 7671:
        -: 7672:   // test tga last because it's a crappy test!
        -: 7673:   #ifndef STBI_NO_TGA
    #####: 7674:   if (stbi__tga_info(s, x, y, comp))
    %%%%%: 7674-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7675:       return 1;
    %%%%%: 7675-block 28
        -: 7676:   #endif
    #####: 7677:   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
    %%%%%: 7677-block 29
call    0 never executed
        -: 7678:}
        -: 7679:
function _ZL16stbi__is_16_mainP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7680:static int stbi__is_16_main(stbi__context *s)
        -: 7681:{
        -: 7682:   #ifndef STBI_NO_PNG
    #####: 7683:   if (stbi__png_is16(s))  return 1;
    %%%%%: 7683-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7683-block 4
        -: 7684:   #endif
        -: 7685:
        -: 7686:   #ifndef STBI_NO_PSD
    #####: 7687:   if (stbi__psd_is16(s))  return 1;
    %%%%%: 7687-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7687-block 7
        -: 7688:   #endif
        -: 7689:
        -: 7690:   #ifndef STBI_NO_PNM
    #####: 7691:   if (stbi__pnm_is16(s))  return 1;
    %%%%%: 7691-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7691-block 10
        -: 7692:   #endif
    #####: 7693:   return 0;
    %%%%%: 7693-block 11
        -: 7694:}
        -: 7695:
        -: 7696:#ifndef STBI_NO_STDIO
function stbi_info called 0 returned 0% blocks executed 0%
    #####: 7697:STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
        -: 7698:{
    #####: 7699:    FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 7699-block 2
call    0 never executed
        -: 7700:    int result;
    #####: 7701:    if (!f) return stbi__err("can't fopen", "Unable to open file");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7701-block 4
call    2 never executed
    #####: 7702:    result = stbi_info_from_file(f, x, y, comp);
    %%%%%: 7702-block 5
call    0 never executed
    #####: 7703:    fclose(f);
call    0 never executed
    #####: 7704:    return result;
        -: 7705:}
        -: 7706:
function stbi_info_from_file called 0 returned 0% blocks executed 0%
    #####: 7707:STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
        -: 7708:{
        -: 7709:   int r;
        -: 7710:   stbi__context s;
    #####: 7711:   long pos = ftell(f);
    %%%%%: 7711-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7712:   stbi__start_file(&s, f);
    %%%%%: 7712-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7713:   r = stbi__info_main(&s,x,y,comp);
    %%%%%: 7713-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7714:   fseek(f,pos,SEEK_SET);
    %%%%%: 7714-block 5
call    0 never executed
    #####: 7715:   return r;
    %%%%%: 7715-block 7
        -: 7716:}
        -: 7717:
function stbi_is_16_bit called 0 returned 0% blocks executed 0%
    #####: 7718:STBIDEF int stbi_is_16_bit(char const *filename)
        -: 7719:{
    #####: 7720:    FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 7720-block 2
call    0 never executed
        -: 7721:    int result;
    #####: 7722:    if (!f) return stbi__err("can't fopen", "Unable to open file");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7722-block 4
call    2 never executed
    #####: 7723:    result = stbi_is_16_bit_from_file(f);
    %%%%%: 7723-block 5
call    0 never executed
    #####: 7724:    fclose(f);
call    0 never executed
    #####: 7725:    return result;
        -: 7726:}
        -: 7727:
function stbi_is_16_bit_from_file called 0 returned 0% blocks executed 0%
    #####: 7728:STBIDEF int stbi_is_16_bit_from_file(FILE *f)
        -: 7729:{
        -: 7730:   int r;
        -: 7731:   stbi__context s;
    #####: 7732:   long pos = ftell(f);
    %%%%%: 7732-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7733:   stbi__start_file(&s, f);
    %%%%%: 7733-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7734:   r = stbi__is_16_main(&s);
    %%%%%: 7734-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7735:   fseek(f,pos,SEEK_SET);
    %%%%%: 7735-block 5
call    0 never executed
    #####: 7736:   return r;
    %%%%%: 7736-block 7
        -: 7737:}
        -: 7738:#endif // !STBI_NO_STDIO
        -: 7739:
function stbi_info_from_memory called 0 returned 0% blocks executed 0%
    #####: 7740:STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
        -: 7741:{
        -: 7742:   stbi__context s;
    #####: 7743:   stbi__start_mem(&s,buffer,len);
    %%%%%: 7743-block 2
call    0 never executed
    #####: 7744:   return stbi__info_main(&s,x,y,comp);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7744-block 4
    %%%%%: 7744-block 6
        -: 7745:}
        -: 7746:
function stbi_info_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 7747:STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
        -: 7748:{
        -: 7749:   stbi__context s;
    #####: 7750:   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
    %%%%%: 7750-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7751:   return stbi__info_main(&s,x,y,comp);
    %%%%%: 7751-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7751-block 4
    %%%%%: 7751-block 6
        -: 7752:}
        -: 7753:
function stbi_is_16_bit_from_memory called 0 returned 0% blocks executed 0%
    #####: 7754:STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
        -: 7755:{
        -: 7756:   stbi__context s;
    #####: 7757:   stbi__start_mem(&s,buffer,len);
    %%%%%: 7757-block 2
call    0 never executed
    #####: 7758:   return stbi__is_16_main(&s);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7758-block 4
    %%%%%: 7758-block 6
        -: 7759:}
        -: 7760:
function stbi_is_16_bit_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 7761:STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
        -: 7762:{
        -: 7763:   stbi__context s;
    #####: 7764:   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
    %%%%%: 7764-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7765:   return stbi__is_16_main(&s);
    %%%%%: 7765-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7765-block 4
    %%%%%: 7765-block 6
        -: 7766:}
        -: 7767:
        -: 7768:#endif // STB_IMAGE_IMPLEMENTATION
        -: 7769:
        -: 7770:/*
        -: 7771:   revision history:
        -: 7772:      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
        -: 7773:      2.19  (2018-02-11) fix warning
        -: 7774:      2.18  (2018-01-30) fix warnings
        -: 7775:      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
        -: 7776:                         1-bit BMP
        -: 7777:                         *_is_16_bit api
        -: 7778:                         avoid warnings
        -: 7779:      2.16  (2017-07-23) all functions have 16-bit variants;
        -: 7780:                         STBI_NO_STDIO works again;
        -: 7781:                         compilation fixes;
        -: 7782:                         fix rounding in unpremultiply;
        -: 7783:                         optimize vertical flip;
        -: 7784:                         disable raw_len validation;
        -: 7785:                         documentation fixes
        -: 7786:      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
        -: 7787:                         warning fixes; disable run-time SSE detection on gcc;
        -: 7788:                         uniform handling of optional "return" values;
        -: 7789:                         thread-safe initialization of zlib tables
        -: 7790:      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
        -: 7791:      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
        -: 7792:      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
        -: 7793:      2.11  (2016-04-02) allocate large structures on the stack
        -: 7794:                         remove white matting for transparent PSD
        -: 7795:                         fix reported channel count for PNG & BMP
        -: 7796:                         re-enable SSE2 in non-gcc 64-bit
        -: 7797:                         support RGB-formatted JPEG
        -: 7798:                         read 16-bit PNGs (only as 8-bit)
        -: 7799:      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
        -: 7800:      2.09  (2016-01-16) allow comments in PNM files
        -: 7801:                         16-bit-per-pixel TGA (not bit-per-component)
        -: 7802:                         info() for TGA could break due to .hdr handling
        -: 7803:                         info() for BMP to shares code instead of sloppy parse
        -: 7804:                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
        -: 7805:                         code cleanup
        -: 7806:      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
        -: 7807:      2.07  (2015-09-13) fix compiler warnings
        -: 7808:                         partial animated GIF support
        -: 7809:                         limited 16-bpc PSD support
        -: 7810:                         #ifdef unused functions
        -: 7811:                         bug with < 92 byte PIC,PNM,HDR,TGA
        -: 7812:      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
        -: 7813:      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
        -: 7814:      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
        -: 7815:      2.03  (2015-04-12) extra corruption checking (mmozeiko)
        -: 7816:                         stbi_set_flip_vertically_on_load (nguillemot)
        -: 7817:                         fix NEON support; fix mingw support
        -: 7818:      2.02  (2015-01-19) fix incorrect assert, fix warning
        -: 7819:      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
        -: 7820:      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
        -: 7821:      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
        -: 7822:                         progressive JPEG (stb)
        -: 7823:                         PGM/PPM support (Ken Miller)
        -: 7824:                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
        -: 7825:                         GIF bugfix -- seemingly never worked
        -: 7826:                         STBI_NO_*, STBI_ONLY_*
        -: 7827:      1.48  (2014-12-14) fix incorrectly-named assert()
        -: 7828:      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
        -: 7829:                         optimize PNG (ryg)
        -: 7830:                         fix bug in interlaced PNG with user-specified channel count (stb)
        -: 7831:      1.46  (2014-08-26)
        -: 7832:              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
        -: 7833:      1.45  (2014-08-16)
        -: 7834:              fix MSVC-ARM internal compiler error by wrapping malloc
        -: 7835:      1.44  (2014-08-07)
        -: 7836:              various warning fixes from Ronny Chevalier
        -: 7837:      1.43  (2014-07-15)
        -: 7838:              fix MSVC-only compiler problem in code changed in 1.42
        -: 7839:      1.42  (2014-07-09)
        -: 7840:              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
        -: 7841:              fixes to stbi__cleanup_jpeg path
        -: 7842:              added STBI_ASSERT to avoid requiring assert.h
        -: 7843:      1.41  (2014-06-25)
        -: 7844:              fix search&replace from 1.36 that messed up comments/error messages
        -: 7845:      1.40  (2014-06-22)
        -: 7846:              fix gcc struct-initialization warning
        -: 7847:      1.39  (2014-06-15)
        -: 7848:              fix to TGA optimization when req_comp != number of components in TGA;
        -: 7849:              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
        -: 7850:              add support for BMP version 5 (more ignored fields)
        -: 7851:      1.38  (2014-06-06)
        -: 7852:              suppress MSVC warnings on integer casts truncating values
        -: 7853:              fix accidental rename of 'skip' field of I/O
        -: 7854:      1.37  (2014-06-04)
        -: 7855:              remove duplicate typedef
        -: 7856:      1.36  (2014-06-03)
        -: 7857:              convert to header file single-file library
        -: 7858:              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
        -: 7859:      1.35  (2014-05-27)
        -: 7860:              various warnings
        -: 7861:              fix broken STBI_SIMD path
        -: 7862:              fix bug where stbi_load_from_file no longer left file pointer in correct place
        -: 7863:              fix broken non-easy path for 32-bit BMP (possibly never used)
        -: 7864:              TGA optimization by Arseny Kapoulkine
        -: 7865:      1.34  (unknown)
        -: 7866:              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
        -: 7867:      1.33  (2011-07-14)
        -: 7868:              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
        -: 7869:      1.32  (2011-07-13)
        -: 7870:              support for "info" function for all supported filetypes (SpartanJ)
        -: 7871:      1.31  (2011-06-20)
        -: 7872:              a few more leak fixes, bug in PNG handling (SpartanJ)
        -: 7873:      1.30  (2011-06-11)
        -: 7874:              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
        -: 7875:              removed deprecated format-specific test/load functions
        -: 7876:              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
        -: 7877:              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
        -: 7878:              fix inefficiency in decoding 32-bit BMP (David Woo)
        -: 7879:      1.29  (2010-08-16)
        -: 7880:              various warning fixes from Aurelien Pocheville
        -: 7881:      1.28  (2010-08-01)
        -: 7882:              fix bug in GIF palette transparency (SpartanJ)
        -: 7883:      1.27  (2010-08-01)
        -: 7884:              cast-to-stbi_uc to fix warnings
        -: 7885:      1.26  (2010-07-24)
        -: 7886:              fix bug in file buffering for PNG reported by SpartanJ
        -: 7887:      1.25  (2010-07-17)
        -: 7888:              refix trans_data warning (Won Chun)
        -: 7889:      1.24  (2010-07-12)
        -: 7890:              perf improvements reading from files on platforms with lock-heavy fgetc()
        -: 7891:              minor perf improvements for jpeg
        -: 7892:              deprecated type-specific functions so we'll get feedback if they're needed
        -: 7893:              attempt to fix trans_data warning (Won Chun)
        -: 7894:      1.23    fixed bug in iPhone support
        -: 7895:      1.22  (2010-07-10)
        -: 7896:              removed image *writing* support
        -: 7897:              stbi_info support from Jetro Lauha
        -: 7898:              GIF support from Jean-Marc Lienher
        -: 7899:              iPhone PNG-extensions from James Brown
        -: 7900:              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
        -: 7901:      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
        -: 7902:      1.20    added support for Softimage PIC, by Tom Seddon
        -: 7903:      1.19    bug in interlaced PNG corruption check (found by ryg)
        -: 7904:      1.18  (2008-08-02)
        -: 7905:              fix a threading bug (local mutable static)
        -: 7906:      1.17    support interlaced PNG
        -: 7907:      1.16    major bugfix - stbi__convert_format converted one too many pixels
        -: 7908:      1.15    initialize some fields for thread safety
        -: 7909:      1.14    fix threadsafe conversion bug
        -: 7910:              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
        -: 7911:      1.13    threadsafe
        -: 7912:      1.12    const qualifiers in the API
        -: 7913:      1.11    Support installable IDCT, colorspace conversion routines
        -: 7914:      1.10    Fixes for 64-bit (don't use "unsigned long")
        -: 7915:              optimized upsampling by Fabian "ryg" Giesen
        -: 7916:      1.09    Fix format-conversion for PSD code (bad global variables!)
        -: 7917:      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
        -: 7918:      1.07    attempt to fix C++ warning/errors again
        -: 7919:      1.06    attempt to fix C++ warning/errors again
        -: 7920:      1.05    fix TGA loading to return correct *comp and use good luminance calc
        -: 7921:      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
        -: 7922:      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
        -: 7923:      1.02    support for (subset of) HDR files, float interface for preferred access to them
        -: 7924:      1.01    fix bug: possible bug in handling right-side up bmps... not sure
        -: 7925:              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
        -: 7926:      1.00    interface to zlib that skips zlib header
        -: 7927:      0.99    correct handling of alpha in palette
        -: 7928:      0.98    TGA loader by lonesock; dynamically add loaders (untested)
        -: 7929:      0.97    jpeg errors on too large a file; also catch another malloc failure
        -: 7930:      0.96    fix detection of invalid v value - particleman@mollyrocket forum
        -: 7931:      0.95    during header scan, seek to markers in case of padding
        -: 7932:      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
        -: 7933:      0.93    handle jpegtran output; verbose errors
        -: 7934:      0.92    read 4,8,16,24,32-bit BMP files of several formats
        -: 7935:      0.91    output 24-bit Windows 3.0 BMP files
        -: 7936:      0.90    fix a few more warnings; bump version number to approach 1.0
        -: 7937:      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
        -: 7938:      0.60    fix compiling as c++
        -: 7939:      0.59    fix warnings: merge Dave Moore's -Wall fixes
        -: 7940:      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
        -: 7941:      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
        -: 7942:      0.56    fix bug: zlib uncompressed mode len vs. nlen
        -: 7943:      0.55    fix bug: restart_interval not initialized to 0
        -: 7944:      0.54    allow NULL for 'int *comp'
        -: 7945:      0.53    fix bug in png 3->4; speedup png decoding
        -: 7946:      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
        -: 7947:      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
        -: 7948:              on 'test' only check type, not whether we support this variant
        -: 7949:      0.50  (2006-11-19)
        -: 7950:              first released version
        -: 7951:*/
        -: 7952:
        -: 7953:
        -: 7954:/*
        -: 7955:------------------------------------------------------------------------------
        -: 7956:This software is available under 2 licenses -- choose whichever you prefer.
        -: 7957:------------------------------------------------------------------------------
        -: 7958:ALTERNATIVE A - MIT License
        -: 7959:Copyright (c) 2017 Sean Barrett
        -: 7960:Permission is hereby granted, free of charge, to any person obtaining a copy of
        -: 7961:this software and associated documentation files (the "Software"), to deal in
        -: 7962:the Software without restriction, including without limitation the rights to
        -: 7963:use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
        -: 7964:of the Software, and to permit persons to whom the Software is furnished to do
        -: 7965:so, subject to the following conditions:
        -: 7966:The above copyright notice and this permission notice shall be included in all
        -: 7967:copies or substantial portions of the Software.
        -: 7968:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -: 7969:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -: 7970:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -: 7971:AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -: 7972:LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -: 7973:OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -: 7974:SOFTWARE.
        -: 7975:------------------------------------------------------------------------------
        -: 7976:ALTERNATIVE B - Public Domain (www.unlicense.org)
        -: 7977:This is free and unencumbered software released into the public domain.
        -: 7978:Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
        -: 7979:software, either in source code form or as a compiled binary, for any purpose,
        -: 7980:commercial or non-commercial, and by any means.
        -: 7981:In jurisdictions that recognize copyright laws, the author or authors of this
        -: 7982:software dedicate any and all copyright interest in the software to the public
        -: 7983:domain. We make this dedication for the benefit of the public at large and to
        -: 7984:the detriment of our heirs and successors. We intend this dedication to be an
        -: 7985:overt act of relinquishment in perpetuity of all present and future rights to
        -: 7986:this software under copyright law.
        -: 7987:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -: 7988:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -: 7989:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -: 7990:AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
        -: 7991:ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
        -: 7992:WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        -: 7993:------------------------------------------------------------------------------
        -: 7994:*/
        -: 7995:#endif //STB_IMAGE_H
