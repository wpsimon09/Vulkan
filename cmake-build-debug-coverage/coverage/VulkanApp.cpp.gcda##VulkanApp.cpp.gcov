        -:    0:Source:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/Includes/VulkanApp.cpp
        -:    0:Graph:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/VulkanApp.cpp.gcno
        -:    0:Data:/home/wpsimon09/Desktop/LearningVulkan/Vulkan/cmake-build-debug-coverage/CMakeFiles/LearnVulkan.dir/Includes/VulkanApp.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by wpsimon09 on 25/07/24.
        -:    3://
        -:    4:
        -:    5:#include "VulkanApp.hpp"
        -:    6:
        -:    7:#include <emmintrin.h>
        -:    8:#include <unistd.h>
        -:    9:
        -:   10:
function _ZN9VulkanApp3runEv called 1 returned 100% blocks executed 100%
        1:   11:void VulkanApp::run() {
        1:   12:    InitWindow();
        1:   12-block 2
call    0 returned 1
        -:   13:
        1:   14:    InitVulkan();
call    0 returned 1
        1:   15:    MainLoop();
call    0 returned 1
        -:   16:
        1:   17:    CleanUp();
call    0 returned 1
        1:   18:}
        -:   19:
function _ZN9VulkanApp13debugCallbackE38VkDebugUtilsMessageSeverityFlagBitsEXTjPK36VkDebugUtilsMessengerCallbackDataEXTPv called 39 returned 100% blocks executed 21%
       39:   20:VkBool32 VulkanApp::debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
        -:   21:                                      VkDebugUtilsMessageTypeFlagsEXT messageType,
        -:   22:                                      const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData,
        -:   23:                                      void *pUserData) {
       39:   24:    if (messageSeverity > VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
       39:   24-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 39
    #####:   25:        GetSeverity(messageSeverity);
    %%%%%:   25-block 3
call    0 never executed
    #####:   26:        GetMessageType(messageType);
call    0 never executed
        -:   27:        std::cerr <<
        -:   28:                "\n File:\t" <<__FILE__<<
    #####:   29:                "\n Message:\t"     <<pCallbackData ->pMessage <<
    #####:   30:                "\n Message ID:\t"  <<pCallbackData->messageIdNumber<<
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:   31:                "\n Object name:\t" <<pCallbackData->pObjects->pObjectName<<
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   32:            std::endl;
call    0 never executed
        -:   33:    }
       39:   34:    return VK_FALSE;
       39:   34-block 14
        -:   35:}
        -:   36:
function _ZN9VulkanApp10InitWindowEv called 1 returned 100% blocks executed 100%
        1:   37:void VulkanApp::InitWindow() {
        1:   38:    glfwInit();
        1:   38-block 2
call    0 returned 1
        1:   39:    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
call    0 returned 1
        1:   40:    glfwWindowHint(GLFW_RESIZABLE,GLFW_TRUE);
call    0 returned 1
        1:   41:    m_window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);
call    0 returned 1
        1:   42:    CreateCamera();
call    0 returned 1
        -:   43:
        1:   44:    glfwSetWindowUserPointer(m_window, this);
call    0 returned 1
        1:   45:    glfwSetFramebufferSizeCallback(m_window,FrameBufferResizeCallback);
call    0 returned 1
        1:   46:    glfwSetCursorPosCallback(m_window,MousePositionCallback);
call    0 returned 1
        1:   47:    glfwSetMouseButtonCallback(m_window, MouseClickCallback);
call    0 returned 1
        1:   48:    glfwSetScrollCallback(m_window, MouseScrollCallback);
call    0 returned 1
        1:   49:}
        -:   50:
function _ZN9VulkanApp10InitVulkanEv called 1 returned 100% blocks executed 100%
        1:   51:void VulkanApp::InitVulkan() {
        -:   52:
        1:   53:    CreateInstance();
        1:   53-block 2
call    0 returned 1
        1:   54:    SetUpDebugMessenger();
call    0 returned 1
        1:   55:    CreateSurface();
call    0 returned 1
        1:   56:    PickPhysicalDevice();
call    0 returned 1
        1:   57:    CreateLogicalDevice();
call    0 returned 1
        1:   58:    CreateSwapChain();
call    0 returned 1
        1:   59:    CreateImageViews();
call    0 returned 1
        1:   60:    CreateRenderPass();
call    0 returned 1
        1:   61:    GenerateGeometryVertices(PLANE);
call    0 returned 1
        1:   62:    CreateDescriptorSetLayout();
call    0 returned 1
        1:   63:    CreateGraphicsPipeline();
call    0 returned 1
        1:   64:    CreateFrameBuffers();
call    0 returned 1
        1:   65:    CreateCommandPool();
call    0 returned 1
        1:   66:    CreateTextureImage();
call    0 returned 1
        1:   67:    CreateTextureImageView();
call    0 returned 1
        1:   68:    CreateTextureSampler();
call    0 returned 1
        1:   69:    CreateVertexBuffers();
call    0 returned 1
        1:   70:    CreateIndexBuffers();
call    0 returned 1
        1:   71:    CreateUniformBuffers();
call    0 returned 1
        1:   72:    CreateDescriptorPool();
call    0 returned 1
        1:   73:    CreateDescriptorSet();
call    0 returned 1
        1:   74:    CreateCommandBuffers();
call    0 returned 1
        1:   75:    CreateSyncObjects();
call    0 returned 1
        1:   76:}
        -:   77:
function _ZN9VulkanApp12CreateCameraEv called 1 returned 100% blocks executed 100%
        1:   78:void VulkanApp::CreateCamera() {
        1:   79:    this->m_camera = std::make_unique<Camera>(m_window);
        1:   79-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:   79-block 3
call    3 returned 1
call    4 returned 1
        1:   80:}
        -:   81:
function _ZN9VulkanApp14CreateInstanceEv called 1 returned 100% blocks executed 59%
        1:   82:void VulkanApp::CreateInstance() {
        1:   83:    if (enableValidationLayers && !this->CheckValidationLayerSupport()) {
        1:   83-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:   83-block 3
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:   84:        throw std::runtime_error("Requested validation layers were not found");
    %%%%%:   84-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:   84-block 6
call    4 never executed
    $$$$$:   84-block 24
call    5 never executed
        -:   85:    } else {
        1:   86:        std::cout << "Valiation layers found\n";
        1:   86-block 7
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:   87:    }
        -:   88:
        -:   89:    //--------
        -:   90:    //APP INFO
        -:   91:    //--------
        1:   92:    VkApplicationInfo appInfo{};
        1:   93:    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
        1:   94:    appInfo.pApplicationName = "Hello triangle";
        1:   95:    appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
        1:   96:    appInfo.pEngineName = "No Engine";
        1:   97:    appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
        1:   98:    appInfo.apiVersion = VK_API_VERSION_1_3;
        1:   99:    appInfo.pNext = nullptr;
        -:  100:
        -:  101:    //--------------
        -:  102:    // INSTANCE INFO
        -:  103:    //--------------
        1:  104:    VkInstanceCreateInfo createInfo{};
        1:  105:    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
        1:  106:    createInfo.pApplicationInfo = &appInfo;
        1:  107:    VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo{};
        1:  107-block 8
        -:  108:    if (enableValidationLayers) {
        1:  109:        createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
        1:  109-block 9
call    0 returned 1
        1:  110:        createInfo.ppEnabledLayerNames = validationLayers.data();
call    0 returned 1
        1:  111:        PopulateDebugMessengerCreateInfo(debugCreateInfo);
call    0 returned 1
        1:  112:        createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT *) &debugCreateInfo;
        -:  113:    } else {
        -:  114:        createInfo.enabledLayerCount = 0;
        -:  115:        createInfo.pNext = nullptr;
        -:  116:    }
        -:  117:
        -:  118:    //----------
        -:  119:    //EXTENSIONS
        -:  120:    //----------
        1:  121:    auto extentions = GetRequiredExtentions();
        1:  121-block 13
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  122:    createInfo.enabledExtensionCount = static_cast<uint32_t>(extentions.size());
        1:  122-block 14
call    0 returned 1
        1:  123:    createInfo.ppEnabledExtensionNames = extentions.data();
call    0 returned 1
        -:  124:
        -:  125:    //----------------
        -:  126:    // CREATE INSTANCE
        -:  127:    //----------------
        1:  128:    if (vkCreateInstance(&createInfo, nullptr, &m_instance) != VK_SUCCESS) {
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  128-block 17
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  129:        throw std::runtime_error("Failed to create intance \n");
    %%%%%:  129-block 18
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  129-block 20
call    4 never executed
    $$$$$:  129-block 26
call    5 never executed
        -:  130:    } else {
        1:  131:        std::cout << "Vulkan instance created successfuly \n";
        1:  131-block 21
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  132:    }
        -:  133:
        1:  134:}
        1:  134-block 22
call    0 returned 1
    $$$$$:  134-block 28
call    1 never executed
        -:  135:
function _ZN9VulkanApp27CheckValidationLayerSupportEv called 1 returned 100% blocks executed 79%
        1:  136:bool VulkanApp::CheckValidationLayerSupport() {
        -:  137:    uint32_t layerCount;
        1:  138:    vkEnumerateInstanceLayerProperties(&layerCount, nullptr);
        1:  138-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  139:    std::vector<VkLayerProperties> availableLayers(layerCount);
        1:  139-block 5
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:  139-block 34
        1:  140:    vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data());
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        -:  141:
        2:  142:    for (const char *layerName: validationLayers) {
        1:  142-block 9
call    0 returned 1
call    1 returned 1
        1:  142-block 11
call    2 returned 1
        1:  142-block 25
call    3 returned 1
        2:  142-block 26
call    4 returned 2
branch  5 taken 1
branch  6 taken 1 (fallthrough)
        1:  143:        bool layerFound = false;
        8:  144:        for (const auto &layerProperties: availableLayers) {
call    0 returned 1
call    1 returned 1
        8:  144-block 14
call    2 returned 8
        7:  144-block 20
call    3 returned 7
        8:  144-block 21
call    4 returned 8
branch  5 taken 8
branch  6 taken 0 (fallthrough)
        8:  145:            std::cout << '\t' << layerProperties.layerName << '\n';
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0 (throw)
        8:  145-block 16
call    3 returned 8
branch  4 taken 8 (fallthrough)
branch  5 taken 0 (throw)
        8:  145-block 17
call    6 returned 8
branch  7 taken 8 (fallthrough)
branch  8 taken 0 (throw)
        8:  146:            if (strcmp(layerName, layerProperties.layerName) == 0) {
        8:  146-block 18
branch  0 taken 1 (fallthrough)
branch  1 taken 7
        1:  147:                layerFound = true;
        1:  148:                break;
        1:  148-block 19
        -:  149:            }
        -:  150:        }
        1:  151:        if (!layerFound)
        1:  151-block 23
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  152:            return false;
    %%%%%:  152-block 24
        -:  153:    }
        1:  154:    return true;
        1:  154-block 28
        1:  155:}
        1:  155-block 29
call    0 returned 1
    $$$$$:  155-block 37
call    1 never executed
        -:  156:
function _ZN9VulkanApp8MainLoopEv called 1 returned 100% blocks executed 100%
        1:  157:void VulkanApp::MainLoop() {
     1577:  158:    while (!glfwWindowShouldClose(m_window)) {
        1:  158-block 2
     1577:  158-block 6
call    0 returned 1577
branch  1 taken 1576
branch  2 taken 1 (fallthrough)
     1576:  159:        DrawFrame();
     1576:  159-block 3
call    0 returned 1576
     1576:  160:        m_appNotifier.NotifyChange();
call    0 returned 1576
     1576:  161:        glfwPollEvents();
call    0 returned 1576
        -:  162:    }
        1:  163:    vkDeviceWaitIdle(m_device);
        1:  163-block 8
call    0 returned 1
        1:  164:}
        -:  165:
function _ZN9VulkanApp9DrawFrameEv called 1576 returned 100% blocks executed 57%
     1576:  166:void VulkanApp::DrawFrame() {
        -:  167:    // wait for previous frame to finish drawind
     1576:  168:    vkWaitForFences(m_device, 1, &m_inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
     1576:  168-block 2
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
        -:  169:
        -:  170:    //get image from swap chain to draw into
        -:  171:    uint32_t imageIndex;
     1576:  172:    VkResult result = vkAcquireNextImageKHR(m_device, m_swapChain, UINT64_MAX, m_imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &imageIndex);
     1576:  172-block 4
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
        -:  173:
     1576:  174:    if(result == VK_ERROR_OUT_OF_DATE_KHR ) {
     1576:  174-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1576
    #####:  175:        RecreateSwapChain();
    %%%%%:  175-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  176:        return;
    %%%%%:  176-block 8
    1576*:  177:    }else if(result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
     1576:  177-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 1576
    %%%%%:  177-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  178:        throw std::runtime_error("Failed to acquire swap chain iamge");
    %%%%%:  178-block 11
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  178-block 13
call    4 never executed
    $$$$$:  178-block 42
call    5 never executed
        -:  179:    }
        -:  180:
        -:  181:    //reset fences after we are sure that we can continue rendering
     1576:  182:    vkResetFences(m_device, 1, &m_inFlightFences[currentFrame]);
     1576:  182-block 14
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
        -:  183:
     1576:  184:    UpdateUniformBuffer(currentFrame);
     1576:  184-block 16
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
        -:  185:
        -:  186:    //clear the command buffer so that it can record new information
        -:  187:    //here is acctual draw command and pipeline binding, scissors and viewport configuratio
     1576:  188:    vkResetCommandBuffer(m_commandBuffers[currentFrame], 0);
     1576:  188-block 17
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
     1576:  189:    RecordCommandBuffer(m_commandBuffers[currentFrame], imageIndex);
     1576:  189-block 19
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
        -:  190:
     1576:  191:    VkSubmitInfo submitInfo{};
     1576:  192:    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
     1576:  193:    VkSemaphore syncSemaphors[] = {m_imageAvailableSemaphores[currentFrame]};
     1576:  193-block 21
call    0 returned 1576
     1576:  194:    VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
        -:  195:
        -:  196:
     1576:  197:    submitInfo.waitSemaphoreCount = 1;
     1576:  198:    submitInfo.pWaitSemaphores = syncSemaphors;
     1576:  199:    submitInfo.pWaitDstStageMask = waitStages;
        -:  200:
     1576:  201:    submitInfo.commandBufferCount = 1;
     1576:  202:    submitInfo.pCommandBuffers = &m_commandBuffers[currentFrame];
call    0 returned 1576
        -:  203:
     1576:  204:    VkSemaphore signalSemaphores [] = {m_renderFinishedSemaphores[currentFrame]};
call    0 returned 1576
     1576:  205:    submitInfo.signalSemaphoreCount = 1;
     1576:  206:    submitInfo.pSignalSemaphores = signalSemaphores;
        -:  207:
     1576:  208:    if(vkQueueSubmit(m_graphicsQueue, 1, &submitInfo, m_inFlightFences[currentFrame]) != VK_SUCCESS) {
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
     1576:  208-block 26
branch  4 taken 0 (fallthrough)
branch  5 taken 1576
    #####:  209:        throw std::runtime_error("Failed to submit drawing command buffer");
    %%%%%:  209-block 27
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  209-block 29
call    4 never executed
    $$$$$:  209-block 44
call    5 never executed
        -:  210:    }
        -:  211:
     1576:  212:    VkPresentInfoKHR presentInfo{};
     1576:  213:    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
     1576:  214:    presentInfo.waitSemaphoreCount = 1;
     1576:  215:    presentInfo.pWaitSemaphores = signalSemaphores;
        -:  216:
     1576:  217:    VkSwapchainKHR swapChains[] = {m_swapChain};
     1576:  218:    presentInfo.swapchainCount = 1;
     1576:  219:    presentInfo.pSwapchains = swapChains;
     1576:  220:    presentInfo.pImageIndices = &imageIndex;
     1576:  221:    presentInfo.pResults = nullptr;
        -:  222:
     1576:  223:    result = vkQueuePresentKHR(m_presentationQueue,&presentInfo);
     1576:  223-block 30
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
        -:  224:
     1576:  225:    if(result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || m_frameBufferResized) {
     1576:  225-block 31
branch  0 taken 1576 (fallthrough)
branch  1 taken 0
     1576:  225-block 32
branch  2 taken 1576 (fallthrough)
branch  3 taken 0
     1576:  225-block 33
branch  4 taken 0 (fallthrough)
branch  5 taken 1576
    #####:  226:        RecreateSwapChain();
    %%%%%:  226-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  227:        m_frameBufferResized = false;
    %%%%%:  227-block 35
     1576:  228:    }else if(result != VK_SUCCESS) {
     1576:  228-block 36
branch  0 taken 0 (fallthrough)
branch  1 taken 1576
    #####:  229:        throw std::runtime_error("Failed to present swap chain image ");
    %%%%%:  229-block 37
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  229-block 39
call    4 never executed
    $$$$$:  229-block 46
call    5 never executed
        -:  230:    }
        -:  231:
     1576:  232:    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
     1576:  232-block 40
        -:  233:}
        -:  234:
function _ZN9VulkanApp32PopulateDebugMessengerCreateInfoER34VkDebugUtilsMessengerCreateInfoEXT called 2 returned 100% blocks executed 100%
        2:  235:void VulkanApp::PopulateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT &createInfo) {
        2:  236:    createInfo = {};
        2:  237:    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
        2:  238:    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
        -:  239:                                 VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
        -:  240:                                 VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
        2:  241:    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
        -:  242:                             VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
        -:  243:                             VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
        2:  244:    createInfo.pfnUserCallback = debugCallback;
        2:  245:    createInfo.pUserData = nullptr;
        2:  246:}
        -:  247:
function _ZN9VulkanApp18PickPhysicalDeviceEv called 1 returned 100% blocks executed 63%
        1:  248:void VulkanApp::PickPhysicalDevice() {
        -:  249:    //-----------------------------------
        -:  250:    // GET ALL AVAILABLE PHYSICAL DEVICES
        -:  251:    //-----------------------------------
        1:  252:    uint32_t deviceCount = 0;
        1:  253:    vkEnumeratePhysicalDevices(m_instance, &deviceCount, nullptr);
        1:  253-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  254:    std::cout << "Found " << deviceCount << " physical devices: \n";
        1:  254-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  254-block 4
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  254-block 5
call    6 returned 1
branch  7 taken 1 (fallthrough)
branch  8 taken 0 (throw)
        1:  255:    if (deviceCount == 0) {
        1:  255-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  256:        throw std::runtime_error("There are no physical devices on the machine ");
    %%%%%:  256-block 7
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  256-block 9
call    4 never executed
    $$$$$:  256-block 36
call    5 never executed
        -:  257:    }
        1:  258:    std::vector<VkPhysicalDevice> devices(deviceCount);
        1:  258-block 12
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:  258-block 40
        1:  259:    vkEnumeratePhysicalDevices(m_instance, &deviceCount, devices.data());
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        -:  260:
        -:  261:    //----------------------------------
        -:  262:    // PICK THE PHYSICAL DEVICE SUITABLE
        -:  263:    //----------------------------------
        2:  264:    for (auto &device: devices) {
        1:  264-block 16
call    0 returned 1
call    1 returned 1
        2:  264-block 18
call    2 returned 2
        1:  264-block 27
call    3 returned 1
        2:  264-block 28
call    4 returned 2
branch  5 taken 2
branch  6 taken 0 (fallthrough)
        2:  265:        if (isDeviceSuitable(device, m_sruface)) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  265-block 20
branch  3 taken 1 (fallthrough)
branch  4 taken 1
        1:  266:            m_physicalDevice = device;
        -:  267:            VkPhysicalDeviceProperties props;
        1:  268:            vkGetPhysicalDeviceProperties(device, &props);
        1:  268-block 21
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  269:            std::cout << "Using:" << props.deviceName << std::endl;
        1:  269-block 22
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  269-block 23
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  269-block 24
call    6 returned 1
branch  7 taken 1 (fallthrough)
branch  8 taken 0 (throw)
        1:  270:            break;
        1:  270-block 25
        -:  271:        }
        -:  272:    }
        1:  273:    if (m_physicalDevice == VK_NULL_HANDLE) {
        1:  273-block 30
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  274:        throw std::runtime_error("Failed to found any suitable GPU");
    %%%%%:  274-block 31
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  274-block 33
call    4 never executed
    $$$$$:  274-block 43
call    5 never executed
        -:  275:    }
        1:  276:}
        1:  276-block 34
call    0 returned 1
    $$$$$:  276-block 45
call    1 never executed
        -:  277:
function _ZN9VulkanApp15CreateSwapChainEv called 1 returned 100% blocks executed 67%
        1:  278:void VulkanApp::CreateSwapChain() {
        1:  279:    SwapChainSupportDetails swapChainSupport = querySwapChainSupport(m_physicalDevice, m_sruface);
        1:  279-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  280:    VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);
        1:  280-block 3
call    0 returned 1
        1:  281:    VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);
call    0 returned 1
        1:  282:    VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities, m_window);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  283:
        1:  284:    m_swapChainImageFormat = surfaceFormat.format;
        1:  285:    m_swapChainExtent = extent;
        -:  286:
        -:  287:    //images in swap chain (array of images)
        1:  288:    uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;
        -:  289:
        -:  290:    //make sure to not go over the limit of images in swap chain
        1:  291:    if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) {
        1:  291-block 6
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  291-block 7
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:  292:        imageCount = swapChainSupport.capabilities.maxImageCount;
    %%%%%:  292-block 8
        -:  293:    }
        -:  294:
        1:  295:    VkSwapchainCreateInfoKHR createInfo{};
        1:  296:    createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
        1:  297:    createInfo.surface = m_sruface;
        -:  298:
        1:  299:    createInfo.minImageCount = imageCount;
        1:  300:    createInfo.imageFormat = surfaceFormat.format;
        1:  301:    createInfo.imageColorSpace = surfaceFormat.colorSpace;
        1:  302:    createInfo.imageExtent = extent;
        -:  303:    //layer for setreoscopic 3D application
        1:  304:    createInfo.imageArrayLayers = 1;
        -:  305:    //how images will be used
        1:  306:    createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
        -:  307:
        1:  308:    QueueFamilyIndices indices = FindQueueFamilies(m_physicalDevice, m_sruface);
        1:  308-block 9
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  309:    uint32_t queueFamilyIndecies[] = {indices.graphicsFamily.value(), indices.presentFamily.value()};
        1:  309-block 10
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  309-block 11
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        -:  310:
        -:  311:    //if presentation and graphics queue family are the same use the exlusive mode
        -:  312:    //otherwise use concurent mode
        1:  313:    if (indices.graphicsFamily != indices.presentFamily) {
        1:  313-block 12
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  314:        createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
    #####:  315:        createInfo.queueFamilyIndexCount = 2;
    #####:  316:        createInfo.pQueueFamilyIndices = queueFamilyIndecies;
    %%%%%:  316-block 14
        -:  317:    }
        -:  318:    else {
        1:  319:        createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
        1:  319-block 15
        -:  320:    }
        -:  321:
        -:  322:    //horizontal flip, 90 deg rotation
        1:  323:    createInfo.preTransform = swapChainSupport.capabilities.currentTransform;
        -:  324:    //blend with other windows ? no
        1:  325:    createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
        -:  326:    //mailbox, fifo etc...
        1:  327:    createInfo.presentMode = presentMode;
        -:  328:    //if other window is infrotn of current window dont calculate pixels
        1:  329:    createInfo.clipped = VK_TRUE;
        -:  330:    //it can happend that swap chain will have to be recreted again, we wont do it here hence NULL
        1:  331:    createInfo.oldSwapchain = VK_NULL_HANDLE;
        -:  332:
        1:  333:    if(vkCreateSwapchainKHR(m_device, &createInfo, nullptr, &m_swapChain) != VK_SUCCESS) {
        1:  333-block 16
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  333-block 17
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  334:        throw std::runtime_error("Failed to create swap chain");
    %%%%%:  334-block 18
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  334-block 20
call    4 never executed
    $$$$$:  334-block 37
call    5 never executed
        -:  335:    }
        1:  336:    std::cout<<"Swapchain created !\n";
        1:  336-block 21
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  337:
        1:  338:    vkGetSwapchainImagesKHR(m_device, m_swapChain, &imageCount, nullptr);
        1:  338-block 22
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  339:    m_swapChainImages.resize(imageCount);
        1:  339-block 23
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  340:    vkGetSwapchainImagesKHR(m_device, m_swapChain, &imageCount, m_swapChainImages.data());
        1:  340-block 24
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        -:  341:
        1:  342:    if(m_swapChainImages.empty())
        1:  342-block 26
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  343:        throw std::runtime_error("No swap chain images retrieved");
    %%%%%:  343-block 28
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  343-block 30
call    4 never executed
    $$$$$:  343-block 39
call    5 never executed
        1:  344:    std::cout<<"Retrieved "<<m_swapChainImages.size()<<" swap chain images\n";
        1:  344-block 31
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  344-block 32
call    3 returned 1
call    4 returned 1
branch  5 taken 1 (fallthrough)
branch  6 taken 0 (throw)
        1:  344-block 34
call    7 returned 1
branch  8 taken 1 (fallthrough)
branch  9 taken 0 (throw)
        1:  345:}
        1:  345-block 35
call    0 returned 1
    $$$$$:  345-block 41
call    1 never executed
        -:  346:
function _ZN9VulkanApp16CreateImageViewsEv called 1 returned 100% blocks executed 100%
        1:  347:void VulkanApp::CreateImageViews() {
        1:  348:    m_swapChainImageViews.resize(m_swapChainImages.size());
        1:  348-block 2
call    0 returned 1
call    1 returned 1
        4:  349:    for(size_t i = 0; i<m_swapChainImages.size(); i++) {
        4:  349-block 9
call    0 returned 4
branch  1 taken 3
branch  2 taken 1 (fallthrough)
        3:  350:        m_swapChainImageViews[i] = GenerateImageView(m_device, m_swapChainImages[i], m_swapChainImageFormat);
        3:  350-block 5
call    0 returned 3
call    1 returned 3
call    2 returned 3
        -:  351:    }
        1:  352:}
        -:  353:
function _ZN9VulkanApp16CreateRenderPassEv called 1 returned 100% blocks executed 44%
        1:  354:void VulkanApp::CreateRenderPass() {
        1:  355:    VkAttachmentDescription colorAttachment{};
        1:  356:    colorAttachment.format = m_swapChainImageFormat;
        1:  357:    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
        -:  358:    //before render call colou and depth
        1:  359:    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
        -:  360:    //after render call colour and depth
        1:  361:    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
        1:  362:    colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
        1:  363:    colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
        -:  364:    //before render call
        1:  365:    colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        -:  366:    //after render call
        1:  367:    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
        -:  368:
        -:  369:    //---------
        -:  370:    // SUB PASS
        -:  371:    //---------
        1:  372:    VkAttachmentReference colorAttachmentRef{};
        -:  373:    //reference to the imaginary array of VkAttachmentDescription (we only have one)
        1:  374:    colorAttachmentRef.attachment = 0;
        1:  375:    colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
        -:  376:
        1:  377:    VkSubpassDescription subPass{};
        1:  378:    subPass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
        -:  379:    //reference to the colour attachemnt
        1:  380:    subPass.colorAttachmentCount = 1;
        1:  381:    subPass.pColorAttachments = &colorAttachmentRef;
        -:  382:
        -:  383:    //--------------------
        -:  384:    // SUB PASS DEPENDENCY
        -:  385:    //--------------------
        1:  386:    VkSubpassDependency dependency{};
        1:  387:    dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
        -:  388:    //subpass we are going to use since we only have one we will pass 0
        -:  389:    //dst subpass must be heigher than srcSubpass, only exception is if src is VK_SUBPASS_EXTERNAL
        1:  390:    dependency.dstSubpass = 0;
        -:  391:    //dependecy start
        1:  392:    dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        -:  393:    //we are not targeting any memmory so 0
        1:  394:    dependency.srcAccessMask = 0;
        -:  395:
        -:  396:    //dependency end
        1:  397:    dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        -:  398:    //we want to access colour attachemnt so that we can write to it
        1:  399:    dependency.dstAccessMask= VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
        -:  400:
        -:  401:
        1:  402:    VkRenderPassCreateInfo renderPassInfo{};
        1:  403:    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
        1:  404:    renderPassInfo.attachmentCount = 1;
        1:  405:    renderPassInfo.pAttachments = &colorAttachment;
        1:  406:    renderPassInfo.subpassCount = 1;
        1:  407:    renderPassInfo.pSubpasses = &subPass;
        1:  408:    renderPassInfo.dependencyCount = 1;
        1:  409:    renderPassInfo.pDependencies = &dependency;
        -:  410:
        -:  411:
        1:  412:    if(vkCreateRenderPass(m_device, &renderPassInfo, nullptr, &m_renderPass) != VK_SUCCESS) {
        1:  412-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  412-block 3
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  413:        throw std::runtime_error("Failed to create render pass");
    %%%%%:  413-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  413-block 6
call    4 never executed
    $$$$$:  413-block 8
call    5 never executed
        -:  414:    }
        -:  415:
        1:  416:}
        1:  416-block 7
        -:  417:
function _ZN9VulkanApp25CreateDescriptorSetLayoutEv called 1 returned 100% blocks executed 59%
        1:  418:void VulkanApp::CreateDescriptorSetLayout() {
        -:  419:
        1:  420:    VkDescriptorSetLayoutBinding uboLayoutBinding{};
        1:  421:    uboLayoutBinding.binding = 0;
        1:  422:    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        1:  423:    uboLayoutBinding.descriptorCount = 1;
        1:  424:    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
        1:  425:    uboLayoutBinding.pImmutableSamplers = nullptr;
        -:  426:
        1:  427:    auto bindings = m_material->GetLayoutBindings(1);
        1:  427-block 2
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  428:    bindings.emplace_back(uboLayoutBinding);
        1:  428-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  429:    /*
        -:  430:    VkDescriptorSetLayoutBinding imageSamplerLayoutBinding{};
        -:  431:    imageSamplerLayoutBinding.binding = 1;
        -:  432:    imageSamplerLayoutBinding.descriptorCount = 1;
        -:  433:    imageSamplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        -:  434:    imageSamplerLayoutBinding.pImmutableSamplers = nullptr;
        -:  435:    imageSamplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
        -:  436:    */
        -:  437:
        1:  438:    VkDescriptorSetLayoutCreateInfo layoutInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO};
        1:  439:    layoutInfo.bindingCount = static_cast<uint32_t>(bindings.size());
        1:  439-block 5
call    0 returned 1
        1:  440:    layoutInfo.pBindings = bindings.data();
call    0 returned 1
        1:  441:    layoutInfo.pNext = nullptr;
        -:  442:
        1:  443:    if(vkCreateDescriptorSetLayout(m_device, &layoutInfo, nullptr, &m_descriptorSetLayout) != VK_SUCCESS) {
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  443-block 8
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  444:        throw std::runtime_error("Failed to create descriptor set layout");
    %%%%%:  444-block 9
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  444-block 11
call    4 never executed
    $$$$$:  444-block 14
call    5 never executed
        -:  445:    };
        1:  446:}
        1:  446-block 12
call    0 returned 1
    $$$$$:  446-block 16
call    1 never executed
        -:  447:
function _ZN9VulkanApp20CreateDescriptorPoolEv called 1 returned 100% blocks executed 72%
        1:  448:void VulkanApp::CreateDescriptorPool() {
        1:  449:    std::array<VkDescriptorPoolSize,2> poolSizes{};
        -:  450:
        -:  451:    // for UBO
        1:  452:    poolSizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        1:  452-block 2
call    0 returned 1
        1:  453:    poolSizes[0].descriptorCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);
call    0 returned 1
        -:  454:
        -:  455:    // for Sampler
        1:  456:    poolSizes[1] = m_material->GetDescriptorPoolSize(static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT));
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  456-block 6
call    4 returned 1
        -:  457:
        1:  458:    VkDescriptorPoolCreateInfo poolInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO};
        1:  459:    poolInfo.poolSizeCount = static_cast<uint32_t>(poolSizes.size());
        1:  459-block 9
        1:  460:    poolInfo.pPoolSizes = poolSizes.data();
        1:  461:    poolInfo.maxSets = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);
        -:  462:
        1:  463:    if(vkCreateDescriptorPool(m_device, &poolInfo, nullptr, &m_descriptorPool) != VK_SUCCESS) {
        1:  463-block 11
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  463-block 12
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  464:        throw std::runtime_error("Failed to create descriptor pool");
    %%%%%:  464-block 13
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  464-block 15
call    4 never executed
    $$$$$:  464-block 17
call    5 never executed
        -:  465:    }
        1:  466:}
        1:  466-block 16
        -:  467:
function _ZN9VulkanApp19CreateDescriptorSetEv called 1 returned 100% blocks executed 64%
        1:  468:void VulkanApp::CreateDescriptorSet() {
        1:  468-block 2
        1:  469:    std::vector<VkDescriptorSetLayout> layouts(MAX_FRAMES_IN_FLIGHT,m_descriptorSetLayout);
        1:  469-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:  469-block 33
        1:  470:    VkDescriptorSetAllocateInfo allocInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO};
        1:  471:    allocInfo.descriptorPool = m_descriptorPool;
        1:  472:    allocInfo.descriptorSetCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);
        1:  473:    allocInfo.pSetLayouts = layouts.data();
call    0 returned 1
        1:  474:    m_descriptorSets.resize(MAX_FRAMES_IN_FLIGHT);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  475:
        1:  476:    if(vkAllocateDescriptorSets(m_device, &allocInfo, m_descriptorSets.data()) != VK_SUCCESS) {
        1:  476-block 8
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  476-block 10
branch  4 taken 0 (fallthrough)
branch  5 taken 1
    #####:  477:        throw std::runtime_error("Failed to allocate descriptors sets");
    %%%%%:  477-block 11
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  477-block 13
call    4 never executed
    $$$$$:  477-block 34
call    5 never executed
        -:  478:    }
        -:  479:
        3:  480:    for(size_t i = 0; i<MAX_FRAMES_IN_FLIGHT; i++) {
        1:  480-block 14
        3:  480-block 28
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        -:  481:        //--------
        -:  482:        // UBO
        -:  483:        //--------
        2:  484:        VkDescriptorBufferInfo bufferInfo{};
        2:  485:        bufferInfo.buffer = m_uniformBuffers[i];
        2:  485-block 15
call    0 returned 2
        2:  486:        bufferInfo.offset = 0;
        2:  487:        bufferInfo.range = VK_WHOLE_SIZE;
        -:  488:
        -:  489:        //----------
        -:  490:        // TEXTURE
        -:  491:        //----------
        -:  492:        /*VkDescriptorImageInfo imageInfo{};
        -:  493:        imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        -:  494:        imageInfo.imageView = m_textureImageView;
        -:  495:        imageInfo.sampler = m_textureSampler;*/
        -:  496:
        -:  497:
        -:  498:        //--------
        -:  499:        // UBO
        -:  500:        //--------
        -:  501:        VkWriteDescriptorSet bufferDescriptorWrite;
        2:  502:        bufferDescriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        2:  503:        bufferDescriptorWrite.dstSet = m_descriptorSets[i];
call    0 returned 2
        2:  504:        bufferDescriptorWrite.dstBinding = 0;
        2:  505:        bufferDescriptorWrite.dstArrayElement = 0;
        2:  506:        bufferDescriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        2:  507:        bufferDescriptorWrite.descriptorCount = 1;
        2:  508:        bufferDescriptorWrite.pBufferInfo = &bufferInfo;
        2:  509:        bufferDescriptorWrite.pImageInfo = nullptr;
        2:  510:        bufferDescriptorWrite.pTexelBufferView = nullptr;
        2:  511:        bufferDescriptorWrite.pNext = nullptr;
        -:  512:
        -:  513:        //----------
        -:  514:        // TEXTURE
        -:  515:        //----------
        -:  516:        /*descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        -:  517:        descriptorWrites[1].dstSet = m_descriptorSets[i];
        -:  518:        descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        -:  519:        descriptorWrites[1].dstBinding = 1;
        -:  520:        descriptorWrites[1].dstArrayElement = 0;
        -:  521:        descriptorWrites[1].descriptorCount = 1;
        -:  522:        descriptorWrites[1].pImageInfo = &imageInfo;
        -:  523:        descriptorWrites[1].pBufferInfo = nullptr;
        -:  524:        descriptorWrites[1].pTexelBufferView = nullptr;*/
        -:  525:
        2:  526:        auto descriptorWrites = m_material->GetDescriptorWrites(m_descriptorSets[i]);
call    0 returned 2
call    1 returned 2
call    2 returned 2
branch  3 taken 2 (fallthrough)
branch  4 taken 0 (throw)
        2:  527:        descriptorWrites.insert(descriptorWrites.begin(),bufferDescriptorWrite);
        2:  527-block 20
call    0 returned 2
call    1 returned 2
call    2 returned 2
branch  3 taken 2 (fallthrough)
branch  4 taken 0 (throw)
    $$$$$:  527-block 36
    $$$$$:  527-block 37
        -:  528:
        2:  529:        vkUpdateDescriptorSets(m_device, static_cast<uint32_t>(descriptorWrites.size()), descriptorWrites.data(), 0, nullptr);
        2:  529-block 23
call    0 returned 2
call    1 returned 2
call    2 returned 2
branch  3 taken 2 (fallthrough)
branch  4 taken 0 (throw)
        2:  530:    }
        2:  530-block 26
call    0 returned 2
    $$$$$:  530-block 38
call    1 never executed
        1:  531:}
        1:  531-block 29
call    0 returned 1
    $$$$$:  531-block 41
call    1 never executed
        -:  532:
function _ZN9VulkanApp22CreateGraphicsPipelineEv called 1 returned 100% blocks executed 56%
        1:  533:void VulkanApp::CreateGraphicsPipeline() {
        1:  533-block 2
        -:  534:
        -:  535:    //----------------
        -:  536:    // SHADER CREATION
        -:  537:    //----------------
        2:  538:    auto vertShaderCode = readFile("Shaders/Compiled/TriangleVertex.spv");
        1:  538-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  538-block 5
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  538-block 6
call    6 returned 1
    $$$$$:  538-block 59
call    7 never executed
    $$$$$:  538-block 63
    $$$$$:  538-block 64
        1:  539:    auto fragmentShaderCode = readFile("Shaders/Compiled/TriangleFragment.spv");
        1:  539-block 10
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  539-block 11
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  539-block 12
call    6 returned 1
    $$$$$:  539-block 65
call    7 never executed
    $$$$$:  539-block 69
    $$$$$:  539-block 70
        1:  540:    std::cout<<"Shader read sucessfuly\n";
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  541:
        1:  542:    VkShaderModule vertexShaderModule = createShaderModuel(m_device, vertShaderCode);
        1:  542-block 15
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  543:    VkShaderModule fragmentShaderModule = createShaderModuel(m_device, fragmentShaderCode);
        1:  543-block 16
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  544:
        1:  545:    VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
        1:  546:    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        1:  547:    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
        1:  548:    vertShaderStageInfo.module = vertexShaderModule;
        1:  549:    vertShaderStageInfo.pName = "main";
        1:  550:    vertShaderStageInfo.pNext = nullptr;
        -:  551:
        -:  552:    //allows to fill in constant variables in shaders using memory offset
        1:  553:    vertShaderStageInfo.pSpecializationInfo = nullptr;
        -:  554:
        1:  555:    VkPipelineShaderStageCreateInfo fragmentShaderStageInfo{};
        1:  556:    fragmentShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        1:  557:    fragmentShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
        1:  558:    fragmentShaderStageInfo.module = fragmentShaderModule;
        1:  559:    fragmentShaderStageInfo.pName = "main";
        1:  560:    fragmentShaderStageInfo.pNext = nullptr;
        -:  561:    //allows to fill in constant variables in shaders using memory offset
        1:  562:    fragmentShaderStageInfo.pSpecializationInfo = nullptr;
        1:  563:    VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragmentShaderStageInfo};
        -:  564:
        -:  565:    //----------------
        -:  566:    // DINAMIC PIPLINE
        -:  567:    //----------------
        -:  568:    std::vector<VkDynamicState> dynamicStates = {
        -:  569:        VK_DYNAMIC_STATE_VIEWPORT,
        -:  570:        VK_DYNAMIC_STATE_SCISSOR
        2:  571:    };
        1:  571-block 17
        1:  571-block 19
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:  571-block 73
    $$$$$:  571-block 74
        -:  572:
        1:  573:    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo{};
        1:  574:    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
        1:  575:    dynamicStateCreateInfo.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
call    0 returned 1
        1:  576:    dynamicStateCreateInfo.pDynamicStates = dynamicStates.data();
call    0 returned 1
        -:  577:
        -:  578:    //------------------
        -:  579:    // VERTEX ATTRIBUTES
        -:  580:    //------------------
        1:  581:    auto bindingDescription = Vertex::getBindingDescription();
call    0 returned 1
        1:  582:    auto attributeDescriptions = Vertex::getAttributeDescriptions();
call    0 returned 1
        -:  583:
        1:  584:    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
        1:  585:    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
        1:  586:    vertexInputInfo.vertexBindingDescriptionCount = 1;
        1:  587:    vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
        1:  588:    vertexInputInfo.vertexAttributeDescriptionCount = static_cast<uint32_t>(attributeDescriptions.size());
        1:  588-block 27
        1:  589:    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();
        -:  590:
        -:  591:    //-------------------
        -:  592:    // PRIMITIVE TOPOLOGY
        -:  593:    //-------------------
        1:  594:    VkPipelineInputAssemblyStateCreateInfo inputAssemblyCreateInfo{};
        1:  595:    inputAssemblyCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
       1*:  596:    inputAssemblyCreateInfo.topology = m_geometryType == SPHERE ? VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP : VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
        1:  596-block 29
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  596-block 30
        1:  596-block 31
        1:  597:    inputAssemblyCreateInfo.primitiveRestartEnable = VK_FALSE;
        -:  598:
        -:  599:    //----------
        -:  600:    // VIEW PORT
        -:  601:    //----------
        1:  602:    VkViewport viewPort{};
        1:  603:    viewPort.x = 0.0f;
        1:  604:    viewPort.y = 0.0f;
        1:  605:    viewPort.width = (float)m_swapChainExtent.width;
        1:  606:    viewPort.height = (float)m_swapChainExtent.height;
        1:  607:    viewPort.minDepth = 0.0f;
        1:  608:    viewPort.maxDepth = 1.0f;
        -:  609:
        -:  610:    //---------
        -:  611:    // SCISSORS
        -:  612:    //---------
        1:  613:    VkRect2D scissor{};
        1:  614:    scissor.offset = {0,0};
        1:  615:    scissor.extent = m_swapChainExtent;
        -:  616:
        -:  617:    //---------------------------------------------------
        -:  618:    // SCISSORS AND VIEW PORT DYNAMIC ADD TO THE PIPELINE
        -:  619:    //---------------------------------------------------
        -:  620:    std::vector<VkDynamicState> dynamicStates2 = {
        -:  621:        VK_DYNAMIC_STATE_VIEWPORT,
        -:  622:        VK_DYNAMIC_STATE_SCISSOR
        2:  623:    };
        1:  623-block 32
        1:  623-block 34
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:  623-block 77
    $$$$$:  623-block 78
        -:  624:
        1:  625:    VkPipelineDynamicStateCreateInfo dynmicStateVPandScissors{};
        1:  626:    dynmicStateVPandScissors.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
        1:  627:    dynmicStateVPandScissors.dynamicStateCount = static_cast <uint32_t>(dynamicStates2.size());
call    0 returned 1
        1:  628:    dynmicStateVPandScissors.pDynamicStates= dynamicStates2.data();
call    0 returned 1
        -:  629:
        1:  630:    VkPipelineViewportStateCreateInfo viewPortState{};
        1:  631:    viewPortState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
        1:  632:    viewPortState.viewportCount = 1;
        1:  633:    viewPortState.scissorCount=1;
        -:  634:
        -:  635:    //-----------
        -:  636:    // RASTERIZER
        -:  637:    //-----------
        1:  638:    VkPipelineRasterizationStateCreateInfo rasterizerCreateInfo{};
        1:  639:    rasterizerCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
        1:  640:    rasterizerCreateInfo.depthClampEnable = VK_FALSE;
        1:  641:    rasterizerCreateInfo.rasterizerDiscardEnable = VK_FALSE;
        1:  642:    rasterizerCreateInfo.polygonMode = VK_POLYGON_MODE_FILL;
        1:  643:    rasterizerCreateInfo.lineWidth = 1.0f;
       1*:  644:    rasterizerCreateInfo.cullMode =  m_geometryType == PLANE ? VK_CULL_MODE_NONE :VK_CULL_MODE_BACK_BIT;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  644-block 39
    %%%%%:  644-block 40
        1:  645:    rasterizerCreateInfo.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
        1:  646:    rasterizerCreateInfo.depthBiasEnable = VK_FALSE;
        1:  647:    rasterizerCreateInfo.depthBiasConstantFactor = 0.0F;
        1:  648:    rasterizerCreateInfo.depthBiasClamp = 0.0f;
        1:  649:    rasterizerCreateInfo.depthBiasSlopeFactor = 0.0f;
        -:  650:
        -:  651:    //--------------
        -:  652:    // MULTISAMPLING
        -:  653:    //--------------
        1:  654:    VkPipelineMultisampleStateCreateInfo multisampleCreateInfo{};
        1:  655:    multisampleCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
        1:  656:    multisampleCreateInfo.sampleShadingEnable = VK_FALSE;
        1:  657:    multisampleCreateInfo.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
        1:  658:    multisampleCreateInfo.minSampleShading = 1.0f;
        1:  659:    multisampleCreateInfo.pSampleMask = nullptr;
        1:  660:    multisampleCreateInfo.alphaToCoverageEnable= VK_FALSE;
        1:  661:    multisampleCreateInfo.alphaToOneEnable =VK_FALSE;
        -:  662:
        -:  663:    //-----------------------
        -:  664:    // DEPTH AND STENCIL TEST
        -:  665:    //-----------------------
        -:  666:    //later|
        -:  667:
        -:  668:    //----------------
        -:  669:    // COLOUR BLENDING
        -:  670:    //----------------
        1:  671:    VkPipelineColorBlendAttachmentState colourBlendAttachmentCreateInfo{};
        1:  672:    colourBlendAttachmentCreateInfo.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
        1:  673:    colourBlendAttachmentCreateInfo.blendEnable = VK_FALSE;
        1:  674:    colourBlendAttachmentCreateInfo.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
        1:  675:    colourBlendAttachmentCreateInfo.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;
        1:  676:    colourBlendAttachmentCreateInfo.colorBlendOp = VK_BLEND_OP_ADD;
        1:  677:    colourBlendAttachmentCreateInfo.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
        1:  678:    colourBlendAttachmentCreateInfo.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
        1:  679:    colourBlendAttachmentCreateInfo.alphaBlendOp = VK_BLEND_OP_ADD;
        -:  680:
        1:  681:    VkPipelineColorBlendStateCreateInfo colourBlendCreateInfo{};
        1:  682:    colourBlendCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
        1:  683:    colourBlendCreateInfo.logicOpEnable = VK_FALSE;
        1:  684:    colourBlendCreateInfo.logicOp = VK_LOGIC_OP_COPY;
        1:  685:    colourBlendCreateInfo.attachmentCount = 1;
        1:  686:    colourBlendCreateInfo.pAttachments = &colourBlendAttachmentCreateInfo;
        1:  687:    colourBlendCreateInfo.blendConstants[0] = 0.0f;
        1:  688:    colourBlendCreateInfo.blendConstants[1] = 0.0f;
        1:  689:    colourBlendCreateInfo.blendConstants[2] = 0.0f;
        1:  690:    colourBlendCreateInfo.blendConstants[3] = 0.0f;
        -:  691:
        -:  692:
        -:  693:    //----------------
        -:  694:    // PIPELINE LAYOUT
        -:  695:    //----------------
        1:  696:    VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo{};
        1:  697:    pipelineLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
        1:  698:    pipelineLayoutCreateInfo.setLayoutCount = 1;
        1:  699:    pipelineLayoutCreateInfo.pSetLayouts = &m_descriptorSetLayout;
        1:  700:    pipelineLayoutCreateInfo.pushConstantRangeCount = 0;
        1:  701:    pipelineLayoutCreateInfo.pPushConstantRanges = nullptr;
        -:  702:
        1:  703:    if(vkCreatePipelineLayout(m_device, &pipelineLayoutCreateInfo, nullptr, &m_pipelineLayout) != VK_SUCCESS) {
        1:  703-block 41
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  703-block 42
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  704:        throw std::runtime_error("Failed to create pipeline layout !");
    %%%%%:  704-block 43
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  704-block 45
call    4 never executed
    $$$$$:  704-block 79
call    5 never executed
        -:  705:    }
        -:  706:
        -:  707:    //------------------
        -:  708:    // PIPELINE CREATION
        -:  709:    //------------------
        1:  710:    VkGraphicsPipelineCreateInfo pipelineInfo{};
        -:  711:
        1:  712:    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
        1:  713:    pipelineInfo.stageCount = 2;
        -:  714:    //shaders
        1:  715:    pipelineInfo.pStages = shaderStages;
        -:  716:    //fixed functionality
        1:  717:    pipelineInfo.pVertexInputState = &vertexInputInfo;
        1:  718:    pipelineInfo.pInputAssemblyState = &inputAssemblyCreateInfo;
        1:  719:    pipelineInfo.pViewportState = &viewPortState;
        1:  720:    pipelineInfo.pRasterizationState= &rasterizerCreateInfo;
        1:  721:    pipelineInfo.pMultisampleState = &multisampleCreateInfo;
        1:  722:    pipelineInfo.pDepthStencilState = nullptr;
        1:  723:    pipelineInfo.pColorBlendState = &colourBlendCreateInfo;
        1:  724:    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
        -:  725:    //pipeline layout for uniforms
        1:  726:    pipelineInfo.layout = m_pipelineLayout;
        -:  727:    //render pass
        1:  728:    pipelineInfo.renderPass = m_renderPass;
        1:  729:    pipelineInfo.subpass = 0;
        -:  730:    //pipeline handle
        1:  731:    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;
        1:  732:    pipelineInfo.basePipelineIndex  = -1;
        -:  733:
        1:  734:    if(vkCreateGraphicsPipelines(m_device, VK_NULL_HANDLE,1,&pipelineInfo, nullptr, &m_graphicsPipeline)) {
        1:  734-block 46
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  734-block 47
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  735:        throw std::runtime_error("Failed to create graphics pipeline");
    %%%%%:  735-block 48
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  735-block 50
call    4 never executed
    $$$$$:  735-block 81
call    5 never executed
        -:  736:    }else {
        1:  737:        std::cout<<"Graphics pipeline created sucessfully !\n";
        1:  737-block 51
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  738:    }
        -:  739:
        -:  740:
        1:  741:    vkDestroyShaderModule(m_device, vertexShaderModule, nullptr);
        1:  741-block 52
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  742:    vkDestroyShaderModule(m_device, fragmentShaderModule, nullptr);
        1:  742-block 53
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  743:
        1:  744:}
        1:  744-block 54
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
    $$$$$:  744-block 83
call    4 never executed
    $$$$$:  744-block 85
call    5 never executed
    $$$$$:  744-block 87
call    6 never executed
    $$$$$:  744-block 89
call    7 never executed
        -:  745:
function _ZN9VulkanApp18CreateFrameBuffersEv called 1 returned 100% blocks executed 71%
        1:  746:void VulkanApp::CreateFrameBuffers() {
        1:  747:    m_swapChainFrameBuffers.resize(m_swapChainImageViews.size());
        1:  747-block 2
call    0 returned 1
call    1 returned 1
        -:  748:
        4:  749:    for(size_t i=0; i<m_swapChainImageViews.size(); i++) {
        3:  749-block 12
        4:  749-block 13
call    0 returned 4
branch  1 taken 3
branch  2 taken 1 (fallthrough)
        -:  750:        VkImageView attachments[] = {
        3:  751:            m_swapChainImageViews[i]
        3:  751-block 5
call    0 returned 3
        3:  752:        };
        3:  753:        VkFramebufferCreateInfo frameBufferInfo{};
        3:  754:        frameBufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        3:  755:        frameBufferInfo.renderPass = m_renderPass;
        3:  756:        frameBufferInfo.attachmentCount = 1;
        3:  757:        frameBufferInfo.pAttachments = attachments;
        3:  758:        frameBufferInfo.width = m_swapChainExtent.width;
        3:  759:        frameBufferInfo.height = m_swapChainExtent.height;
        3:  760:        frameBufferInfo.layers = 1;
        -:  761:
        3:  762:        if(vkCreateFramebuffer(m_device, &frameBufferInfo, nullptr, &m_swapChainFrameBuffers[i]) != VK_SUCCESS) {
call    0 returned 3
call    1 returned 3
branch  2 taken 3 (fallthrough)
branch  3 taken 0 (throw)
        3:  762-block 8
branch  4 taken 0 (fallthrough)
branch  5 taken 3
    #####:  763:            throw std::runtime_error("Failed to create frame buffers from swap chain images");
    %%%%%:  763-block 9
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  763-block 11
call    4 never executed
    $$$$$:  763-block 16
call    5 never executed
        -:  764:        }
        -:  765:    }
        1:  766:}
        1:  766-block 15
        -:  767:
function _ZN9VulkanApp18CreateTextureImageEv called 1 returned 100% blocks executed 81%
        1:  768:void VulkanApp::CreateTextureImage() {
        -:  769:
        1:  770:    TEXTURE_TYPE texturesToProcess[] = {TEXTURE_TYPE_ALBEDO, TEXTURE_TYPE_ARM, TEXTURE_TYPE_NORMAL};
        -:  771:    std::vector<std::string> paths = {
        -:  772:        "Textures/albedo.png", "Textures/arm.png", "Textures/normal.png"
        2:  773:    };
        1:  773-block 2
        1:  773-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:  773-block 52
        -:  774:
        -:  775:    VkBuffer stagingImageBuffer;
        -:  776:    VkDeviceMemory stagingImageMemory;
        -:  777:
        -:  778:    BufferCreateInfo bufferInfo;
        1:  779:    bufferInfo.physicalDevice = m_physicalDevice;
        1:  780:    bufferInfo.logicalDevice = m_device;
        1:  781:    bufferInfo.surface = m_sruface;
        1:  782:    bufferInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
        1:  783:    bufferInfo.properties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
        -:  784:
        1:  785:    ImageCreateInfo imageCreateInfo {};
        1:  786:    imageCreateInfo.physicalDevice = m_physicalDevice;
        1:  787:    imageCreateInfo.logicalDevice = m_device;
        1:  788:    imageCreateInfo.surface = m_sruface;
        1:  789:    imageCreateInfo.format = VK_FORMAT_R8G8B8A8_SRGB;
        1:  790:    imageCreateInfo.imageTiling = VK_IMAGE_TILING_OPTIMAL;
        1:  791:    imageCreateInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
        1:  792:    imageCreateInfo.memoryProperteis = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
        -:  793:
        -:  794:
        1:  795:    ImageLayoutDependencyInfo dependencyInfo{};
        1:  796:    dependencyInfo.commandBuffer = StartRecordingCommandBuffer();
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  797:    dependencyInfo.logicalDevice = m_device;
        1:  798:    dependencyInfo.transformQueue = m_transferQueue;
        -:  799:
        4:  800:    for(int i = 0; i < paths.size(); i++) {
        1:  800-block 7
        3:  800-block 42
        4:  800-block 43
call    0 returned 4
branch  1 taken 3
branch  2 taken 1 (fallthrough)
        -:  801:        int texWidth, texHeight, texChanels;
        3:  802:        stbi_uc* pixels = stbi_load(paths[i].c_str(), &texWidth, &texHeight, &texChanels, STBI_rgb_alpha);
        3:  802-block 8
call    0 returned 3
call    1 returned 3
call    2 returned 3
branch  3 taken 3 (fallthrough)
branch  4 taken 0 (throw)
        -:  803:
        3:  804:        std::cout<<"Loading texture: "<< paths[i] <<std::endl;
        3:  804-block 11
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  804-block 12
call    3 returned 3
call    4 returned 3
branch  5 taken 3 (fallthrough)
branch  6 taken 0 (throw)
        3:  804-block 14
call    7 returned 3
branch  8 taken 3 (fallthrough)
branch  9 taken 0 (throw)
        -:  805:
        3:  806:        if(!pixels) {
        3:  806-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  807:            throw std::runtime_error("Failed to load textue");
    %%%%%:  807-block 16
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  807-block 18
call    4 never executed
    $$$$$:  807-block 53
call    5 never executed
        -:  808:        }
        -:  809:
        -:  810:        // times 4 becaus   e we have RGBA
        3:  811:        VkDeviceSize imageSize = texWidth * texHeight * 4;
        3:  812:        bufferInfo.size = imageSize;
        3:  813:        CreateBuffer(bufferInfo, stagingImageBuffer, stagingImageMemory);
        3:  813-block 19
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:  814:
        -:  815:        void *data;
        3:  816:        vkMapMemory(m_device, stagingImageMemory, 0, imageSize, 0, &data);
        3:  816-block 20
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  817:            memcpy(data, pixels, static_cast<size_t>(imageSize));
        3:  818:        vkUnmapMemory(m_device, stagingImageMemory);
        3:  818-block 21
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:  819:
        3:  820:        stbi_image_free(pixels);
        3:  820-block 22
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:  821:
        3:  822:        imageCreateInfo.width = texWidth;
        3:  823:        imageCreateInfo.height = texHeight;
        3:  824:        imageCreateInfo.size = imageSize;
        -:  825:
        3:  826:        CreateImage(imageCreateInfo, m_material->GetTextures()[texturesToProcess[i]].image, m_material->GetTextures()[texturesToProcess[i]].memory);
        3:  826-block 23
call    0 returned 3
call    1 returned 3
call    2 returned 3
branch  3 taken 3 (fallthrough)
branch  4 taken 0 (throw)
        3:  826-block 26
call    5 returned 3
call    6 returned 3
call    7 returned 3
branch  8 taken 3 (fallthrough)
branch  9 taken 0 (throw)
        3:  826-block 29
call   10 returned 3
branch 11 taken 3 (fallthrough)
branch 12 taken 0 (throw)
        -:  827:
        -:  828:
        3:  829:        TransferImageLayout(dependencyInfo, m_material->GetTextures()[texturesToProcess[i]].image, imageCreateInfo.format, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
        3:  829-block 30
call    0 returned 3
call    1 returned 3
call    2 returned 3
branch  3 taken 3 (fallthrough)
branch  4 taken 0 (throw)
        3:  829-block 33
call    5 returned 3
branch  6 taken 3 (fallthrough)
branch  7 taken 0 (throw)
        -:  830:
        3:  831:        CopyBufferToImage(dependencyInfo,stagingImageBuffer, m_material->GetTextures()[texturesToProcess[i]].image, static_cast<uint32_t>(texWidth),static_cast<uint32_t>(texHeight));
        3:  831-block 34
call    0 returned 3
call    1 returned 3
call    2 returned 3
branch  3 taken 3 (fallthrough)
branch  4 taken 0 (throw)
        3:  831-block 37
call    5 returned 3
branch  6 taken 3 (fallthrough)
branch  7 taken 0 (throw)
        -:  832:
        3:  833:        TransferImageLayout(dependencyInfo, m_material->GetTextures()[texturesToProcess[i]].image, imageCreateInfo.format,VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
        3:  833-block 38
call    0 returned 3
call    1 returned 3
call    2 returned 3
branch  3 taken 3 (fallthrough)
branch  4 taken 0 (throw)
        3:  833-block 41
call    5 returned 3
branch  6 taken 3 (fallthrough)
branch  7 taken 0 (throw)
        -:  834:
        -:  835:
        -:  836:    }
        1:  837:        FlushCommandBuffer(dependencyInfo.commandBuffer);
        1:  837-block 45
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  838:        vkFreeMemory(m_device, stagingImageMemory, nullptr);
        1:  838-block 46
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  839:        vkDestroyBuffer(m_device, stagingImageBuffer, nullptr);
        1:  839-block 47
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  840:}
        1:  840-block 48
call    0 returned 1
    $$$$$:  840-block 56
call    1 never executed
        -:  841:
function _ZN9VulkanApp17CreateCommandPoolEv called 1 returned 100% blocks executed 47%
        1:  842:void VulkanApp::CreateCommandPool() {
        -:  843:    //retrieve all queue families from the GPU
        1:  844:    QueueFamilyIndices queueFamilyIndices = FindQueueFamilies(m_physicalDevice, m_sruface);
        1:  844-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  845:
        1:  846:    VkCommandPoolCreateInfo poolInfo{};
        1:  847:    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
        1:  848:    poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
        -:  849:    //use the graphics family for the drawing
        1:  850:    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();
        1:  850-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  851:
        1:  852:    if(vkCreateCommandPool(m_device, &poolInfo, nullptr, &m_comandPool) != VK_SUCCESS) {
        1:  852-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  852-block 5
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  853:        throw std::runtime_error("Failed to create command pool !");
    %%%%%:  853-block 6
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  853-block 8
call    4 never executed
    $$$$$:  853-block 16
call    5 never executed
        -:  854:    }
        -:  855:
        1:  856:    poolInfo.flags = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT;
        1:  857:    poolInfo.queueFamilyIndex = queueFamilyIndices.transferFamily.value();
        1:  857-block 9
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  858:    if(vkCreateCommandPool(m_device,&poolInfo, nullptr, &m_transferCommandPool) != VK_SUCCESS) {
        1:  858-block 10
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  858-block 11
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  859:        throw std::runtime_error("Failed to create transfer command pool");
    %%%%%:  859-block 12
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  859-block 14
call    4 never executed
    $$$$$:  859-block 18
call    5 never executed
        -:  860:    }
        1:  861:}
        1:  861-block 15
        -:  862:
function _ZN9VulkanApp19CreateVertexBuffersEv called 1 returned 100% blocks executed 100%
        1:  863:void VulkanApp::CreateVertexBuffers() {
        -:  864:    //-------------
        -:  865:    // BUFFER INFO
        -:  866:    //-------------
        1:  867:    BufferCreateInfo bufferInfo{};
        1:  868:    bufferInfo.size = sizeof(vertices[0]) * vertices.size();
        1:  868-block 2
call    0 returned 1
        1:  869:    bufferInfo.properties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
        -:  870:                            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
        1:  871:    bufferInfo.surface = m_sruface;
        1:  872:    bufferInfo.logicalDevice = m_device;
        1:  873:    bufferInfo.physicalDevice = m_physicalDevice;
        -:  874:
        -:  875:    //----------------
        -:  876:    // STAGING BUFFER
        -:  877:    //----------------
        -:  878:    VkBuffer stagingBuffer;
        -:  879:    VkDeviceMemory stagingBufferMemory;
        1:  880:    bufferInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
        1:  881:    CreateBuffer(bufferInfo, stagingBuffer, stagingBufferMemory);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  882:
        -:  883:    void* data;
        1:  884:    vkMapMemory(m_device, stagingBufferMemory, 0, bufferInfo.size, 0, &data);
        1:  884-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  885:    memcpy(data, vertices.data(), (size_t)bufferInfo.size);
        1:  885-block 5
call    0 returned 1
        1:  886:    vkUnmapMemory(m_device, stagingBufferMemory);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  887:
        -:  888:    //----------------
        -:  889:    // VERTEX BUFFER
        -:  890:    //----------------
        1:  891:    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
        1:  892:    bufferInfo.properties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
        1:  893:    CreateBuffer(bufferInfo, m_vertexBuffer, m_vertexBufferMemory);
        1:  893-block 7
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  894:
        -:  895:    //-----------------------------------
        -:  896:    // MOVE THE MEMORY FROM STAGING
        -:  897:    // BUFFER TO ACCTUAL VERTEX BUFFER
        -:  898:    //----------------------------------
        1:  899:    CopyBuffer(m_device, m_transferQueue, m_transferCommandPool,stagingBuffer, m_vertexBuffer,bufferInfo.size);
        1:  899-block 8
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  900:
        1:  901:    vkDestroyBuffer(m_device, stagingBuffer, nullptr);
        1:  901-block 9
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  902:    vkFreeMemory(m_device, stagingBufferMemory, nullptr);
        1:  902-block 10
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  903:}
        1:  903-block 11
        -:  904:
function _ZN9VulkanApp18CreateIndexBuffersEv called 1 returned 100% blocks executed 100%
        1:  905:void VulkanApp::CreateIndexBuffers() {
        1:  906:    BufferCreateInfo bufferCreateInfo{};
        1:  907:    bufferCreateInfo.physicalDevice = m_physicalDevice;
        1:  908:    bufferCreateInfo.logicalDevice = m_device;
        1:  909:    bufferCreateInfo.surface = m_sruface;
        -:  910:
        1:  911:    bufferCreateInfo.properties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
        1:  912:    bufferCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
        1:  913:    bufferCreateInfo.size = sizeof(uint32_t) * indices.size();
        1:  913-block 2
call    0 returned 1
        -:  914:
        -:  915:    VkBuffer stagingBuffer;
        -:  916:    VkDeviceMemory stagingMemory;
        1:  917:    CreateBuffer(bufferCreateInfo, stagingBuffer, stagingMemory);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  918:
        -:  919:    //put data to the staging buffer
        -:  920:    void* data;
        1:  921:    vkMapMemory(m_device, stagingMemory, 0, bufferCreateInfo.size,0, &data);
        1:  921-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  922:    memcpy(data, indices.data(), (size_t)bufferCreateInfo.size);
        1:  922-block 5
call    0 returned 1
        1:  923:    vkUnmapMemory(m_device, stagingMemory);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  924:
        -:  925:    //create index buffer
        1:  926:    bufferCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
        1:  927:    bufferCreateInfo.properties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
        1:  928:    CreateBuffer(bufferCreateInfo, m_indexBuffer, m_indexBufferMemory);
        1:  928-block 7
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  929:
        -:  930:    //copy staging buffer to the index buffer
        1:  931:    CopyBuffer(m_device ,m_transferQueue, m_transferCommandPool, stagingBuffer, m_indexBuffer, bufferCreateInfo.size);
        1:  931-block 8
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  932:
        -:  933:    //clean up
        1:  934:    vkDestroyBuffer(m_device, stagingBuffer, nullptr);
        1:  934-block 9
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  935:    vkFreeMemory(m_device, stagingMemory, nullptr);
        1:  935-block 10
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  936:}
        1:  936-block 11
        -:  937:
function _ZN9VulkanApp20CreateUniformBuffersEv called 1 returned 100% blocks executed 100%
        1:  938:void VulkanApp::CreateUniformBuffers() {
        1:  939:    BufferCreateInfo bufferInfo{};
        1:  940:    bufferInfo.logicalDevice = m_device;
        1:  941:    bufferInfo.physicalDevice = m_physicalDevice;
        1:  942:    bufferInfo.surface = m_sruface;
        1:  943:    bufferInfo.size = sizeof(UniformBufferObject);
        1:  944:    bufferInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
        1:  945:    bufferInfo.properties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
        -:  946:
        1:  947:    m_uniformBuffers.resize(MAX_FRAMES_IN_FLIGHT);
        1:  947-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  948:    m_uniformBuffersMemory.resize(MAX_FRAMES_IN_FLIGHT);
        1:  948-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  949:    m_uniformBuffersMapped.resize(MAX_FRAMES_IN_FLIGHT);
        1:  949-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  950:
        3:  951:    for(size_t i=0; i< MAX_FRAMES_IN_FLIGHT; i++) {
        1:  951-block 5
        2:  951-block 12
        3:  951-block 13
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        2:  952:        CreateBuffer(bufferInfo, m_uniformBuffers[i], m_uniformBuffersMemory[i]);
        2:  952-block 6
call    0 returned 2
call    1 returned 2
call    2 returned 2
branch  3 taken 2 (fallthrough)
branch  4 taken 0 (throw)
        -:  953:
        2:  954:        vkMapMemory(m_device, m_uniformBuffersMemory[i], 0, bufferInfo.size, 0, &m_uniformBuffersMapped[i]);
        2:  954-block 9
call    0 returned 2
call    1 returned 2
call    2 returned 2
branch  3 taken 2 (fallthrough)
branch  4 taken 0 (throw)
        -:  955:    }
        1:  956:}
        1:  956-block 14
        -:  957:
function _ZN9VulkanApp22CreateTextureImageViewEv called 1 returned 100% blocks executed 100%
        1:  958:void VulkanApp::CreateTextureImageView() {
        -:  959:    //m_textureImageView = GenerateImageView(m_device, m_textureImage);
        -:  960:
        4:  961:    for(auto &materialTexture:m_material->GetTextures()) {
        1:  961-block 2
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
        3:  961-block 6
call    4 returned 3
        4:  961-block 9
call    5 returned 4
branch  6 taken 3
branch  7 taken 1 (fallthrough)
        3:  962:        materialTexture.second.imageView = GenerateImageView(m_device, materialTexture.second.image);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:  962-block 8
call    3 returned 3
        -:  963:    }
        1:  964:}
        1:  964-block 11
        -:  965:
function _ZN9VulkanApp20CreateTextureSamplerEv called 1 returned 100% blocks executed 72%
        1:  966:void VulkanApp::CreateTextureSampler() {
        1:  967:    VkSamplerCreateInfo samplerInfo{.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO};
        1:  968:    samplerInfo.magFilter = VK_FILTER_LINEAR; //can be VK_FILTER_NEREAST (resutls in pixelatino)
        1:  969:    samplerInfo.minFilter = VK_FILTER_LINEAR; //can be VK_FILTER_NEREAST (resutls in pixelatino)
        1:  970:    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT; // what happens when we attemp to sample where there are not pixels
        1:  971:    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT; // can be repeat, clamp to eadge or clamp to border
        1:  972:    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        1:  973:    samplerInfo.anisotropyEnable = VK_TRUE;
        -:  974:
        -:  975:    VkPhysicalDeviceProperties physicalDeviceProperties;
        1:  976:    vkGetPhysicalDeviceProperties(m_physicalDevice, &physicalDeviceProperties);
        1:  976-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  977:    samplerInfo.maxAnisotropy = physicalDeviceProperties.limits.maxSamplerAnisotropy;
        -:  978:
        -:  979:    //color to be used when VK_SAMPLER_ADRESSS_MODE_BORDER is selected
        1:  980:    samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
        -:  981:
        -:  982:    // use uv coordinates in range (0,1) - true or (0,imageLimit) - false
        1:  983:    samplerInfo.unnormalizedCoordinates = VK_FALSE;
        -:  984:
        -:  985:    // compare values against reference, this will be important while calculating PCF shadow
        1:  986:    samplerInfo.compareEnable = VK_FALSE;
        1:  987:    samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;
        -:  988:
        -:  989:    // mip mapping
        1:  990:    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
        1:  991:    samplerInfo.mipLodBias = 0.0f; // can also be physicalDeviceProperties.limits.maxSamplerLodBias
        1:  992:    samplerInfo.minLod = 0.0;
        1:  993:    samplerInfo.maxLod = 0.0f;
        -:  994:
        1:  995:    if(vkCreateSampler(m_device, &samplerInfo, nullptr, &m_textureSampler) != VK_SUCCESS) {
        1:  995-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  995-block 4
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  996:        throw std::runtime_error("Failed to create texture sampler");
    %%%%%:  996-block 5
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  996-block 7
call    4 never executed
    $$$$$:  996-block 17
call    5 never executed
        -:  997:    }
        -:  998:
        4:  999:    for(auto &material: m_material->GetTextures()) {
        1:  999-block 8
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
        3:  999-block 12
call    4 returned 3
        4:  999-block 14
call    5 returned 4
branch  6 taken 3
branch  7 taken 1 (fallthrough)
        3: 1000:        material.second.sampler = m_textureSampler;
call    0 returned 3
        -: 1001:    }
        -: 1002:
        1: 1003:}
        1: 1003-block 16
        -: 1004:
function _ZN9VulkanApp20CreateCommandBuffersEv called 1 returned 100% blocks executed 58%
        1: 1005:void VulkanApp::CreateCommandBuffers() {
        1: 1006:    m_commandBuffers.resize(MAX_FRAMES_IN_FLIGHT);
        1: 1006-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1007:    VkCommandBufferAllocateInfo allocInfo{};
        1: 1008:    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        1: 1009:    allocInfo.commandPool = m_comandPool;
        1: 1010:    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        1: 1011:    allocInfo.commandBufferCount = static_cast<uint32_t>(m_commandBuffers.size());
        1: 1011-block 3
call    0 returned 1
        -: 1012:
        1: 1013:    if(vkAllocateCommandBuffers(m_device,&allocInfo,m_commandBuffers.data()) != VK_SUCCESS) {
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1: 1013-block 6
branch  4 taken 0 (fallthrough)
branch  5 taken 1
    #####: 1014:        throw std::runtime_error("Failed to allocate command buffer");
    %%%%%: 1014-block 7
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1014-block 9
call    4 never executed
    $$$$$: 1014-block 11
call    5 never executed
        -: 1015:    }
        1: 1016:}
        1: 1016-block 10
        -: 1017:
function _ZN9VulkanApp19RecordCommandBufferEP17VkCommandBuffer_Tj called 1576 returned 100% blocks executed 67%
     1576: 1018:void VulkanApp:: RecordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex) {
     1576: 1019:    VkCommandBufferBeginInfo beginInfo{};
     1576: 1020:    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
     1576: 1021:    beginInfo.flags = 0;
     1576: 1022:    beginInfo.pInheritanceInfo = nullptr;
        -: 1023:
     1576: 1024:    if(vkBeginCommandBuffer(commandBuffer, &beginInfo)!=VK_SUCCESS) {
     1576: 1024-block 2
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
     1576: 1024-block 3
branch  3 taken 0 (fallthrough)
branch  4 taken 1576
    #####: 1025:        throw std::runtime_error("Failed to start recording the command buffer");
    %%%%%: 1025-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1025-block 6
call    4 never executed
    $$$$$: 1025-block 27
call    5 never executed
        -: 1026:    }
        -: 1027:
     1576: 1028:    VkRenderPassBeginInfo renderPassInfo{};
     1576: 1029:    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
     1576: 1030:    renderPassInfo.renderPass = m_renderPass;
     1576: 1031:    renderPassInfo.framebuffer = m_swapChainFrameBuffers[imageIndex];
     1576: 1031-block 7
call    0 returned 1576
        -: 1032:
     1576: 1033:    renderPassInfo.renderArea.offset = {0,0};
     1576: 1034:    renderPassInfo.renderArea.extent = m_swapChainExtent;
        -: 1035:
     1576: 1036:    const float red = glm::abs(glm::sin(glfwGetTime()));
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
     1576: 1036-block 9
call    3 returned 1576
branch  4 taken 1576 (fallthrough)
branch  5 taken 0 (throw)
        -: 1037:
     1576: 1038:    VkClearValue clearValue = {{{0.3f, 0.3f, 0.3f,1.0f}}};
     1576: 1039:    renderPassInfo.clearValueCount = 1;
     1576: 1040:    renderPassInfo.pClearValues = &clearValue;
        -: 1041:
     1576: 1042:    vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);
     1576: 1042-block 10
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
        -: 1043:
     1576: 1044:    vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_graphicsPipeline);
     1576: 1044-block 11
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
        -: 1045:
     1576: 1046:    VkViewport viewport{};
     1576: 1047:    viewport.x = 0.0f;
     1576: 1048:    viewport.y = 0.0f;
        -: 1049:
     1576: 1050:    viewport.width = static_cast<float>(m_swapChainExtent.width);
     1576: 1051:    viewport.height = static_cast<float>(m_swapChainExtent.height);
        -: 1052:
     1576: 1053:    viewport.minDepth = 0.0f;
     1576: 1054:    viewport.maxDepth = 1.0f;
     1576: 1055:    vkCmdSetViewport(commandBuffer, 0, 1, &viewport);
     1576: 1055-block 12
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
        -: 1056:
     1576: 1057:    VkRect2D scissors{};
     1576: 1058:    scissors.offset = {0,0};
     1576: 1059:    scissors.extent = m_swapChainExtent;
     1576: 1060:    vkCmdSetScissor(commandBuffer, 0, 1, &scissors);
     1576: 1060-block 13
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
        -: 1061:
     1576: 1062:    VkBuffer vertexBuffers[] = {m_vertexBuffer};
     1576: 1063:    VkDeviceSize offsets[] = {0};
        -: 1064:
     1576: 1065:    vkCmdBindVertexBuffers(commandBuffer, 0, 1, vertexBuffers, offsets);
     1576: 1065-block 14
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
        -: 1066:
     1576: 1067:    vkCmdBindIndexBuffer(commandBuffer, m_indexBuffer, 0, VK_INDEX_TYPE_UINT32);
     1576: 1067-block 15
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
        -: 1068:
     1576: 1069:    vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipelineLayout, 0, 1, &m_descriptorSets[currentFrame], 0, nullptr);
     1576: 1069-block 16
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
        -: 1070:
     1576: 1071:    vkCmdDrawIndexed(commandBuffer,static_cast<uint32_t>(indices.size()),1,0,0,0);
     1576: 1071-block 18
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
        -: 1072:
     1576: 1073:    vkCmdEndRenderPass(commandBuffer);
     1576: 1073-block 20
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
        -: 1074:
     1576: 1075:    if(vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
     1576: 1075-block 21
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
     1576: 1075-block 22
branch  3 taken 0 (fallthrough)
branch  4 taken 1576
    #####: 1076:        throw std::runtime_error("Failed to record command buffer !");
    %%%%%: 1076-block 23
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1076-block 25
call    4 never executed
    $$$$$: 1076-block 29
call    5 never executed
        -: 1077:    }
     1576: 1078:}
     1576: 1078-block 26
        -: 1079:
function _ZN9VulkanApp27StartRecordingCommandBufferEv called 1 returned 100% blocks executed 100%
        1: 1080:VkCommandBuffer VulkanApp::StartRecordingCommandBuffer() {
        1: 1081:    VkCommandBufferAllocateInfo allocInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};
        1: 1082:    allocInfo.commandPool = m_transferCommandPool;
        1: 1083:    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        1: 1084:    allocInfo.commandBufferCount = 1;
        -: 1085:
        -: 1086:    VkCommandBuffer commandBuffer;
        1: 1087:    vkAllocateCommandBuffers(m_device, &allocInfo, &commandBuffer);
        1: 1087-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 1088:
        1: 1089:    VkCommandBufferBeginInfo beginInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
        1: 1090:    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        -: 1091:
        1: 1092:    vkBeginCommandBuffer(commandBuffer, &beginInfo);
        1: 1092-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 1093:
        1: 1094:    return commandBuffer;
        1: 1094-block 4
        1: 1094-block 5
        -: 1095:}
        -: 1096:
function _ZN9VulkanApp18FlushCommandBufferEP17VkCommandBuffer_T called 1 returned 100% blocks executed 100%
        1: 1097:void VulkanApp::FlushCommandBuffer(VkCommandBuffer commandBuffer) {
        1: 1098:    vkEndCommandBuffer(commandBuffer);
        1: 1098-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 1099:
        1: 1100:    VkSubmitInfo submitInfo{.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO};
        1: 1101:    submitInfo.commandBufferCount = 1;
        1: 1102:    submitInfo.pCommandBuffers = &commandBuffer;
        -: 1103:
        1: 1104:    vkQueueSubmit(m_transferQueue, 1, &submitInfo, VK_NULL_HANDLE);
        1: 1104-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1105:    vkQueueWaitIdle(m_transferQueue);
        1: 1105-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1106:    vkFreeCommandBuffers(m_device, m_transferCommandPool, 1, &commandBuffer);
        1: 1106-block 5
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1107:}
        1: 1107-block 6
        -: 1108:
function _ZN9VulkanApp17CreateSyncObjectsEv called 1 returned 100% blocks executed 76%
        1: 1109:void VulkanApp::CreateSyncObjects() {
        1: 1110:    m_imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
        1: 1110-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1111:    m_renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
        1: 1111-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1112:    m_inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);
        1: 1112-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 1113:
        1: 1114:    VkSemaphoreCreateInfo semaphoreInfo{};
        1: 1115:    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
        -: 1116:
        1: 1117:    VkFenceCreateInfo fenceInfo{};
        1: 1118:    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
        1: 1119:    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;
        -: 1120:
        3: 1121:    for(size_t i = 0; i< MAX_FRAMES_IN_FLIGHT;i++) {
        1: 1121-block 5
        2: 1121-block 21
        3: 1121-block 22
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        2: 1122:        if(vkCreateSemaphore(m_device, &semaphoreInfo, nullptr, &m_imageAvailableSemaphores[i]) != VK_SUCCESS ||
        2: 1122-block 6
call    0 returned 2
call    1 returned 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0 (throw)
       4*: 1123:           vkCreateSemaphore(m_device, &semaphoreInfo, nullptr, &m_renderFinishedSemaphores[i]) != VK_SUCCESS ||
        2: 1123-block 8
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1123-block 9
call    2 returned 2
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
        2: 1123-block 11
branch  6 taken 2 (fallthrough)
branch  7 taken 0
    %%%%%: 1123-block 15
        2: 1123-block 16
        2: 1123-block 17
branch  8 taken 0 (fallthrough)
branch  9 taken 2
        2: 1124:           vkCreateFence(m_device, &fenceInfo, nullptr, &m_inFlightFences[i]) != VK_SUCCESS
        2: 1124-block 12
call    0 returned 2
call    1 returned 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0 (throw)
        2: 1124-block 14
branch  4 taken 0 (fallthrough)
branch  5 taken 2
        -: 1125:           ) {
    #####: 1126:            throw std::runtime_error("Failed to create synchronization objects");
    %%%%%: 1126-block 18
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1126-block 20
call    4 never executed
    $$$$$: 1126-block 24
call    5 never executed
        -: 1127:        }
        -: 1128:    }
        1: 1129:}
        1: 1129-block 23
        -: 1130:
function _ZN9VulkanApp19UpdateUniformBufferEj called 1576 returned 100% blocks executed 80%
     1576: 1131:void VulkanApp::UpdateUniformBuffer(uint32_t currentImage) {
     1576: 1132:    UniformBufferObject ubo{};
     1576: 1133:    ubo.model = glm::mat4(1.0f);
     1576: 1133-block 2
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$: 1133-block 17
    $$$$$: 1133-block 18
     1576: 1134:    ubo.model = glm::scale(ubo.model, glm::vec3(10.7f));
     1576: 1134-block 3
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 1134-block 19
     1576: 1135:    ubo.projection = m_camera->getPojectionMatix();
     1576: 1135-block 5
call    0 returned 1576
call    1 returned 1576
     1576: 1136:    ubo.projection[1][1] *= -1;
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
     1576: 1136-block 8
call    3 returned 1576
branch  4 taken 1576 (fallthrough)
branch  5 taken 0 (throw)
     1576: 1137:    ubo.view = m_camera->getViewMatrix();
     1576: 1137-block 9
call    0 returned 1576
call    1 returned 1576
branch  2 taken 1576 (fallthrough)
branch  3 taken 0 (throw)
     1576: 1138:    ubo.camPos = m_camera->getPosition();
     1576: 1138-block 11
call    0 returned 1576
call    1 returned 1576
     1576: 1139:    ubo.normal = glm::transpose(glm::inverse(ubo.model));
call    0 returned 1576
branch  1 taken 1576 (fallthrough)
branch  2 taken 0 (throw)
     1576: 1139-block 14
call    3 returned 1576
branch  4 taken 1576 (fallthrough)
branch  5 taken 0 (throw)
    $$$$$: 1139-block 20
        -: 1140:
     1576: 1141:    memcpy(m_uniformBuffersMapped[currentFrame], &ubo, sizeof(ubo));
     1576: 1141-block 15
call    0 returned 1576
        -: 1142:
     1576: 1143:}
        -: 1144:
function _ZN9VulkanApp16CleanupSwapChainEv called 1 returned 100% blocks executed 94%
        1: 1145:void VulkanApp::CleanupSwapChain() {
        4: 1146:    for (auto frameBuffer: m_swapChainFrameBuffers) {
        1: 1146-block 2
call    0 returned 1
call    1 returned 1
        3: 1146-block 4
call    2 returned 3
        3: 1146-block 6
call    3 returned 3
        4: 1146-block 7
call    4 returned 4
branch  5 taken 3
branch  6 taken 1 (fallthrough)
        3: 1147:        vkDestroyFramebuffer(m_device, frameBuffer, nullptr);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -: 1148:    }
        -: 1149:
        4: 1150:    for (auto imageView: m_swapChainImageViews) {
        1: 1150-block 9
call    0 returned 1
call    1 returned 1
        3: 1150-block 11
call    2 returned 3
        3: 1150-block 13
call    3 returned 3
        4: 1150-block 14
call    4 returned 4
branch  5 taken 3
branch  6 taken 1 (fallthrough)
        3: 1151:        vkDestroyImageView(m_device, imageView, nullptr);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -: 1152:    }
        -: 1153:
        1: 1154:    vkDestroySwapchainKHR(m_device, m_swapChain, nullptr);
        1: 1154-block 16
call    0 returned 1
        1: 1155:}
        -: 1156:
function _ZN9VulkanApp17RecreateSwapChainEv called 0 returned 0% blocks executed 0%
    #####: 1157:void VulkanApp::RecreateSwapChain() {
        -: 1158:
    #####: 1159:    int width = 0, height = 0;
    #####: 1160:    glfwGetFramebufferSize(m_window, &width, &height);
    %%%%%: 1160-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1161:    while(width == 0 || height == 0) {
    %%%%%: 1161-block 3
    %%%%%: 1161-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1161-block 7
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 1162:        m_appNotifier.appStatus = IDLE;
    #####: 1163:        m_appNotifier.isDirty = true;
    #####: 1164:        glfwGetFramebufferSize(m_window, &width, &height);
    %%%%%: 1164-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1165:        glfwWaitEvents();
    %%%%%: 1165-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1166:    }
        -: 1167:
    #####: 1168:    vkDeviceWaitIdle(m_device);
    %%%%%: 1168-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1169:
    #####: 1170:    CleanupSwapChain();
    %%%%%: 1170-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1171:
    #####: 1172:    CreateSwapChain();
    %%%%%: 1172-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1173:    CreateImageViews();
    %%%%%: 1173-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1174:    CreateFrameBuffers();
    %%%%%: 1174-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1175:}
    %%%%%: 1175-block 13
        -: 1176:
function _ZN9VulkanApp19CreateLogicalDeviceEv called 1 returned 100% blocks executed 69%
        1: 1177:void VulkanApp::CreateLogicalDevice() {
        -: 1178:    //finds queue family with graphics capabilities VK_QUEUE_GRAPHICS_BIT
        1: 1179:    QueueFamilyIndices indices = FindQueueFamilies(m_physicalDevice, m_sruface);
        1: 1179-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1180:    std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;
        1: 1180-block 3
call    0 returned 1
        2: 1181:    std::set<uint32_t> uniqueQueueFamilies = {indices.graphicsFamily.value(), indices.presentFamily.value()};
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1181-block 5
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1: 1181-block 6
        1: 1181-block 8
call    6 returned 1
branch  7 taken 1 (fallthrough)
branch  8 taken 0 (throw)
    $$$$$: 1181-block 44
    $$$$$: 1181-block 45
    $$$$$: 1181-block 46
        -: 1182:
        1: 1183:    float queuePriority = 1.0f;
        2: 1184:    for (auto queueFamily: uniqueQueueFamilies) {
call    0 returned 1
call    1 returned 1
        1: 1184-block 12
call    2 returned 1
        1: 1184-block 14
call    3 returned 1
        2: 1184-block 15
call    4 returned 2
branch  5 taken 1
branch  6 taken 1 (fallthrough)
        1: 1185:        VkDeviceQueueCreateInfo queueCreateInfo{};
        1: 1186:        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        1: 1187:        queueCreateInfo.queueFamilyIndex = queueFamily;
        1: 1188:        queueCreateInfo.queueCount = 1;
        1: 1189:        queueCreateInfo.pQueuePriorities = &queuePriority;
        1: 1190:        queueCreateInfos.push_back(queueCreateInfo);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 1191:    }
        -: 1192:
        1: 1193:    VkPhysicalDeviceFeatures deviceFeatures{};
        1: 1194:    deviceFeatures.samplerAnisotropy = VK_TRUE;
        -: 1195:
        -: 1196:
        1: 1197:    VkDeviceCreateInfo createInfo{};
        1: 1198:    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
        1: 1199:    createInfo.pQueueCreateInfos = queueCreateInfos.data();
        1: 1199-block 17
call    0 returned 1
        1: 1200:    createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size());
call    0 returned 1
        1: 1201:    createInfo.pEnabledFeatures = &deviceFeatures;
        1: 1202:    createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtentions.size());
call    0 returned 1
        1: 1203:    createInfo.ppEnabledExtensionNames = deviceExtentions.data();
call    0 returned 1
        -: 1204:    if (enableValidationLayers) {
        1: 1205:        createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
        1: 1205-block 22
call    0 returned 1
        1: 1206:        createInfo.ppEnabledLayerNames = validationLayers.data();
call    0 returned 1
        -: 1207:    } else {
        -: 1208:        createInfo.enabledLayerCount = 0;
        -: 1209:    }
        -: 1210:
        1: 1211:    if (vkCreateDevice(m_physicalDevice, &createInfo, nullptr, &m_device) != VK_SUCCESS) {
        1: 1211-block 25
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1211-block 26
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####: 1212:        throw std::runtime_error("Failed to create logical device !");
    %%%%%: 1212-block 27
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1212-block 29
call    4 never executed
    $$$$$: 1212-block 49
call    5 never executed
        -: 1213:    }
        -: 1214:
        1: 1215:    vkGetDeviceQueue(m_device, indices.graphicsFamily.value(), 0, &m_graphicsQueue);
        1: 1215-block 30
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1215-block 31
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1: 1216:    vkGetDeviceQueue(m_device, indices.presentFamily.value(), 0, &m_presentationQueue);
        1: 1216-block 32
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1216-block 33
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1: 1217:    vkGetDeviceQueue(m_device, indices.presentFamily.value(), 0, &m_transferQueue);
        1: 1217-block 34
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1217-block 35
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        -: 1218:
        1: 1219:    this->m_material = std::make_unique<Material>(m_device);
        1: 1219-block 36
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1219-block 37
call    3 returned 1
call    4 returned 1
    $$$$$: 1219-block 51
        1: 1220:}
call    0 returned 1
call    1 returned 1
    $$$$$: 1220-block 52
call    2 never executed
    $$$$$: 1220-block 54
call    3 never executed
        -: 1221:
function _ZN9VulkanApp13CreateSurfaceEv called 1 returned 100% blocks executed 50%
        1: 1222:void VulkanApp::CreateSurface() {
        1: 1223:    if (glfwCreateWindowSurface(m_instance, m_window, nullptr, &m_sruface) != VK_SUCCESS) {
        1: 1223-block 2
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1224:        throw std::runtime_error("Failed to create window surface");
    %%%%%: 1224-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1224-block 6
call    4 never executed
    $$$$$: 1224-block 8
call    5 never executed
        -: 1225:    }
        1: 1226:}
        1: 1226-block 7
        -: 1227:
function _ZN9VulkanApp21GetRequiredExtentionsEv called 1 returned 100% blocks executed 60%
        1: 1228:std::vector<const char *> VulkanApp::GetRequiredExtentions() {
        1: 1229:    uint32_t glfwExtentionsCount = 0;
        -: 1230:    const char **glfwExtentions;
        1: 1231:    glfwExtentions = glfwGetRequiredInstanceExtensions(&glfwExtentionsCount);
        1: 1231-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1231-block 3
        -: 1232:
        1: 1233:    std::vector<const char *> extensions(glfwExtentions, glfwExtentions + glfwExtentionsCount);
        1: 1233-block 5
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$: 1233-block 12
        -: 1234:
        -: 1235:    if (enableValidationLayers) {
        1: 1236:        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$: 1236-block 13
        -: 1237:    }
        -: 1238:
        1: 1239:    return extensions;
        1: 1239-block 8
        1: 1239-block 9
    =====: 1240:}
    $$$$$: 1240-block 14
call    0 never executed
        -: 1241:
function _ZN9VulkanApp19SetUpDebugMessengerEv called 1 returned 100% blocks executed 64%
        1: 1242:void VulkanApp::SetUpDebugMessenger() {
        1: 1242-block 2
        -: 1243:    if (!enableValidationLayers) return;
        -: 1244:
        -: 1245:    VkDebugUtilsMessengerCreateInfoEXT createInfo;
        1: 1246:    PopulateDebugMessengerCreateInfo(createInfo);
        1: 1246-block 3
call    0 returned 1
        -: 1247:
        1: 1248:    if (CreateDebugUtilsMessengerEXT(m_instance, &createInfo, nullptr, &m_debugMessanger) != VK_SUCCESS) {
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1248-block 5
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####: 1249:        throw std::runtime_error("Failed to create a debug messenger");
    %%%%%: 1249-block 6
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1249-block 8
call    4 never executed
    $$$$$: 1249-block 13
call    5 never executed
        -: 1250:    } else
        1: 1251:        std::cout << "Debug messenger created" << std::endl;
        1: 1251-block 9
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1251-block 10
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        -: 1252:}
        -: 1253:
function _ZN9VulkanApp7CleanUpEv called 1 returned 100% blocks executed 100%
        1: 1254:void VulkanApp::CleanUp() {
        3: 1255:    for(size_t i  =0; i< MAX_FRAMES_IN_FLIGHT; i++) {
        1: 1255-block 2
        3: 1255-block 10
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        2: 1256:        vkDestroySemaphore(m_device, m_imageAvailableSemaphores[i], nullptr);
        2: 1256-block 3
call    0 returned 2
call    1 returned 2
        2: 1257:        vkDestroySemaphore(m_device, m_renderFinishedSemaphores[i], nullptr);
call    0 returned 2
call    1 returned 2
        2: 1258:        vkDestroyFence(m_device, m_inFlightFences[i], nullptr);
call    0 returned 2
call    1 returned 2
        -: 1259:    }
        1: 1260:    vkDestroyCommandPool(m_device, m_comandPool, nullptr);
        1: 1260-block 11
call    0 returned 1
        1: 1261:    vkDestroyCommandPool(m_device, m_transferCommandPool, nullptr);
call    0 returned 1
        -: 1262:
        1: 1263:    CleanupSwapChain();
call    0 returned 1
        -: 1264:    //vkDestroyImageView(m_device, m_textureImageView, nullptr);
        -: 1265:    //vkDestroyImage(m_device, m_textureImage, nullptr);
        -: 1266://    vkFreeMemory(m_device, m_textureImageMemory, nullptr);
        1: 1267:    vkDestroySampler(m_device, m_textureSampler, nullptr);
call    0 returned 1
        -: 1268:
        3: 1269:    for(size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        3: 1269-block 21
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        2: 1270:        vkDestroyBuffer(m_device, m_uniformBuffers[i], nullptr);
        2: 1270-block 16
call    0 returned 2
call    1 returned 2
        2: 1271:        vkFreeMemory(m_device, m_uniformBuffersMemory[i], nullptr);
call    0 returned 2
call    1 returned 2
        -: 1272:    }
        -: 1273:
        1: 1274:    vkDestroyDescriptorPool(m_device, m_descriptorPool, nullptr);
        1: 1274-block 22
call    0 returned 1
        1: 1275:    vkDestroyDescriptorSetLayout(m_device, m_descriptorSetLayout, nullptr);
call    0 returned 1
        -: 1276:
        1: 1277:    vkDestroyBuffer(m_device, m_vertexBuffer, nullptr);
call    0 returned 1
        1: 1278:    vkFreeMemory(m_device, m_vertexBufferMemory, nullptr);
call    0 returned 1
        -: 1279:
        1: 1280:    vkDestroyBuffer(m_device, m_indexBuffer, nullptr);
call    0 returned 1
        1: 1281:    vkFreeMemory(m_device, m_indexBufferMemory, nullptr);
call    0 returned 1
        1: 1282:    m_material.reset();
call    0 returned 1
        1: 1283:    vkDestroyPipeline(m_device, m_graphicsPipeline, nullptr);
call    0 returned 1
        1: 1284:    vkDestroyPipelineLayout(m_device, m_pipelineLayout, nullptr);
call    0 returned 1
        1: 1285:    vkDestroyRenderPass(m_device, m_renderPass, nullptr);
call    0 returned 1
        -: 1286:    if (enableValidationLayers) {
        1: 1287:        DestroyDebugUtilsMessengerEXT(m_instance, m_debugMessanger, nullptr);
call    0 returned 1
        -: 1288:    }
        1: 1289:    vkDestroyDevice(m_device, nullptr);
call    0 returned 1
        1: 1290:    vkDestroySurfaceKHR(m_instance, m_sruface, nullptr);
call    0 returned 1
        1: 1291:    vkDestroyInstance(m_instance, nullptr);
call    0 returned 1
        1: 1292:    glfwDestroyWindow(m_window);
call    0 returned 1
        1: 1293:    glfwTerminate();
call    0 returned 1
        1: 1294:}
        -: 1295:
function _ZN9VulkanApp25FrameBufferResizeCallbackEP10GLFWwindowii called 0 returned 0% blocks executed 0%
    #####: 1296:void VulkanApp::FrameBufferResizeCallback(GLFWwindow *window, int width, int height) {
    #####: 1297:    std::cout<<"Resize x: "<<width<<"y: "<<height<<std::endl;
    %%%%%: 1297-block 2
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1298:    auto app = reinterpret_cast<VulkanApp*>(glfwGetWindowUserPointer((window)));
call    0 never executed
    #####: 1299:    app->m_frameBufferResized = true;
    #####: 1300:    app->m_camera->processResize(width, height);
call    0 never executed
call    1 never executed
    #####: 1301:}
        -: 1302:
function _ZN9VulkanApp21MousePositionCallbackEP10GLFWwindowdd called 276 returned 100% blocks executed 100%
      276: 1303:void VulkanApp::MousePositionCallback(GLFWwindow *window, double xpos, double ypos) {
      276: 1304:    auto app = reinterpret_cast<VulkanApp*>(glfwGetWindowUserPointer((window)));
      276: 1304-block 2
call    0 returned 276
      276: 1305:    auto pointerX = (float)xpos;
      276: 1306:    auto pointerY = (float)ypos;
      276: 1307:     if (app->m_isFirstMouse) {
branch  0 taken 1 (fallthrough)
branch  1 taken 275
        1: 1308:            app->m_lastX = xpos;
        1: 1309:            app->m_lastY = ypos;
        1: 1310:            app->m_isFirstMouse = false;;
        1: 1310-block 4
        -: 1311:        }
        -: 1312:
      276: 1313:        float xOffset = xpos - app->m_lastX;
      276: 1314:        float yOffset = app->m_lastY - ypos; // Invert the sign here
        -: 1315:
      276: 1316:        app->m_lastX = xpos;
      276: 1317:        app->m_lastY = ypos;
        -: 1318:
      276: 1319:        xOffset *= 0.01;
      276: 1320:        yOffset *= 0.01;
        -: 1321:
      276: 1322:        if (xOffset != 0.0 && app->m_isMousePressed) {
      276: 1322-block 5
branch  0 taken 230 (fallthrough)
branch  1 taken 46
      230: 1322-block 6
branch  2 taken 111 (fallthrough)
branch  3 taken 119
      111: 1323:            app->m_camera->rotateAzimutn(xOffset);
      111: 1323-block 7
call    0 returned 111
call    1 returned 111
        -: 1324:        }
        -: 1325:
      276: 1326:        if (yOffset != 0.0 && app->m_isMousePressed ) {
      276: 1326-block 9
branch  0 taken 247 (fallthrough)
branch  1 taken 29
      247: 1326-block 10
branch  2 taken 110 (fallthrough)
branch  3 taken 137
      110: 1327:            app->m_camera->rotatePolar(-yOffset);
      110: 1327-block 11
call    0 returned 110
call    1 returned 110
        -: 1328:        }
        -: 1329:
      276: 1330:}
        -: 1331:
function _ZN9VulkanApp18MouseClickCallbackEP10GLFWwindowiii called 4 returned 100% blocks executed 100%
        4: 1332:void VulkanApp::MouseClickCallback(GLFWwindow *window, int button, int action, int mods) {
        4: 1333:    auto app = reinterpret_cast<VulkanApp*>(glfwGetWindowUserPointer((window)));
        4: 1333-block 2
call    0 returned 4
        4: 1334:    GLFWcursor *hand = glfwCreateStandardCursor(GLFW_HAND_CURSOR);
call    0 returned 4
        4: 1335:    GLFWcursor *cursor = glfwCreateStandardCursor(GLFW_CURSOR_NORMAL);
call    0 returned 4
        4: 1336:    if (button == GLFW_MOUSE_BUTTON_LEFT) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1337:        if (action == GLFW_PRESS) {
        4: 1337-block 6
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2: 1338:            app->m_isMousePressed = true;
        2: 1339:            glfwSetCursor(app->m_window, hand);
        2: 1339-block 7
call    0 returned 2
        -: 1340:
        2: 1341:        } else if (action == GLFW_RELEASE) {
        2: 1341-block 8
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1342:            app->m_isMousePressed = false;
        2: 1343:            glfwSetCursor(app->m_window, cursor);
        2: 1343-block 9
call    0 returned 2
        -: 1344:        }
        -: 1345:    }
        4: 1346:}
        -: 1347:
function _ZN9VulkanApp19MouseScrollCallbackEP10GLFWwindowdd called 24 returned 100% blocks executed 100%
       24: 1348:void VulkanApp::MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset) {
       24: 1349:    auto app = reinterpret_cast<VulkanApp*>(glfwGetWindowUserPointer((window)));
       24: 1349-block 2
call    0 returned 24
       24: 1350:    app->m_camera->zoom((float) yoffset);
call    0 returned 24
call    1 returned 24
       24: 1351:}
        -: 1352:
function _ZN9VulkanApp24GenerateGeometryVerticesE13GEOMETRY_TYPE called 1 returned 100% blocks executed 50%
        1: 1353:void VulkanApp::GenerateGeometryVertices(GEOMETRY_TYPE geometryType) {
        1: 1354:    m_geometryType = geometryType;
        1: 1355:    switch(geometryType) {
        1: 1355-block 2
branch  0 taken 0
branch  1 taken 1
branch  2 taken 0
branch  3 taken 0
    #####: 1356:        case CUBE: {
    #####: 1357:            vertices = VertexData::cubeVertices;
    %%%%%: 1357-block 3
call    0 never executed
    #####: 1358:            indices = VertexData::cubeIndices;
call    0 never executed
    #####: 1359:            break;
        -: 1360:        }
        1: 1361:        case PLANE: {
        1: 1362:            vertices = VertexData::planeVertices;
        1: 1362-block 6
call    0 returned 1
        1: 1363:            indices = VertexData::planeIndices;
call    0 returned 1
        1: 1364:            break;
    #####: 1365:        }case SPHERE: {
    #####: 1366:            GenerateSphere(vertices, indices);
    %%%%%: 1366-block 9
call    0 never executed
    #####: 1367:            break;
        -: 1368:        }
        -: 1369:    }
        1: 1370:}
